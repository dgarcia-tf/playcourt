const API_BASE = '/app/api';
const APP_BRAND_NAME = 'PlayCourt';
const APP_BRAND_SLOGAN = 'Tenis & Padel';
const STORAGE_PREFIX = 'playcourt';
const STORAGE_KEY = `${STORAGE_PREFIX}-app-session`;
const REMEMBER_CREDENTIALS_KEY = `${STORAGE_PREFIX}-remember-credentials`;
const NOTICE_LAST_SEEN_PREFIX = `${STORAGE_PREFIX}-notices-last-seen:`;
const MAX_PHOTO_SIZE = 2 * 1024 * 1024;
const MAX_POSTER_SIZE = 5 * 1024 * 1024;
const MAX_NOTICE_ATTACHMENT_SIZE = 3 * 1024 * 1024;
const MAX_NOTICE_ATTACHMENTS = 5;
const MAX_INLINE_NOTICE_IMAGE_SIZE = MAX_NOTICE_ATTACHMENT_SIZE;
const MAX_TOTAL_INLINE_NOTICE_IMAGE_SIZE = MAX_INLINE_NOTICE_IMAGE_SIZE * 2;
const MAX_NOTICE_RICH_CONTENT_LENGTH = 12000;
const MAX_NOTICE_RICH_CONTENT_WITH_IMAGES = 600000;
const NOTICE_INLINE_IMAGE_DATA_URL_PATTERN = /^data:image\/[a-z0-9.+-]+;base64,/i;
const NOTICE_INLINE_IMAGE_SRC_REGEX = /<img[^>]+src\s*=\s*["']([^"']+)["'][^>]*>/gi;
const COURT_RESERVATION_DEFAULT_DURATION = 75;
const CALENDAR_TIME_SLOT_MINUTES = COURT_RESERVATION_DEFAULT_DURATION;
const CALENDAR_TIME_SLOT_STEP_SECONDS = CALENDAR_TIME_SLOT_MINUTES * 60;
const COURT_RESERVATION_FIRST_SLOT_MINUTE = 8 * 60 + 30;
const COURT_RESERVATION_LAST_SLOT_END_MINUTE = 22 * 60 + 15;

const SCHEDULE_LABELS = {
  manana: 'Mañana',
  tarde: 'Tarde',
  noche: 'Noche',
  fin_de_semana: 'Fin de semana',
  flexible: 'Flexible',
};

const WEEKDAY_OPTIONS = [
  { value: 'monday', label: 'Lunes' },
  { value: 'tuesday', label: 'Martes' },
  { value: 'wednesday', label: 'Miércoles' },
  { value: 'thursday', label: 'Jueves' },
  { value: 'friday', label: 'Viernes' },
  { value: 'saturday', label: 'Sábado' },
  { value: 'sunday', label: 'Domingo' },
];

const WEEKDAY_LABEL_BY_VALUE = WEEKDAY_OPTIONS.reduce((map, option) => {
  map[option.value] = option.label;
  return map;
}, {});

const STATUS_LABELS = {
  pendiente: 'Pendiente',
  propuesto: 'Propuesto',
  programado: 'Programado',
  revision: 'Resultado pendiente',
  completado: 'Completado',
  caducado: 'Caducado',
};

const CALENDAR_MATCH_STATUSES = [
  'pendiente',
  'propuesto',
  'programado',
  'revision',
  'completado',
  'finalizado',
];

const MATCH_EXPIRATION_DAYS = 15;
const MATCHES_PER_PAGE = 10;
const LEAGUE_ENROLLED_PAGE_SIZE = 10;
const MATCH_CALENDAR_DEFAULT_DURATION_MINUTES = 90;
const UNCATEGORIZED_CATEGORY_KEY = '__uncategorized__';
const UNCATEGORIZED_CATEGORY_LABEL = 'Sin categoría';
const DAY_IN_MS = 24 * 60 * 60 * 1000;
const TOURNAMENT_BRACKET_SIZES = [8, 16, 32];
const TOURNAMENT_CATEGORY_DRAW_SIZE_OPTIONS = [8, 16, 32];
const TOURNAMENT_BRACKET_REPLACEMENT_CONFIRMATION =
  'El cuadro actual desaparecerá y se generará uno nuevo. ¿Deseas continuar?';
const TOURNAMENT_BRACKET_REPLACEMENT_TOOLTIP =
  'Generar un nuevo cuadro reemplazará el actual.';
const TOURNAMENT_BRACKET_RESULTS_REPLACEMENT_CONFIRMATION =
  'El cuadro actual tiene resultados registrados. Generar un nuevo cuadro eliminará los resultados anteriores. ¿Deseas continuar?';
const TOURNAMENT_BRACKET_RESULTS_REPLACEMENT_TOOLTIP =
  'Generar un nuevo cuadro eliminará los resultados registrados en esta categoría.';

const PUSH_SUPPORTED =
  typeof window !== 'undefined' &&
  'serviceWorker' in navigator &&
  'PushManager' in window &&
  'Notification' in window;

const DEFAULT_APP_BASE_PATH = '/app';

const SECTION_ROUTE_ENTRIES = [
  ['panel', 'section-dashboard'],
  ['', 'section-dashboard'],
  ['reservas', 'section-court-reservations'],
  ['noticias', 'section-chat'],
  ['notificaciones', 'section-notifications'],
  ['ligas', 'section-league-dashboard'],
  ['ligas/inscribirse', 'section-leagues'],
  ['ligas/categorias', 'section-categories'],
  ['ligas/jugadores', 'section-league-players'],
  ['ligas/pagos', 'section-league-payments'],
  ['ligas/partidos', 'section-matches'],
  ['ligas/calendario', 'section-calendar'],
  ['ligas/ranking', 'section-ranking'],
  ['ligas/reglamento', 'section-rules'],
  ['torneos/panel', 'section-tournament-dashboard'],
  ['torneos', 'section-tournaments'],
  ['torneos/categorias', 'section-tournament-categories'],
  ['torneos/cuadros', 'section-tournament-brackets'],
  ['torneos/inscripciones', 'section-tournament-enrollments'],
  ['torneos/dobles', 'section-tournament-doubles'],
  ['torneos/pagos', 'section-tournament-payments'],
  ['torneos/partidos', 'section-tournament-matches'],
  ['torneos/reglamento', 'section-tournament-rules'],
  ['administracion', 'section-admin'],
  ['administracion/club', 'section-club'],
  ['administracion/pistas', 'section-court-admin'],
  ['administracion/usuarios', 'section-user-directory'],
  ['administracion/modo-demo', 'section-demo-mode'],
  ['mi-cuenta', 'section-account'],
];

const SECTION_ROUTE_TO_ID = new Map(SECTION_ROUTE_ENTRIES);

const SECTION_ID_TO_ROUTE = new Map();
SECTION_ROUTE_ENTRIES.forEach(([route, sectionId]) => {
  if (!SECTION_ID_TO_ROUTE.has(sectionId) && route) {
    SECTION_ID_TO_ROUTE.set(sectionId, route);
  }
});
if (!SECTION_ID_TO_ROUTE.has('section-dashboard')) {
  SECTION_ID_TO_ROUTE.set('section-dashboard', '');
}

function resolveAppBasePath() {
  if (typeof document === 'undefined') {
    return DEFAULT_APP_BASE_PATH;
  }

  const datasetValue = document.body?.dataset?.appBasePath;
  if (datasetValue) {
    return datasetValue;
  }

  if (typeof window !== 'undefined' && window.location?.pathname) {
    const { pathname } = window.location;
    if (pathname.startsWith(DEFAULT_APP_BASE_PATH)) {
      return DEFAULT_APP_BASE_PATH;
    }

    if (!pathname || pathname === '/') {
      return '/';
    }

    const segments = pathname.split('/').filter(Boolean);
    if (segments.length) {
      return `/${segments[0]}`;
    }
  }

  return DEFAULT_APP_BASE_PATH;
}

const APP_BASE_PATH = resolveAppBasePath();

let shouldReplaceHistoryOnNextSection = false;

function normalizeHistoryPath(path) {
  if (typeof path !== 'string' || !path) {
    return APP_BASE_PATH || '/';
  }

  if (path.length > 1 && path.endsWith('/')) {
    return path.replace(/\/+$/, '');
  }

  return path;
}

function normalizeAppPath(pathname) {
  if (typeof pathname !== 'string') {
    return null;
  }

  const base = (APP_BASE_PATH || '').replace(/\/+$/, '');
  let remaining = pathname;

  if (base && base !== '/') {
    if (!remaining.startsWith(base)) {
      return null;
    }
    remaining = remaining.slice(base.length);
  }

  remaining = remaining.replace(/^\/+/, '').replace(/\/+$/, '');
  return remaining;
}

function getSectionIdFromPath(pathname) {
  const normalized = normalizeAppPath(pathname);
  if (normalized == null) {
    return null;
  }

  let routeKey = normalized;
  if (!routeKey) {
    return SECTION_ROUTE_TO_ID.get('') || 'section-dashboard';
  }

  try {
    routeKey = decodeURIComponent(routeKey);
  } catch (error) {
    // Ignorar errores de decodificación y continuar con la ruta original.
  }

  return SECTION_ROUTE_TO_ID.get(routeKey) || null;
}

function buildPathFromSection(sectionId) {
  if (typeof sectionId !== 'string' || !sectionId) {
    return APP_BASE_PATH || '/';
  }

  const base = (APP_BASE_PATH || '/').replace(/\/+$/, '') || '/';
  const slug = SECTION_ID_TO_ROUTE.get(sectionId);
  if (!slug) {
    return base || '/';
  }

  const normalizedSlug = slug
    .split('/')
    .map((segment) => segment.trim())
    .filter(Boolean)
    .join('/');

  if (!normalizedSlug) {
    return base || '/';
  }

  if (!base || base === '/' || base === '') {
    return `/${normalizedSlug}`;
  }

  return `${base}/${normalizedSlug}`;
}

function syncSectionRoute(sectionId, { replace = false } = {}) {
  if (typeof window === 'undefined' || !window.history) {
    return;
  }

  const targetPath = buildPathFromSection(sectionId);
  if (!targetPath) {
    return;
  }

  const statePayload = { section: sectionId };
  const normalizedTarget = normalizeHistoryPath(targetPath);
  const normalizedCurrent = normalizeHistoryPath(window.location.pathname || '/');

  if (replace || normalizedCurrent === normalizedTarget) {
    window.history.replaceState(statePayload, '', targetPath);
    return;
  }

  if (typeof window.history.pushState === 'function') {
    window.history.pushState(statePayload, '', targetPath);
  }
}

const CATEGORY_STATUS_LABELS = {
  inscripcion: 'Inscripción abierta',
  en_curso: 'En curso',
};

const CATEGORY_SKILL_LEVEL_OPTIONS = [
  { value: 'Iniciación', label: 'Iniciación' },
  { value: 'Intermedio', label: 'Intermedio' },
  { value: 'Avanzado', label: 'Avanzado' },
];

const DEFAULT_CATEGORY_MATCH_FORMAT = 'two_sets_six_games_super_tb';
const CATEGORY_MATCH_FORMAT_OPTIONS = [
  {
    value: 'two_sets_six_games_super_tb',
    label: '2 sets a 6 juegos + super tie-break',
  },
  {
    value: 'two_sets_four_games_super_tb',
    label: '2 sets a 4 juegos + super tie-break',
  },
  {
    value: 'single_set_ten_games_super_tb',
    label: '1 set a 10 juegos + super tie-break',
  },
];

const TOURNAMENT_MATCH_TYPE_OPTIONS = [
  { value: 'individual', label: 'Individual' },
  { value: 'dobles', label: 'Dobles' },
];

const TOURNAMENT_MATCH_TYPE_LABELS = TOURNAMENT_MATCH_TYPE_OPTIONS.reduce((map, option) => {
  map[option.value] = option.label;
  return map;
}, {});

const MATCH_FORMAT_LABELS = CATEGORY_MATCH_FORMAT_OPTIONS.reduce((map, option) => {
  map[option.value] = option.label;
  return map;
}, {});

const MATCH_FORMAT_METADATA = {
  two_sets_six_games_super_tb: {
    label: '2 sets a 6 juegos + super tie-break',
    description:
      'Formato de partido: 2 sets a 6 juegos + super tie-break (el super tie-break se juega a 10 puntos).',
    minimumSets: 2,
    setDefinitions: [
      { number: 1, tieBreak: false, label: 'Set 1' },
      { number: 2, tieBreak: false, label: 'Set 2' },
      { number: 3, tieBreak: true, label: 'Super tie-break (10 puntos)' },
    ],
  },
  two_sets_four_games_super_tb: {
    label: '2 sets a 4 juegos + super tie-break',
    description:
      'Formato de partido: 2 sets a 4 juegos + super tie-break (el super tie-break se juega a 10 puntos).',
    minimumSets: 2,
    setDefinitions: [
      { number: 1, tieBreak: false, label: 'Set 1' },
      { number: 2, tieBreak: false, label: 'Set 2' },
      { number: 3, tieBreak: true, label: 'Super tie-break (10 puntos)' },
    ],
  },
  single_set_ten_games_super_tb: {
    label: '1 set a 10 juegos + super tie-break',
    description:
      'Formato de partido: 1 set a 10 juegos + super tie-break (a 10 puntos).',
    minimumSets: 1,
    setDefinitions: [
      { number: 1, tieBreak: false, label: 'Set 1' },
      { number: 2, tieBreak: true, label: 'Super tie-break (10 puntos)' },
    ],
  },
};

const LEAGUE_STATUS_LABELS = {
  activa: 'Activa',
  cerrada: 'Cerrada',
};

const TOURNAMENT_STATUS_LABELS = {
  inscripcion: 'Inscripción abierta',
  en_juego: 'En juego',
  finalizado: 'Finalizado',
};

const TOURNAMENT_CATEGORY_STATUS_LABELS = {
  inscripcion: 'Inscripción abierta',
  cuadros: 'Cuadros definidos',
  en_juego: 'En juego',
  finalizado: 'Finalizado',
};

const TOURNAMENT_ENROLLMENT_STATUS_LABELS = {
  pendiente: 'Pendiente',
  confirmada: 'Confirmada',
  cancelada: 'Cancelada',
};

const TOURNAMENT_ENROLLMENT_ALL_OPTION = '__all__';

const TOURNAMENT_MATCH_STATUS_LABELS = {
  pendiente: 'Pendiente',
  programado: 'Programado',
  confirmado: 'Confirmado',
  rechazado: 'Rechazado',
  completado: 'Completado',
};

const TOURNAMENT_RESULT_STATUS_LABELS = {
  sin_resultado: 'Sin resultado',
  pendiente_admin: 'Pendiente de validación',
  revision_requerida: 'Revisión requerida',
  confirmado: 'Confirmado',
};

const DEFAULT_RULE_SECTIONS = [
  {
    title: 'Filosofía del club',
    bullets: [
      'Promovemos el tenis social competitivo con un ambiente inclusivo para todos los niveles.',
      'Cada temporada prioriza el compañerismo, la mejora continua y el respeto entre rivales.',
      'Las decisiones deportivas se apoyan en la aplicación y el feedback de la comunidad.',
    ],
  },
  {
    title: 'Instalaciones y pistas',
    bullets: [
      'Disponemos de 4 pistas rápidas iluminadas y 2 pistas de arcilla disponibles con reserva previa.',
      'La app indica la pista asignada y permite actualizar la información si se produce un cambio de última hora.',
      'El estado de mantenimiento de cada pista se revisa semanalmente para garantizar superficies seguras.',
    ],
  },
  {
    title: 'Horarios recomendados',
    bullets: [
      'Bloques matutinos: 08:00 – 12:00 · Ideal para jugadores con horario flexible.',
      'Bloques vespertinos: 16:00 – 19:00 · Mayor disponibilidad de monitores y personal de apoyo.',
      'Bloques nocturnos: 19:00 – 22:15 · Iluminación LED en todas las pistas rápidas.',
    ],
  },
  {
    title: 'Formato de juego',
    bullets: [
      'Cada partido se disputa al mejor de tres sets. Si cada jugador gana un set, se define por super tie-break a 10 puntos.',
      'Las victorias otorgan 10 puntos al ranking general más un punto por cada juego ganado.',
      'Los resultados deben ser confirmados por ambos jugadores; el administrador puede validar o corregir marcadores en caso de disputa.',
    ],
  },
  {
    title: 'Conducta y fair play',
    bullets: [
      'Respeta los horarios acordados y avisa con al menos 24 horas de antelación si necesitas reprogramar.',
      'Se prohíbe el lenguaje ofensivo o discriminatorio en pista y en los canales de chat; las infracciones podrán sancionarse.',
      'El uso de la app para confirmar asistencia, registrar resultados y gestionar categorías es obligatorio para mantener el histórico de la liga.',
    ],
  },
];

const MOVEMENT_ICON_PATHS = {
  up: 'M12 7l4 4h-3v6h-2v-6H8l4-4z',
  down: 'M12 17l-4-4h3V7h2v6h3l-4 4z',
  same: 'M8 11h8v2H8z',
  new: 'M12 7v4h4v2h-4v4h-2v-4H6v-2h4V7z',
};

const MOVEMENT_STYLES = {
  up: { color: '#2563eb', background: '#dbeafe' },
  down: { color: '#dc2626', background: '#fee2e2' },
  same: { color: '#475569', background: '#e2e8f0' },
  new: { color: '#0f766e', background: '#ccfbf1' },
};

const CATEGORY_COLOR_PALETTE = Object.freeze(['#2563EB', '#9333EA', '#F97316', '#059669']);
const DEFAULT_CATEGORY_COLOR = CATEGORY_COLOR_PALETTE[0];
const HEX_COLOR_INPUT_REGEX = /^#?([0-9a-fA-F]{3}|[0-9a-fA-F]{6})$/;
const PAYMENT_STATUS_LABELS = {
  pendiente: 'Pendiente',
  pagado: 'Pagado',
  exento: 'Exento',
  fallido: 'Fallido',
};

const LEAGUE_PAYMENT_METHOD_OPTIONS = ['Transferencia', 'Tarjeta', 'Efectivo'];
const PAYMENT_STATUS_ORDER = {
  pendiente: 0,
  pagado: 1,
  exento: 2,
  fallido: 3,
};
const DEFAULT_LEAGUE_CURRENCY = 'EUR';
const TOURNAMENT_PAYMENT_METHOD_OPTIONS = LEAGUE_PAYMENT_METHOD_OPTIONS;
const DEFAULT_TOURNAMENT_CURRENCY = 'EUR';

function normalizeHexColor(value) {
  if (typeof value !== 'string') {
    return '';
  }

  const trimmed = value.trim();
  if (!trimmed.length) {
    return '';
  }

  const match = trimmed.match(HEX_COLOR_INPUT_REGEX);
  if (!match) {
    return '';
  }

  let hex = match[1];
  if (hex.length === 3) {
    hex = hex
      .split('')
      .map((char) => `${char}${char}`)
      .join('');
  }

  return `#${hex.toUpperCase()}`;
}

function hexToRgb(hexValue) {
  const normalized = normalizeHexColor(hexValue);
  if (!normalized) {
    return null;
  }

  const hex = normalized.slice(1);
  const r = Number.parseInt(hex.slice(0, 2), 16);
  const g = Number.parseInt(hex.slice(2, 4), 16);
  const b = Number.parseInt(hex.slice(4, 6), 16);

  if ([r, g, b].some((component) => Number.isNaN(component))) {
    return null;
  }

  return { r, g, b, hex: normalized };
}

function hexToRgba(hexValue, alpha = 1) {
  const rgb = hexToRgb(hexValue);
  if (!rgb) {
    return '';
  }

  const safeAlpha = Number.isFinite(alpha) ? Math.min(Math.max(alpha, 0), 1) : 1;
  return `rgba(${rgb.r}, ${rgb.g}, ${rgb.b}, ${safeAlpha})`;
}

function resolveCategoryColor(value, fallback = DEFAULT_CATEGORY_COLOR) {
  const normalized = normalizeHexColor(value);
  if (normalized && CATEGORY_COLOR_PALETTE.includes(normalized)) {
    return normalized;
  }

  const normalizedFallback = normalizeHexColor(fallback);
  if (normalizedFallback && CATEGORY_COLOR_PALETTE.includes(normalizedFallback)) {
    return normalizedFallback;
  }

  return DEFAULT_CATEGORY_COLOR;
}

function getCategoryColor(category) {
  if (!category) {
    return DEFAULT_CATEGORY_COLOR;
  }

  const candidate = typeof category === 'string' ? category : category.color;
  return resolveCategoryColor(candidate);
}

function applyCategoryColorStyles(
  element,
  color,
  { backgroundAlpha = 0.12, borderAlpha = 0.28, shadowAlpha } = {}
) {
  if (!element) return;
  const normalized = resolveCategoryColor(color);

  const background = hexToRgba(normalized, backgroundAlpha);
  const border = hexToRgba(normalized, borderAlpha);

  if (background) {
    element.style.backgroundColor = background;
  }
  if (border) {
    element.style.borderColor = border;
  }
  element.style.setProperty('--category-color', normalized);
  if (typeof shadowAlpha === 'number') {
    const shadow = hexToRgba(normalized, shadowAlpha);
    element.style.boxShadow = `0 10px 22px ${shadow}`;
  }

  element.classList.add('category-colored');
}

function applyCategoryTagColor(tag, color, { backgroundAlpha = 0.18 } = {}) {
  if (!tag) return;
  const normalized = resolveCategoryColor(color);

  const background = hexToRgba(normalized, backgroundAlpha);
  if (background) {
    tag.style.backgroundColor = background;
  }
  tag.style.color = normalized;
}

function createCategoryColorIndicator(color, label = '') {
  const normalized = resolveCategoryColor(color);
  if (!normalized) return null;

  const indicator = document.createElement('span');
  indicator.className = 'category-color-indicator';
  indicator.style.setProperty('--category-color', normalized);
  indicator.setAttribute('aria-hidden', 'true');
  if (label) {
    indicator.title = `Color de ${label}`;
  } else {
    indicator.title = `Color ${normalized}`;
  }
  return indicator;
}

function renderCategoryColorField({
  name = 'color',
  legend = 'Color identificativo',
  hint = '',
  selected,
} = {}) {
  const activeColor = resolveCategoryColor(selected);
  const options = CATEGORY_COLOR_PALETTE.map((color) => {
    const checked = color === activeColor ? 'checked' : '';
    return `
      <label class="color-select-option">
        <input type="radio" name="${name}" value="${color}" ${checked} />
        <span class="color-swatch" style="--option-color: ${color}" aria-hidden="true"></span>
        <span class="color-select-label">${color}</span>
      </label>
    `;
  }).join('');

  return `
    <fieldset class="color-select">
      <legend>${legend}</legend>
      <div class="color-select-options">
        ${options}
      </div>
      ${hint ? `<span class="form-hint">${hint}</span>` : ''}
    </fieldset>
  `;
}

function cloneDefaultRegulationSections() {
  return DEFAULT_RULE_SECTIONS.map((section) => ({
    title: typeof section.title === 'string' ? section.title : '',
    description: typeof section.description === 'string' ? section.description : '',
    bullets: Array.isArray(section.bullets) ? [...section.bullets] : [],
  }));
}

function convertRegulationSectionsToHtml(sections = []) {
  return sections
    .map((section) => {
      const parts = [];
      if (section.title) {
        parts.push(`<h2>${escapeHtml(section.title)}</h2>`);
      }
      if (section.description) {
        parts.push(`<p>${escapeHtml(section.description)}</p>`);
      }
      if (Array.isArray(section.bullets) && section.bullets.length) {
        const items = section.bullets
          .map((item) => `<li>${escapeHtml(item)}</li>`)
          .join('');
        parts.push(`<ul>${items}</ul>`);
      }
      return parts.join('');
    })
    .join('')
    .trim();
}

function normalizeRegulationSection(entry = {}) {
  const title = typeof entry.title === 'string' ? entry.title.trim() : '';
  const description = typeof entry.description === 'string' ? entry.description.trim() : '';
  const bullets = Array.isArray(entry.bullets)
    ? entry.bullets
        .map((item) => (typeof item === 'string' ? item.trim() : ''))
        .filter((item) => item.length > 0)
    : [];

  if (!title && !description && !bullets.length) {
    return null;
  }

  const section = { title };
  if (description) {
    section.description = description;
  }
  if (bullets.length) {
    section.bullets = bullets;
  }
  return section;
}

function getDefaultRegulationHtml() {
  const fallbackSections = cloneDefaultRegulationSections();
  const html = convertRegulationSectionsToHtml(fallbackSections);
  return sanitizeNoticeHtml(html);
}

function getRegulationHtml(rawRegulation) {
  const raw = typeof rawRegulation === 'string' ? rawRegulation.trim() : '';

  if (!raw) {
    return getDefaultRegulationHtml();
  }

  if (raw.startsWith('[')) {
    try {
      const parsed = JSON.parse(raw);
      if (Array.isArray(parsed)) {
        const normalized = parsed.map((entry) => normalizeRegulationSection(entry)).filter(Boolean);
        if (normalized.length) {
          const legacyHtml = convertRegulationSectionsToHtml(normalized);
          const sanitizedLegacy = sanitizeNoticeHtml(legacyHtml);
          if (sanitizedLegacy) {
            return sanitizedLegacy;
          }
        }
      }
    } catch (error) {
      console.warn('No se pudo interpretar el reglamento guardado. Se intentará mostrar el contenido original.', error);
    }
  }

  const sanitizedExisting = sanitizeNoticeHtml(raw);
  if (sanitizedExisting) {
    if (raw.startsWith('[') && sanitizedExisting === raw) {
      return getDefaultRegulationHtml();
    }
    return sanitizedExisting;
  }

  const escaped = escapeHtml(raw);
  if (escaped) {
    return `<p>${escaped}</p>`;
  }

  return getDefaultRegulationHtml();
}

function escapeHtml(value) {
  if (value === null || value === undefined) return '';
  return String(value)
    .replace(/&/g, '&amp;')
    .replace(/</g, '&lt;')
    .replace(/>/g, '&gt;')
    .replace(/"/g, '&quot;')
    .replace(/'/g, '&#39;');
}

function getClubCourtNames() {
  const club = state.club || {};
  const courts = Array.isArray(club.courts) ? club.courts : [];
  const names = courts
    .map((entry) => (entry && typeof entry.name === 'string' ? entry.name.trim() : ''))
    .filter(Boolean);
  return Array.from(new Set(names));
}

function parseTimeStringToMinutes(value) {
  if (typeof value !== 'string') {
    return null;
  }

  const trimmed = value.trim();
  if (!trimmed) {
    return null;
  }

  const match = trimmed.match(/^([0-9]{1,2}):([0-5][0-9])$/);
  if (!match) {
    return null;
  }

  const hours = Number(match[1]);
  const minutes = Number(match[2]);

  if (!Number.isFinite(hours) || !Number.isFinite(minutes)) {
    return null;
  }

  if (hours < 0 || hours > 23) {
    return null;
  }

  return hours * 60 + minutes;
}

function getWeekdayValueFromIndex(index) {
  switch (index) {
    case 0:
      return 'sunday';
    case 1:
      return 'monday';
    case 2:
      return 'tuesday';
    case 3:
      return 'wednesday';
    case 4:
      return 'thursday';
    case 5:
      return 'friday';
    case 6:
      return 'saturday';
    default:
      return '';
  }
}

function normalizeClubScheduleEntry(entry, index) {
  if (!entry) {
    return null;
  }

  const label = typeof entry.label === 'string' ? entry.label.trim() : '';
  if (!label) {
    return null;
  }

  return {
    id: `${index}`,
    label,
    dayValue: getDayValueFromLabel(label),
    opensMinutes: parseTimeStringToMinutes(entry.opensAt),
    closesMinutes: parseTimeStringToMinutes(entry.closesAt),
  };
}

function getClubMatchScheduleTemplates() {
  const club = state.club || {};
  const schedules = Array.isArray(club.schedules) ? club.schedules : [];
  const normalized = schedules.map(normalizeClubScheduleEntry).filter(Boolean);
  if (normalized.length > 0) {
    return normalized;
  }

  return [
    {
      id: 'default',
      label: 'Horario del club',
      dayValue: '',
      opensMinutes: COURT_RESERVATION_FIRST_SLOT_MINUTE,
      closesMinutes: COURT_RESERVATION_LAST_SLOT_END_MINUTE,
    },
  ];
}

function buildSlotsForScheduleEntry(entry, baseDate) {
  if (!entry || !(baseDate instanceof Date) || Number.isNaN(baseDate.getTime())) {
    return [];
  }

  const slots = [];
  const startMinutes = Number.isFinite(entry.opensMinutes)
    ? Math.max(entry.opensMinutes, COURT_RESERVATION_FIRST_SLOT_MINUTE)
    : COURT_RESERVATION_FIRST_SLOT_MINUTE;
  const endMinutes = Number.isFinite(entry.closesMinutes)
    ? Math.min(entry.closesMinutes, COURT_RESERVATION_LAST_SLOT_END_MINUTE)
    : COURT_RESERVATION_LAST_SLOT_END_MINUTE;

  const lastStart = endMinutes - COURT_RESERVATION_DEFAULT_DURATION;
  if (lastStart < startMinutes) {
    return slots;
  }

  for (let minute = startMinutes; minute <= lastStart; minute += COURT_RESERVATION_DEFAULT_DURATION) {
    const start = addMinutes(baseDate, minute);
    const end = addMinutes(start, COURT_RESERVATION_DEFAULT_DURATION);
    slots.push({
      value: formatTimeInputValue(start),
      label: formatTimeRangeLabel(start, end),
    });
  }

  return slots;
}

function getMatchScheduleSlotOptionsForDate(dateValue, templates = getClubMatchScheduleTemplates()) {
  if (!dateValue || !Array.isArray(templates) || !templates.length) {
    return [];
  }

  const reference = new Date(`${dateValue}T00:00:00`);
  if (Number.isNaN(reference.getTime())) {
    return [];
  }

  const dayValue = getWeekdayValueFromIndex(reference.getDay());
  const baseDate = startOfDay(reference);
  const seen = new Set();
  const slots = [];

  templates.forEach((entry) => {
    if (entry.dayValue && entry.dayValue !== dayValue) {
      return;
    }

    const entrySlots = buildSlotsForScheduleEntry(entry, baseDate);
    entrySlots.forEach((slot) => {
      if (seen.has(slot.value)) {
        return;
      }

      seen.add(slot.value);

      const weekdayLabel = entry.dayValue ? WEEKDAY_LABEL_BY_VALUE[entry.dayValue] || '' : '';
      const hasCustomLabel =
        entry.label && weekdayLabel && entry.label.toLowerCase() !== weekdayLabel.toLowerCase();

      slots.push({
        value: slot.value,
        label: slot.label,
        displayLabel: hasCustomLabel ? `${entry.label} · ${slot.label}` : slot.label,
      });
    });
  });

  return slots.sort((a, b) => a.value.localeCompare(b.value));
}

function buildMatchScheduleOptionsFromAvailability({
  dateValue,
  availability,
  availabilityDate,
} = {}) {
  const normalizedDate = typeof dateValue === 'string' ? dateValue : '';
  if (!normalizedDate || !Array.isArray(availability) || !availability.length) {
    return [];
  }

  const availabilityDateValue = formatDateInput(availabilityDate);
  if (availabilityDateValue && availabilityDateValue !== normalizedDate) {
    return [];
  }

  const seen = new Set();
  const options = [];

  availability.forEach((entry) => {
    const slots = Array.isArray(entry?.availableSlots) ? entry.availableSlots : [];
    slots.forEach((slot) => {
      const slotStart = parseDateSafe(slot?.startsAt);
      if (!slotStart) {
        return;
      }

      const slotDateValue = formatDateInput(slotStart);
      if (slotDateValue !== normalizedDate) {
        return;
      }

      const timeValue = formatTimeInputValue(slotStart);
      if (!timeValue || seen.has(timeValue)) {
        return;
      }

      seen.add(timeValue);

      const slotEnd = parseDateSafe(slot?.endsAt) || addMinutes(slotStart, COURT_RESERVATION_DEFAULT_DURATION);
      const label = formatTimeRangeLabel(slotStart, slotEnd);

      options.push({
        value: timeValue,
        label,
        displayLabel: label,
      });
    });
  });

  return options.sort((a, b) => a.value.localeCompare(b.value));
}

function collectMatchScheduleSlotOptions({
  dateValue,
  templates = getClubMatchScheduleTemplates(),
  availability,
  availabilityDate,
} = {}) {
  const normalizedDate = typeof dateValue === 'string' ? dateValue : '';
  if (!normalizedDate) {
    return [];
  }

  const combined = [];
  const seen = new Set();

  const templateOptions = Array.isArray(templates)
    ? getMatchScheduleSlotOptionsForDate(normalizedDate, templates)
    : [];

  templateOptions.forEach((option) => {
    if (!option || !option.value || seen.has(option.value)) {
      return;
    }
    seen.add(option.value);
    combined.push(option);
  });

  const availabilityOptions = buildMatchScheduleOptionsFromAvailability({
    dateValue: normalizedDate,
    availability,
    availabilityDate,
  });

  availabilityOptions.forEach((option) => {
    if (!option || !option.value || seen.has(option.value)) {
      return;
    }
    seen.add(option.value);
    combined.push(option);
  });

  return combined.sort((a, b) => a.value.localeCompare(b.value));
}

function formatScheduleSlotFallbackLabel(dateValue, timeValue) {
  if (!dateValue || !timeValue) {
    return `Horario seleccionado (${timeValue || 'manual'})`;
  }

  const combined = combineDateAndTime(dateValue, timeValue);
  if (!combined) {
    return `Horario seleccionado (${timeValue})`;
  }

  const endsAt = addMinutes(combined, COURT_RESERVATION_DEFAULT_DURATION);
  return `Horario seleccionado · ${formatTimeRangeLabel(combined, endsAt)}`;
}

function isTimeRangeOverlapping(startA, endA, startB, endB) {
  if (!startA || !endA || !startB || !endB) {
    return false;
  }

  return startA < endB && startB < endA;
}

function parseDateSafe(value) {
  if (!value) {
    return null;
  }

  const date = new Date(value);
  return Number.isNaN(date.getTime()) ? null : date;
}

function isCourtAvailableForSlot(slotStart, slotEnd, { reservations = [], blocks = [] } = {}) {
  const hasReservationConflict = reservations.some((reservation) => {
    if (!reservation || reservation.status === 'cancelada') {
      return false;
    }

    const reservationStart = parseDateSafe(reservation.startsAt);
    const reservationEnd = parseDateSafe(reservation.endsAt) ||
      (reservationStart ? addMinutes(reservationStart, COURT_RESERVATION_DEFAULT_DURATION) : null);

    return isTimeRangeOverlapping(slotStart, slotEnd, reservationStart, reservationEnd);
  });

  if (hasReservationConflict) {
    return false;
  }

  const hasBlockConflict = blocks.some((block) => {
    const blockStart = parseDateSafe(block?.startsAt);
    const blockEnd = parseDateSafe(block?.endsAt);
    return isTimeRangeOverlapping(slotStart, slotEnd, blockStart, blockEnd);
  });

  return !hasBlockConflict;
}

function filterSlotsByAvailability(options, {
  dateValue,
  availability,
  availabilityDate,
  availabilityCourt,
} = {}) {
  if (!Array.isArray(options) || !options.length) {
    return options;
  }

  if (!dateValue || !Array.isArray(availability) || !availability.length) {
    return options;
  }

  const availabilityDateValue = formatDateInput(availabilityDate);
  if (!availabilityDateValue || availabilityDateValue !== dateValue) {
    return options;
  }

  const normalizedCourt = typeof availabilityCourt === 'string' ? availabilityCourt.trim() : '';
  const normalizedCourtLower = normalizedCourt.toLowerCase();
  const availabilityList = normalizedCourt
    ? availability.filter((entry) => {
        if (!entry || typeof entry.court !== 'string') {
          return false;
        }
        return entry.court.trim().toLowerCase() === normalizedCourtLower;
      })
    : availability;

  if (!availabilityList.length) {
    return [];
  }

  const availableSlotTimes = new Set();
  availabilityList.forEach((entry) => {
    const slots = Array.isArray(entry?.availableSlots) ? entry.availableSlots : [];
    slots.forEach((slot) => {
      const slotStart = parseDateSafe(slot?.startsAt);
      if (!slotStart) {
        return;
      }
      const slotDateValue = formatDateInput(slotStart);
      if (slotDateValue !== dateValue) {
        return;
      }
      const timeValue = formatTimeInputValue(slotStart);
      if (timeValue) {
        availableSlotTimes.add(timeValue);
      }
    });
  });

  if (availableSlotTimes.size) {
    return options.filter((slot) => availableSlotTimes.has(slot.value));
  }

  return options.filter((slot) => {
    const slotStart = combineDateAndTime(dateValue, slot.value);
    if (!(slotStart instanceof Date) || Number.isNaN(slotStart.getTime())) {
      return true;
    }

    const slotEnd = addMinutes(slotStart, COURT_RESERVATION_DEFAULT_DURATION);
    return availabilityList.some((entry) =>
      isCourtAvailableForSlot(slotStart, slotEnd, {
        reservations: Array.isArray(entry?.reservations) ? entry.reservations : [],
        blocks: Array.isArray(entry?.blocks) ? entry.blocks : [],
      })
    );
  });
}

function renderMatchScheduleSlots({
  select,
  dateValue,
  templates = getClubMatchScheduleTemplates(),
  selectedTime = '',
  availability,
  availabilityDate,
  availabilityCourt,
} = {}) {
  if (!select) {
    return { matched: false, hasOptions: false };
  }

  select.innerHTML = '';
  select.disabled = true;

  if (!dateValue) {
    const option = new Option('Selecciona un día para ver horarios disponibles', '', true, true);
    select.appendChild(option);
    return { matched: false, hasOptions: false };
  }

  const options = collectMatchScheduleSlotOptions({
    dateValue,
    templates,
    availability,
    availabilityDate,
  });

  if (!options.length) {
    const hasTemplates = Array.isArray(templates) && templates.length > 0;
    const hasCourts = getClubCourtNames().length > 0;
    const message = hasTemplates || hasCourts
      ? 'No hay reservas de pista disponibles para este día'
      : 'Configura las pistas del club para habilitar la reserva automática.';
    const option = new Option(message, '', true, true);
    option.disabled = true;
    select.appendChild(option);
    return { matched: false, hasOptions: false };
  }

  const filteredOptions = filterSlotsByAvailability(options, {
    dateValue,
    availability,
    availabilityDate,
    availabilityCourt,
  });

  const placeholder = new Option('Sin horario (partido pendiente)', '', !selectedTime, !selectedTime);
  select.appendChild(placeholder);

  let matched = false;
  filteredOptions.forEach((slot) => {
    const option = new Option(slot.displayLabel || slot.label, slot.value, false, slot.value === selectedTime);
    if (slot.value === selectedTime) {
      matched = true;
    }
    select.appendChild(option);
  });

  if (selectedTime && !matched) {
    const fallbackLabel = formatScheduleSlotFallbackLabel(dateValue, selectedTime);
    const fallbackOption = new Option(fallbackLabel, selectedTime, true, true);
    select.appendChild(fallbackOption);
    matched = true;
  }

  if (!filteredOptions.length) {
    const unavailableOption = new Option('No hay horarios libres para este día', '', false, false);
    unavailableOption.disabled = true;
    select.appendChild(unavailableOption);
  }

  select.disabled = false;

  if (!matched) {
    select.value = '';
  }

  return { matched: Boolean(selectedTime && matched), hasOptions: filteredOptions.length > 0 };
}

function getScheduleAvailabilityState(scope = 'player') {
  if (scope === 'admin') {
    return {
      availability: state.courtAdminSchedule || [],
      date: state.courtAdminDate,
      court: state.courtAdminCourt || '',
      ignoreManualLimit: Boolean(state.courtAdminIgnoreManualLimit),
    };
  }

  return {
    availability: state.courtAvailability || [],
    date: state.courtAvailabilityDate,
    court: state.courtAvailabilityCourt || '',
    ignoreManualLimit: Boolean(state.courtAvailabilityIgnoreManualLimit),
  };
}

async function resolveScheduleAvailability({
  scope = 'player',
  dateValue,
  courtValue,
  ignoreManualLimit,
} = {}) {
  const dateString = typeof dateValue === 'string' ? dateValue : '';
  const targetDate = dateString ? new Date(`${dateString}T00:00:00`) : null;
  if (targetDate && Number.isNaN(targetDate.getTime())) {
    return getScheduleAvailabilityState(scope);
  }

  const currentState = getScheduleAvailabilityState(scope);
  const currentDateValue = formatDateInput(currentState.date);
  const targetDateValue = formatDateInput(targetDate);
  const normalizedCourt = typeof courtValue === 'string' ? courtValue.trim() : '';
  const currentCourtValue = typeof currentState.court === 'string' ? currentState.court : '';
  const shouldIgnoreManualLimit =
    typeof ignoreManualLimit === 'boolean'
      ? ignoreManualLimit
      : scope !== 'player' && hasCourtManagementAccess();
  const currentIgnoreManualLimit = Boolean(currentState.ignoreManualLimit);

  if (!targetDateValue) {
    return currentState;
  }

  if (
    currentDateValue === targetDateValue &&
    currentCourtValue === normalizedCourt &&
    currentIgnoreManualLimit === shouldIgnoreManualLimit
  ) {
    return currentState;
  }

  if (scope === 'admin') {
    state.courtAdminDate = targetDate;
    state.courtAdminCourt = normalizedCourt;
    state.courtAdminIgnoreManualLimit = shouldIgnoreManualLimit;
  } else {
    state.courtAvailabilityDate = targetDate;
    state.courtAvailabilityCourt = normalizedCourt;
    state.courtAvailabilityIgnoreManualLimit = shouldIgnoreManualLimit;
  }

  await refreshCourtAvailability(scope, {
    court: normalizedCourt,
    ignoreManualLimit: shouldIgnoreManualLimit,
  });

  return getScheduleAvailabilityState(scope);
}

function setScheduleSelectLoading(select) {
  if (!select) {
    return;
  }

  select.innerHTML = '';
  const option = new Option('Cargando disponibilidad...', '', true, true);
  option.disabled = true;
  select.appendChild(option);
  select.disabled = true;
}

async function updateMatchScheduleSlots({
  select,
  dateValue,
  templates = getClubMatchScheduleTemplates(),
  selectedTime = '',
  scope = 'player',
  courtValue = '',
  ignoreManualLimit,
} = {}) {
  if (!select) {
    return { matched: false, hasOptions: false };
  }

  if (!dateValue) {
    return renderMatchScheduleSlots({ select, dateValue, templates, selectedTime });
  }

  setScheduleSelectLoading(select);

  const shouldIgnoreManualLimit =
    typeof ignoreManualLimit === 'boolean'
      ? ignoreManualLimit
      : scope !== 'player' && hasCourtManagementAccess();

  const { availability, date, court } = await resolveScheduleAvailability({
    scope,
    dateValue,
    courtValue,
    ignoreManualLimit: shouldIgnoreManualLimit,
  });
  return renderMatchScheduleSlots({
    select,
    dateValue,
    templates,
    selectedTime,
    availability,
    availabilityDate: date,
    availabilityCourt: court,
  });
}

function attachSchedulePicker({
  scheduleTemplates = getClubMatchScheduleTemplates(),
  scheduleDateField = null,
  scheduleSlotField = null,
  scheduledField = null,
  courtField = null,
  existingValue = '',
  scope = 'player',
  ignoreManualLimit,
} = {}) {
  const templates = Array.isArray(scheduleTemplates) ? scheduleTemplates : [];
  if (!templates.length || !scheduleDateField || !scheduleSlotField || !scheduledField) {
    if (scheduledField) {
      scheduledField.value = existingValue || '';
    }
    return {
      syncScheduledValue: () => {},
      updateScheduleSlotOptions: () => Promise.resolve({ matched: false, hasOptions: false }),
    };
  }

  const syncScheduledValue = () => {
    const dateValue = scheduleDateField.value;
    const timeValue = scheduleSlotField.value;
    scheduledField.value = dateValue && timeValue ? `${dateValue}T${timeValue}` : '';
    return scheduledField.value;
  };

  const shouldIgnoreManualLimit =
    typeof ignoreManualLimit === 'boolean'
      ? ignoreManualLimit
      : scope !== 'player' && hasCourtManagementAccess();

  const getSelectedCourtValue = () => {
    if (!courtField) {
      return '';
    }
    const value = courtField.value || '';
    return typeof value === 'string' ? value.trim() : '';
  };

  const updateScheduleSlotOptions = async (selectedTime = '') => {
    return updateMatchScheduleSlots({
      select: scheduleSlotField,
      dateValue: scheduleDateField.value,
      templates,
      selectedTime,
      scope,
      courtValue: getSelectedCourtValue(),
      ignoreManualLimit: shouldIgnoreManualLimit,
    });
  };

  const handleScheduleDateChange = () => {
    updateScheduleSlotOptions('')
      .catch((error) => {
        console.warn('No fue posible cargar la disponibilidad de pistas', error);
      })
      .finally(() => {
        syncScheduledValue();
      });
  };

  scheduleDateField.addEventListener('change', handleScheduleDateChange);
  scheduleDateField.addEventListener('input', handleScheduleDateChange);

  scheduleSlotField.addEventListener('change', () => {
    syncScheduledValue();
  });

  if (courtField) {
    const handleCourtChange = () => {
      updateScheduleSlotOptions(scheduleSlotField?.value || '')
        .catch((error) => {
          console.warn('No fue posible cargar la disponibilidad de pistas', error);
        })
        .finally(() => {
          syncScheduledValue();
        });
    };

    courtField.addEventListener('change', handleCourtChange);
    courtField.addEventListener('input', handleCourtChange);
  }

  const normalizedExisting = typeof existingValue === 'string' ? existingValue : '';
  if (normalizedExisting) {
    const [existingDate, existingTime] = normalizedExisting.split('T');
    if (existingDate) {
      scheduleDateField.value = existingDate;
    }
    updateScheduleSlotOptions(existingTime || '')
      .then((result) => {
        if (existingTime && !result?.matched && scheduleSlotField.value !== existingTime) {
          scheduleSlotField.value = existingTime;
          if (scheduleSlotField.value !== existingTime) {
            scheduleSlotField.value = existingTime;
          }
        }
      })
      .catch((error) => {
        console.warn('No fue posible cargar la disponibilidad de pistas', error);
      })
      .finally(() => {
        syncScheduledValue();
      });
  } else {
    updateScheduleSlotOptions('')
      .catch((error) => {
        console.warn('No fue posible cargar la disponibilidad de pistas', error);
      })
      .finally(() => {
        syncScheduledValue();
      });
  }

  syncScheduledValue();

  return { syncScheduledValue, updateScheduleSlotOptions };
}

function createMatchScheduleSlotPicker({
  container = null,
  dateField = null,
  scheduledField = null,
  templates = getClubMatchScheduleTemplates(),
  scope = 'player',
  courtField = null,
  existingValue = '',
  existingCourt = '',
  onChange = () => {},
  ignoreMatchId = '',
  ignoreManualLimit,
} = {}) {
  const resolvedTemplates = Array.isArray(templates) ? templates : [];
  if (!container || !scheduledField) {
    return {
      clear: () => {},
      refresh: () => {},
      destroy: () => {},
      getSelection: () => ({ scheduledAt: '', date: '', time: '', court: '' }),
      setSelection: () => {},
    };
  }

  let activeDateField = dateField;
  let createdDateField = false;

  if (!activeDateField) {
    activeDateField = document.createElement('input');
    activeDateField.type = 'date';
    activeDateField.name = 'scheduledDate';
    activeDateField.className = 'sr-only';
    activeDateField.setAttribute('aria-hidden', 'true');
    const targetForm = scheduledField.form || container.closest('form');
    if (targetForm) {
      targetForm.appendChild(activeDateField);
    } else {
      container.appendChild(activeDateField);
    }
    createdDateField = true;
  }

  container.classList.add('match-schedule-picker');
  container.innerHTML = '';

  const header = document.createElement('div');
  header.className = 'match-schedule-picker__header';

  const nav = document.createElement('div');
  nav.className = 'calendar-nav';

  const prevButton = document.createElement('button');
  prevButton.type = 'button';
  prevButton.className = 'ghost';
  prevButton.setAttribute('aria-label', 'Ver día anterior');
  prevButton.textContent = '◀';
  nav.appendChild(prevButton);

  const dateLabel = document.createElement('span');
  dateLabel.className = 'calendar-label match-schedule-picker__label';
  nav.appendChild(dateLabel);

  const nextButton = document.createElement('button');
  nextButton.type = 'button';
  nextButton.className = 'ghost';
  nextButton.setAttribute('aria-label', 'Ver día siguiente');
  nextButton.textContent = '▶';
  nav.appendChild(nextButton);

  header.appendChild(nav);

  if (activeDateField) {
    if (activeDateField.parentElement) {
      activeDateField.parentElement.removeChild(activeDateField);
    }
    activeDateField.classList.remove('sr-only');
    activeDateField.removeAttribute('aria-hidden');
    activeDateField.classList.add('match-schedule-picker__date-input');
    if (!activeDateField.getAttribute('aria-label')) {
      activeDateField.setAttribute('aria-label', 'Seleccionar fecha');
    }
    const datePicker = document.createElement('label');
    datePicker.className = 'inline-field calendar-date-picker match-schedule-picker__date-picker';
    const srLabel = document.createElement('span');
    srLabel.className = 'sr-only';
    srLabel.textContent = 'Seleccionar fecha';
    datePicker.appendChild(srLabel);
    datePicker.appendChild(activeDateField);
    header.appendChild(datePicker);
  }

  container.appendChild(header);

  const statusMessage = document.createElement('p');
  statusMessage.className = 'match-schedule-picker__status';
  container.appendChild(statusMessage);

  const gridWrapper = document.createElement('div');
  gridWrapper.className = 'match-schedule-picker__grid calendar-container';
  container.appendChild(gridWrapper);

  const state = {
    dateValue: '',
    timeValue: '',
    courtValue: '',
    availability: [],
    availabilityDate: null,
    ignoredMatchId: normalizeId(ignoreMatchId) || '',
    ignoreManualLimit:
      typeof ignoreManualLimit === 'boolean'
        ? ignoreManualLimit
        : scope !== 'player' && hasCourtManagementAccess(),
  };

  let loadToken = 0;

  const setStatus = (message = '', type = '') => {
    statusMessage.textContent = message;
    statusMessage.classList.remove('match-schedule-picker__status--error');
    if (type === 'error') {
      statusMessage.classList.add('match-schedule-picker__status--error');
    }
  };

  const updateDateLabel = () => {
    if (!dateLabel) {
      return;
    }
    if (!state.dateValue) {
      dateLabel.textContent = 'Selecciona un día';
      return;
    }
    const reference = new Date(`${state.dateValue}T00:00:00`);
    if (!(reference instanceof Date) || Number.isNaN(reference.getTime())) {
      dateLabel.textContent = 'Selecciona un día';
      return;
    }
    dateLabel.textContent = formatDayLabel(reference);
  };

  const emitChange = () => {
    const scheduledAt = state.dateValue && state.timeValue ? `${state.dateValue}T${state.timeValue}` : '';
    if (scheduledField) {
      scheduledField.value = scheduledAt;
    }
    if (courtField) {
      courtField.value = scheduledAt ? state.courtValue || '' : '';
    }
    try {
      onChange({ scheduledAt, court: state.courtValue, date: state.dateValue, time: state.timeValue });
    } catch (error) {
      console.warn('No se pudo ejecutar el manejador de cambios del selector de horario', error);
    }
    return scheduledAt;
  };

  const highlightSelectedButtons = () => {
    const buttons = gridWrapper.querySelectorAll('button[data-slot-value]');
    buttons.forEach((button) => {
      const value = button.dataset.slotValue || '';
      const court = button.dataset.slotCourt || '';
      const isSelected = Boolean(
        value &&
          value === state.timeValue &&
          (state.courtValue ? normalizeCourtKey(state.courtValue) === normalizeCourtKey(court) : true)
      );
      button.classList.toggle('is-selected', isSelected);
      button.setAttribute('aria-pressed', isSelected ? 'true' : 'false');
    });
  };

  const setSelection = ({ timeValue = '', courtValue = '' } = {}) => {
    state.timeValue = timeValue || '';
    state.courtValue = state.timeValue ? courtValue || '' : '';
    highlightSelectedButtons();
    return emitChange();
  };

  const ensureSelectionVisible = () => {
    if (!state.timeValue) {
      highlightSelectedButtons();
      return;
    }

    const normalizedCourt = normalizeCourtKey(state.courtValue);
    const selector = normalizedCourt
      ? `button[data-slot-value="${state.timeValue}"][data-slot-court]`
      : `button[data-slot-value="${state.timeValue}"]`;
    const matchingButtons = Array.from(gridWrapper.querySelectorAll(selector));
    const matchedButton = matchingButtons.find((button) => {
      if (!normalizedCourt) {
        return true;
      }
      return normalizeCourtKey(button.dataset.slotCourt || '') === normalizedCourt;
    });

    if (matchedButton) {
      state.courtValue = matchedButton.dataset.slotCourt || '';
      highlightSelectedButtons();
      emitChange();
      return;
    }

    const fallback = gridWrapper.querySelector(`button[data-slot-value="${state.timeValue}"]`);
    if (fallback) {
      state.courtValue = fallback.dataset.slotCourt || '';
      highlightSelectedButtons();
      emitChange();
      return;
    }

    setSelection({ timeValue: '', courtValue: '' });
  };

  const getAvailabilityEntryForCourt = (courtName) => {
    if (!courtName) {
      return null;
    }
    const normalizedCourt = normalizeCourtKey(courtName);
    if (!normalizedCourt) {
      return null;
    }
    return (
      state.availability.find((entry) => normalizeCourtKey(entry?.court) === normalizedCourt) || null
    );
  };

  const reservationMatchesIgnoredMatch = (reservation) => {
    if (!state.ignoredMatchId) {
      return false;
    }
    const reservationMatchId = normalizeId(reservation?.match);
    return reservationMatchId && reservationMatchId === state.ignoredMatchId;
  };

  const filterReservations = (reservations) => {
    if (!state.ignoredMatchId) {
      return reservations;
    }
    return reservations.filter((reservation) => !reservationMatchesIgnoredMatch(reservation));
  };

  const doesReservationCoverSlot = (reservation, timeValue) => {
    if (!state.dateValue || !timeValue) {
      return false;
    }

    const slotStart = combineDateAndTime(state.dateValue, timeValue);
    if (!(slotStart instanceof Date) || Number.isNaN(slotStart.getTime())) {
      return false;
    }

    const slotEnd = addMinutes(slotStart, COURT_RESERVATION_DEFAULT_DURATION);
    const reservationStart = parseDateSafe(reservation?.startsAt);
    if (!reservationStart) {
      return false;
    }
    if (formatDateInput(reservationStart) !== state.dateValue) {
      return false;
    }
    if (timeValue && formatTimeInputValue(reservationStart) !== timeValue) {
      return false;
    }
    const reservationEnd =
      parseDateSafe(reservation?.endsAt) || addMinutes(reservationStart, COURT_RESERVATION_DEFAULT_DURATION);
    return isTimeRangeOverlapping(slotStart, slotEnd, reservationStart, reservationEnd);
  };

  const eventMatchesIgnoredMatch = (event) => {
    if (!state.ignoredMatchId || !event) {
      return false;
    }
    const eventMatchId = normalizeId(event.matchId || event.match);
    return eventMatchId && eventMatchId === state.ignoredMatchId;
  };

  const isSlotAvailableForCourt = (entry, slotStart, slotEnd, timeValue) => {
    if (!entry) {
      return false;
    }

    const availableSlots = Array.isArray(entry.availableSlots) ? entry.availableSlots : [];
    const reservations = Array.isArray(entry.reservations) ? entry.reservations : [];
    if (availableSlots.length) {
      const matchesAvailableSlot = availableSlots.some((slot) => {
        const startsAt = parseDateSafe(slot?.startsAt);
        if (!startsAt) {
          return false;
        }
        return (
          formatDateInput(startsAt) === state.dateValue && formatTimeInputValue(startsAt) === timeValue
        );
      });

      if (matchesAvailableSlot) {
        return true;
      }

      if (state.ignoredMatchId) {
        return reservations.some(
          (reservation) => reservationMatchesIgnoredMatch(reservation) && doesReservationCoverSlot(reservation, timeValue)
        );
      }

      return false;
    }

    return isCourtAvailableForSlot(slotStart, slotEnd, {
      reservations: filterReservations(reservations),
      blocks: Array.isArray(entry.blocks) ? entry.blocks : [],
    });
  };

  const buildNormalizedEvents = (events = []) =>
    events
      .map((event) => {
        const bounds = getCourtCalendarEventBounds(event);
        if (!bounds.start || !bounds.end) {
          return null;
        }
        return { event, start: bounds.start, end: bounds.end };
      })
      .filter(Boolean);

  const renderGrid = () => {
    gridWrapper.innerHTML = '';
    updateDateLabel();

    if (!state.dateValue) {
      setStatus('Selecciona un día para ver la disponibilidad.');
      return;
    }

    const slotOptions = collectMatchScheduleSlotOptions({
      dateValue: state.dateValue,
      templates: resolvedTemplates,
      availability: state.availability,
      availabilityDate: state.availabilityDate,
    });
    if (!slotOptions.length) {
      setStatus('No hay reservas de pista disponibles para este día.');
      return;
    }

    const events = buildPlayerCourtCalendarEvents(state.availability);
    const normalizedEvents = buildNormalizedEvents(events);
    const courts = getCourtCalendarCourts(events);

    if (!courts.length) {
      setStatus('Configura las pistas del club para habilitar la reserva automática.');
      return;
    }

    setStatus('');

    const headerRow = document.createElement('div');
    headerRow.className = 'calendar-day-schedule__row calendar-day-schedule__row--header';
    headerRow.style.setProperty('--calendar-schedule-court-count', courts.length);

    const timeHeader = document.createElement('div');
    timeHeader.className = 'calendar-day-schedule__cell calendar-day-schedule__cell--time';
    timeHeader.textContent = 'Horario';
    headerRow.appendChild(timeHeader);

    courts.forEach((court, index) => {
      const cell = document.createElement('div');
      cell.className =
        'calendar-day-schedule__cell calendar-day-schedule__cell--court calendar-day-schedule__cell--header';
      cell.textContent = court.label;
      if (index === courts.length - 1) {
        cell.classList.add('calendar-day-schedule__cell--last-column');
      }
      headerRow.appendChild(cell);
    });

    const grid = document.createElement('div');
    grid.className = 'calendar-day-schedule__grid';
    grid.style.setProperty('--calendar-schedule-court-count', courts.length);
    grid.appendChild(headerRow);

    slotOptions.forEach((slotOption, slotIndex) => {
      const slotStart = combineDateAndTime(state.dateValue, slotOption.value);
      if (!(slotStart instanceof Date) || Number.isNaN(slotStart.getTime())) {
        return;
      }
      const slotEnd = addMinutes(slotStart, COURT_RESERVATION_DEFAULT_DURATION);

      const row = document.createElement('div');
      row.className = 'calendar-day-schedule__row calendar-day-schedule__row--body';
      row.style.setProperty('--calendar-schedule-court-count', courts.length);

      const timeCell = document.createElement('div');
      timeCell.className = 'calendar-day-schedule__cell calendar-day-schedule__cell--time';
      timeCell.textContent = slotOption.displayLabel || slotOption.label;
      if (slotIndex === slotOptions.length - 1) {
        timeCell.classList.add('calendar-day-schedule__cell--last-row');
      }
      row.appendChild(timeCell);

      courts.forEach((court, courtIndex) => {
        const cell = document.createElement('div');
        cell.className = 'calendar-day-schedule__cell calendar-day-schedule__cell--court';
        if (slotIndex === slotOptions.length - 1) {
          cell.classList.add('calendar-day-schedule__cell--last-row');
        }
        if (courtIndex === courts.length - 1) {
          cell.classList.add('calendar-day-schedule__cell--last-column');
        }

        const slotEvents = normalizedEvents
          .filter(
            (entry) =>
              isCourtCalendarEventForCourt(entry.event, court.name) &&
              doesCourtCalendarEventOverlapSlot(entry, slotStart, slotEnd)
          )
          .filter((entry) => !eventMatchesIgnoredMatch(entry.event));

        if (slotEvents.length) {
          cell.classList.add('calendar-day-schedule__cell--busy');
          slotEvents
            .sort((a, b) => a.start - b.start)
            .forEach((entry) => {
              const eventElement = createCourtCalendarEvent(entry.event);
              eventElement.classList.add('calendar-schedule-event');
              cell.appendChild(eventElement);
            });
        } else {
          const availabilityEntry = getAvailabilityEntryForCourt(court.name);
          const isAvailable = isSlotAvailableForCourt(
            availabilityEntry,
            slotStart,
            slotEnd,
            slotOption.value
          );

          if (isAvailable) {
            const button = document.createElement('button');
            button.type = 'button';
            button.className = 'calendar-day-schedule__slot-button';
            button.dataset.slotValue = slotOption.value;
            button.dataset.slotCourt = court.name;
            button.textContent = 'Seleccionar';
            button.addEventListener('click', () => {
              setSelection({ timeValue: slotOption.value, courtValue: court.name });
              highlightSelectedButtons();
            });
            cell.appendChild(button);
          } else {
            const unavailable = document.createElement('span');
            unavailable.className = 'calendar-day-schedule__empty';
            unavailable.textContent = 'No disponible';
            cell.appendChild(unavailable);
          }
        }

        row.appendChild(cell);
      });

      grid.appendChild(row);
    });

    gridWrapper.appendChild(grid);
    ensureSelectionVisible();
  };

  const loadAvailabilityForDate = async (dateValue) => {
    const normalizedDate = typeof dateValue === 'string' ? dateValue : '';
    state.dateValue = normalizedDate;
    updateDateLabel();

    if (!normalizedDate) {
      state.availability = [];
      state.availabilityDate = null;
      renderGrid();
      emitChange();
      return;
    }

    const token = ++loadToken;
    setStatus('Cargando disponibilidad...');
    try {
      const { availability, date } = await resolveScheduleAvailability({
        scope,
        dateValue: normalizedDate,
        ignoreManualLimit: state.ignoreManualLimit,
      });
      if (token !== loadToken) {
        return;
      }
      const resolvedDateValue = formatDateInput(date) || normalizedDate;
      state.dateValue = resolvedDateValue;
      if (activeDateField && activeDateField.value !== resolvedDateValue) {
        activeDateField.value = resolvedDateValue;
      }
      updateDateLabel();
      state.availability = Array.isArray(availability) ? availability : [];
      state.availabilityDate = date || null;
      setStatus('');
      renderGrid();
    } catch (error) {
      if (token !== loadToken) {
        return;
      }
      state.availability = [];
      state.availabilityDate = null;
      updateDateLabel();
      renderGrid();
      setStatus(error.message || 'No fue posible cargar la disponibilidad.', 'error');
    }
  };

  const handleDateChange = () => {
    const value = activeDateField?.value || '';
    loadAvailabilityForDate(value).catch((error) => {
      console.warn('No se pudo actualizar la disponibilidad de pistas', error);
    });
  };

  const changeDateBy = (deltaDays) => {
    const baseValue =
      state.dateValue ||
      (activeDateField?.value ? activeDateField.value : '') ||
      (state.availabilityDate ? formatDateInput(state.availabilityDate) : '');
    let reference = baseValue ? new Date(`${baseValue}T00:00:00`) : startOfDay(new Date());
    if (!(reference instanceof Date) || Number.isNaN(reference.getTime())) {
      reference = startOfDay(new Date());
    }
    const nextDate = addDays(reference, deltaDays);
    const nextValue = formatDateInput(nextDate);
    if (!nextValue) {
      return;
    }
    if (activeDateField) {
      if (activeDateField.value !== nextValue) {
        activeDateField.value = nextValue;
      }
      handleDateChange();
    } else {
      loadAvailabilityForDate(nextValue).catch((error) => {
        console.warn('No se pudo actualizar la disponibilidad de pistas', error);
      });
    }
  };

  const handlePrevClick = () => changeDateBy(-1);
  const handleNextClick = () => changeDateBy(1);

  prevButton.addEventListener('click', handlePrevClick);
  nextButton.addEventListener('click', handleNextClick);
  activeDateField?.addEventListener('change', handleDateChange);
  activeDateField?.addEventListener('input', handleDateChange);

  const normalizedExisting = typeof existingValue === 'string' ? existingValue.trim() : '';
  if (normalizedExisting) {
    const [existingDate, existingTime] = normalizedExisting.split('T');
    state.dateValue = existingDate || '';
    state.timeValue = existingTime || '';
    state.courtValue = existingCourt || '';
    if (activeDateField && existingDate) {
      activeDateField.value = existingDate;
    }
    updateDateLabel();
    emitChange();
    loadAvailabilityForDate(existingDate || '').catch((error) => {
      console.warn('No se pudo inicializar la disponibilidad de pistas', error);
    });
  } else {
    state.dateValue = activeDateField?.value || '';
    if (!state.dateValue) {
      const todayValue = formatDateInput(startOfDay(new Date()));
      if (todayValue) {
        state.dateValue = todayValue;
        if (activeDateField) {
          activeDateField.value = todayValue;
        }
      }
    }
    updateDateLabel();
    emitChange();
    if (state.dateValue) {
      loadAvailabilityForDate(state.dateValue).catch((error) => {
        console.warn('No se pudo cargar la disponibilidad de pistas', error);
      });
    } else {
      renderGrid();
    }
  }

  return {
    clear() {
      setSelection({ timeValue: '', courtValue: '' });
      highlightSelectedButtons();
    },
    refresh() {
      loadAvailabilityForDate(state.dateValue || activeDateField?.value || '').catch((error) => {
        console.warn('No se pudo actualizar la disponibilidad de pistas', error);
      });
    },
    destroy() {
      activeDateField?.removeEventListener('change', handleDateChange);
      activeDateField?.removeEventListener('input', handleDateChange);
      prevButton.removeEventListener('click', handlePrevClick);
      nextButton.removeEventListener('click', handleNextClick);
      if (createdDateField && activeDateField?.parentElement) {
        activeDateField.parentElement.removeChild(activeDateField);
      }
    },
    getSelection() {
      return {
        scheduledAt: state.dateValue && state.timeValue ? `${state.dateValue}T${state.timeValue}` : '',
        date: state.dateValue,
        time: state.timeValue,
        court: state.courtValue,
      };
    },
    setSelection(selection = {}) {
      const scheduledAt = selection.scheduledAt || '';
      let nextDate = selection.date || '';
      let nextTime = selection.time || '';
      let nextCourt = selection.court || '';

      if (scheduledAt && (!nextDate || !nextTime)) {
        const [parsedDate, parsedTime] = scheduledAt.split('T');
        nextDate = nextDate || parsedDate || '';
        nextTime = nextTime || parsedTime || '';
      }

      if (nextDate) {
        state.dateValue = nextDate;
        if (activeDateField) {
          activeDateField.value = nextDate;
        }
        updateDateLabel();
        state.timeValue = nextTime || '';
        state.courtValue = nextCourt || '';
        emitChange();
        loadAvailabilityForDate(nextDate).catch((error) => {
          console.warn('No se pudo actualizar la disponibilidad de pistas', error);
        });
      } else {
        state.dateValue = '';
        state.timeValue = '';
        state.courtValue = '';
        updateDateLabel();
        emitChange();
        renderGrid();
      }
    },
  };
}

function populateCourtReservationCourts() {
  if (!courtReservationCourtSelect) {
    return;
  }

  const currentValue = courtReservationCourtSelect.value;
  const courtNames = getClubCourtNames();
  courtReservationCourtSelect.innerHTML = '';

  if (!courtNames.length) {
    const option = new Option('Añade pistas en la sección del club para habilitar las reservas', '');
    option.disabled = true;
    option.selected = true;
    courtReservationCourtSelect.appendChild(option);
    courtReservationCourtSelect.disabled = true;
    if (courtReservationSubmit) {
      courtReservationSubmit.disabled = true;
    }
    return;
  }

  courtReservationCourtSelect.disabled = false;
  if (courtReservationSubmit) {
    courtReservationSubmit.disabled = false;
  }

  let resolvedValue = currentValue && courtNames.includes(currentValue) ? currentValue : courtNames[0];
  courtNames.forEach((name) => {
    const option = new Option(name, name, false, name === resolvedValue);
    courtReservationCourtSelect.appendChild(option);
  });
  courtReservationCourtSelect.value = resolvedValue;
}

function populateCourtBlockCourts() {
  if (!courtBlockCourtsSelect) {
    return;
  }

  const previousSelection = new Set(
    Array.from(courtBlockCourtsSelect.selectedOptions || []).map((option) => option.value)
  );
  const courtNames = getClubCourtNames();
  courtBlockCourtsSelect.innerHTML = '';

  if (!courtNames.length) {
    const option = new Option(
      'Añade pistas en la sección del club para poder bloquearlas',
      '',
      true,
      true
    );
    option.disabled = true;
    courtBlockCourtsSelect.appendChild(option);
    courtBlockCourtsSelect.disabled = true;
    return;
  }

  courtBlockCourtsSelect.disabled = false;
  courtNames.forEach((name) => {
    const option = new Option(name, name, false, previousSelection.has(name));
    courtBlockCourtsSelect.appendChild(option);
  });
}

function populateCourtBlockEntities() {
  if (!courtBlockEntitySelect) {
    return;
  }

  const contextType = courtBlockContextSelect?.value || 'league';

  if (contextType === 'lesson') {
    courtBlockEntitySelect.innerHTML = '';
    const clubId = state.club?._id || state.club?.id || '';
    if (!clubId) {
      const option = new Option(
        'Configura el perfil del club para habilitar los bloqueos de clases.',
        '',
        true,
        true
      );
      option.disabled = true;
      courtBlockEntitySelect.appendChild(option);
      courtBlockEntitySelect.disabled = true;
      if (courtBlockSubmit) {
        courtBlockSubmit.disabled = true;
      }
      return;
    }

    const label = state.club?.name ? `Clases de tenis · ${state.club.name}` : 'Clases de tenis';
    const option = new Option(label, clubId, true, true);
    courtBlockEntitySelect.appendChild(option);
    courtBlockEntitySelect.disabled = false;
    courtBlockEntitySelect.value = clubId;
    if (courtBlockSubmit) {
      courtBlockSubmit.disabled = false;
    }
    return;
  }

  const entities =
    contextType === 'league'
      ? Array.isArray(state.leagues)
        ? state.leagues
        : []
      : Array.isArray(state.tournaments)
        ? state.tournaments
        : [];

  const previousValue = courtBlockEntitySelect.value;
  courtBlockEntitySelect.innerHTML = '';

  if (!entities.length) {
    const message =
      contextType === 'league'
        ? 'No hay ligas activas para asignar bloqueos.'
        : 'No hay torneos activos para asignar bloqueos.';
    const option = new Option(message, '', true, true);
    option.disabled = true;
    courtBlockEntitySelect.appendChild(option);
    courtBlockEntitySelect.disabled = true;
    if (courtBlockSubmit) {
      courtBlockSubmit.disabled = true;
    }
    return;
  }

  courtBlockEntitySelect.disabled = false;
  if (courtBlockSubmit) {
    courtBlockSubmit.disabled = false;
  }

  const options = entities.map((entity) => {
    const id = entity?._id || entity?.id;
    const labelParts = [];
    if (entity?.name) {
      labelParts.push(entity.name);
    }
    if (entity?.year) {
      labelParts.push(entity.year);
    }
    const label = labelParts.length ? labelParts.join(' · ') : 'Competición';
    return { id, label };
  });

  let resolvedValue = previousValue;
  if (!options.some((option) => option.id === resolvedValue)) {
    resolvedValue = options[0]?.id || '';
  }

  options.forEach((option) => {
    if (!option.id) {
      return;
    }
    const element = new Option(option.label, option.id, false, option.id === resolvedValue);
    courtBlockEntitySelect.appendChild(element);
  });

  courtBlockEntitySelect.value = resolvedValue;
}

function setCourtBlockDefaultRange(baseDate = new Date()) {
  if (!courtBlockStartInput || !courtBlockEndInput) {
    return;
  }

  const reference = new Date(baseDate);
  if (Number.isNaN(reference.getTime())) {
    return;
  }

  if (reference.getHours() === 0 && reference.getMinutes() === 0) {
    reference.setHours(8, 30, 0, 0);
  }

  const start = roundDateUpToInterval(reference, CALENDAR_TIME_SLOT_MINUTES);
  const end = addMinutes(start, COURT_RESERVATION_DEFAULT_DURATION);
  courtBlockStartInput.value = formatDateTimeLocal(start);
  courtBlockEndInput.value = formatDateTimeLocal(end);
}

function ensureCourtBlockRangeDefaults(baseDate = new Date()) {
  if (!courtBlockStartInput || !courtBlockEndInput) {
    return;
  }

  if (!courtBlockStartInput.value || !courtBlockEndInput.value) {
    setCourtBlockDefaultRange(baseDate);
  }
}

function resetCourtReservationForm() {
  if (!courtReservationForm) {
    return;
  }

  const baseDate = roundDateUpToInterval(new Date(), CALENDAR_TIME_SLOT_MINUTES);
  const dateValue = formatDateInput(baseDate);
  if (courtReservationDateInput) {
    courtReservationDateInput.value = dateValue;
  }
  populateCourtReservationTimeOptions(baseDate, formatTimeInputValue(baseDate));
  if (courtReservationDurationSelect) {
    courtReservationDurationSelect.value = String(COURT_RESERVATION_DEFAULT_DURATION);
  }
  if (courtReservationNotesInput) {
    courtReservationNotesInput.value = '';
  }
  populateCourtReservationCourts();
  setStatusMessage(courtReservationStatus, '', '');
}

function resolvePlayerDisplayName(player, visited = new Set()) {
  if (!player || visited.has(player)) {
    return '';
  }

  if (typeof player === 'string') {
    const trimmed = player.trim();
    return trimmed;
  }

  if (typeof player !== 'object') {
    return '';
  }

  visited.add(player);

  if (Array.isArray(player.players) && player.players.length) {
    const names = player.players
      .map((member) => resolvePlayerDisplayName(member, visited))
      .filter((name) => Boolean(name && name.trim()));
    if (names.length) {
      return names.join(' / ');
    }
  }

  const directFields = ['fullName', 'name', 'label', 'displayName'];
  for (const field of directFields) {
    const value = player[field];
    if (typeof value === 'string' && value.trim()) {
      return value.trim();
    }
  }

  if (typeof player.email === 'string' && player.email.trim()) {
    return player.email.trim();
  }

  const nestedFields = ['player', 'user', 'member', 'participant'];
  for (const field of nestedFields) {
    if (player[field]) {
      const nestedName = resolvePlayerDisplayName(player[field], visited);
      if (nestedName && nestedName.trim()) {
        return nestedName;
      }
    }
  }

  visited.delete(player);
  return '';
}

function getPlayerDisplayName(player) {
  const name = resolvePlayerDisplayName(player);
  return name && name.trim() ? name.trim() : 'Jugador';
}

function getPlayerInitial(player) {
  const name = getPlayerDisplayName(player).trim();
  return name ? name.charAt(0).toUpperCase() : 'J';
}

function createMovementIcon(type) {
  const pathData = MOVEMENT_ICON_PATHS[type];
  if (!pathData) return null;

  const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
  svg.setAttribute('viewBox', '0 0 24 24');
  svg.setAttribute('aria-hidden', 'true');
  svg.classList.add('movement-icon');

  const circle = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
  circle.setAttribute('cx', '12');
  circle.setAttribute('cy', '12');
  circle.setAttribute('r', '11');
  circle.setAttribute('fill', 'var(--movement-badge-bg)');
  svg.appendChild(circle);

  const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
  path.setAttribute('d', pathData);
  path.setAttribute('fill', 'currentColor');
  svg.appendChild(path);

  return svg;
}

function resolveMovement(entry) {
  if (!entry) return null;

  const toFiniteNumber = (value) => {
    if (value === null || value === undefined || value === '') {
      return null;
    }
    const numeric = Number(value);
    return Number.isFinite(numeric) ? numeric : null;
  };

  const previousPosition = toFiniteNumber(entry.previousPosition);
  const delta = toFiniteNumber(entry.movementDelta);
  const lastPoints = toFiniteNumber(entry.lastMatchPoints);
  const previousPoints = toFiniteNumber(entry.previousMatchPoints);
  const lastResult =
    entry.lastMatchResult === 'win' || entry.lastMatchResult === 'loss'
      ? entry.lastMatchResult
      : null;

  let type = 'same';
  let positionDelta = null;

  if (entry.movement === 'nuevo' || previousPosition === null) {
    type = 'new';
  } else if (delta !== null) {
    positionDelta = delta;
    if (delta > 0) {
      type = 'up';
    } else if (delta < 0) {
      type = 'down';
    } else {
      type = 'same';
    }
  }

  const metrics = [];
  const ariaParts = [];

  if (lastPoints !== null) {
    const hasPrevious = previousPoints !== null;
    const comparisonValue = hasPrevious ? lastPoints - previousPoints : lastPoints;
    const metricType = comparisonValue > 0 ? 'positive' : comparisonValue < 0 ? 'negative' : 'neutral';
    const resultLabel = lastResult === 'win' ? 'V' : lastResult === 'loss' ? 'D' : '';
    const baseValue = hasPrevious ? comparisonValue : lastPoints;
    const signPrefix = hasPrevious && baseValue > 0 ? '+' : '';
    const formattedNumber = `${signPrefix}${baseValue}`;
    const valueText = `${resultLabel ? `${resultLabel} ` : ''}${formattedNumber} pts`;

    const matchDescriptor =
      lastResult === 'win'
        ? 'Victoria en el último partido'
        : lastResult === 'loss'
        ? 'Derrota en el último partido'
        : 'Último partido';
    let description;
    if (hasPrevious) {
      const previousComparison = ` (${lastPoints} vs ${previousPoints})`;
      if (comparisonValue > 0) {
        description = `${matchDescriptor}: ganó ${comparisonValue} puntos más que en el anterior${previousComparison}.`;
      } else if (comparisonValue < 0) {
        description = `${matchDescriptor}: consiguió ${Math.abs(comparisonValue)} puntos menos que en el anterior${previousComparison}.`;
      } else {
        description = `${matchDescriptor}: obtuvo los mismos puntos que en el anterior${previousComparison}.`;
      }
    } else {
      description = `${matchDescriptor}: sumó ${lastPoints} puntos.`;
    }

    metrics.push({
      key: 'performance',
      label: 'Último partido',
      value: valueText,
      type: metricType,
      description,
      delta: hasPrevious ? comparisonValue : null,
      result: lastResult,
    });
    ariaParts.push(description);
  }

  let positionDescription = '';
  if (type === 'new') {
    metrics.push({
      key: 'position',
      label: 'Posición',
      value: 'Nuevo',
      type: 'neutral',
      description: 'Nuevo ingreso al ranking.',
      delta: null,
    });
    ariaParts.push('Nuevo ingreso al ranking.');
  } else if (positionDelta !== null) {
    const absolute = Math.abs(positionDelta);
    let value;
    let metricType = 'neutral';
    if (positionDelta > 0) {
      value = `↑ ${absolute}`;
      metricType = 'positive';
      positionDescription = `Posición: sube ${absolute} ${absolute === 1 ? 'posición' : 'posiciones'}.`;
    } else if (positionDelta < 0) {
      value = `↓ ${absolute}`;
      metricType = 'negative';
      positionDescription = `Posición: baja ${absolute} ${absolute === 1 ? 'posición' : 'posiciones'}.`;
    } else {
      value = '= 0';
      positionDescription = 'Posición: se mantiene sin cambios.';
    }
    metrics.push({
      key: 'position',
      label: 'Posición',
      value,
      type: metricType,
      description: positionDescription,
      delta: positionDelta,
    });
    ariaParts.push(positionDescription);
  } else if (typeof entry.movement === 'string' && entry.movement.trim()) {
    const normalizedMovement = entry.movement.trim();
    const capitalized = `${normalizedMovement.charAt(0).toUpperCase()}${normalizedMovement.slice(1)}`;
    const descriptionText = `Posición: ${normalizedMovement}.`;
    metrics.push({
      key: 'position',
      label: 'Posición',
      value: capitalized,
      type: 'neutral',
      description: descriptionText,
      delta: null,
    });
    ariaParts.push(descriptionText);
  }

  if (!metrics.length) {
    return null;
  }

  return {
    type,
    metrics,
    ariaLabel: ariaParts.filter(Boolean).join(' '),
  };
}

function createMovementBadge(entry) {
  const movement = resolveMovement(entry);
  if (!movement) return null;

  const badge = document.createElement('span');
  badge.className = `movement-badge movement-badge--${movement.type}`;
  const style = MOVEMENT_STYLES[movement.type];
  if (style) {
    badge.style.setProperty('--movement-badge-bg', style.background);
    badge.style.color = style.color;
  }

  const icon = createMovementIcon(movement.type);
  if (icon) {
    badge.appendChild(icon);
  }

  const metrics = Array.isArray(movement.metrics) ? movement.metrics : [];
  if (metrics.length) {
    const metricsContainer = document.createElement('span');
    metricsContainer.className = 'movement-badge__metrics';
    metrics.forEach((metric) => {
      if (!metric || !metric.label) return;
      const metricElement = document.createElement('span');
      metricElement.className = `movement-badge__metric movement-badge__metric--${metric.type || 'neutral'}`;
      if (metric.description) {
        metricElement.title = metric.description;
      }

      const metricLabel = document.createElement('span');
      metricLabel.className = 'movement-badge__metric-label';
      metricLabel.textContent = metric.label;
      metricElement.appendChild(metricLabel);

      const metricValue = document.createElement('span');
      metricValue.className = 'movement-badge__metric-value';
      metricValue.textContent = metric.value ?? '—';
      metricElement.appendChild(metricValue);

      metricsContainer.appendChild(metricElement);
    });

    if (metricsContainer.childElementCount > 0) {
      badge.appendChild(metricsContainer);
    }
  }

  badge.setAttribute('aria-label', movement.ariaLabel || '');
  return badge;
}

function createAvatarElement(player, { size = 'md' } = {}) {
  const wrapper = document.createElement('div');
  wrapper.className = `player-avatar player-avatar--${size}`;

  const photo = typeof player?.photo === 'string' ? player.photo : '';

  if (photo) {
    const image = document.createElement('img');
    image.src = photo;
    image.alt = `Avatar de ${getPlayerDisplayName(player)}`;
    wrapper.appendChild(image);
  } else {
    wrapper.classList.add('player-avatar--placeholder');
    wrapper.textContent = getPlayerInitial(player);
  }

  return wrapper;
}

function buildPlayerCell(player, { includeSchedule = false, size = 'md' } = {}) {
  const container = document.createElement('div');
  container.className = 'player-cell';

  container.appendChild(createAvatarElement(player, { size }));

  const info = document.createElement('div');
  info.className = 'player-cell__info';

  const name = document.createElement('span');
  name.className = 'player-cell__name';
  name.textContent = getPlayerDisplayName(player);
  info.appendChild(name);

  if (includeSchedule && player?.preferredSchedule) {
    const schedule = document.createElement('span');
    schedule.className = 'player-cell__meta';
    schedule.textContent = SCHEDULE_LABELS[player.preferredSchedule] || player.preferredSchedule;
    info.appendChild(schedule);
  }

  container.appendChild(info);
  return container;
}

function getMovementIconMarkup(type) {
  const path = MOVEMENT_ICON_PATHS[type];
  if (!path) return '';
  return `
    <svg class="movement-icon" viewBox="0 0 24 24" aria-hidden="true">
      <circle cx="12" cy="12" r="11" fill="var(--movement-badge-bg)"></circle>
      <path d="${path}" fill="currentColor"></path>
    </svg>
  `;
}

function buildMovementBadgeMarkup(entry) {
  const movement = resolveMovement(entry);
  if (!movement) {
    return '<span class="movement-badge movement-badge--none">—</span>';
  }

  const style = MOVEMENT_STYLES[movement.type] || MOVEMENT_STYLES.same;
  const iconMarkup = getMovementIconMarkup(movement.type);
  const metrics = Array.isArray(movement.metrics) ? movement.metrics : [];
  const metricsMarkup = metrics
    .filter((metric) => metric && metric.label)
    .map((metric) => {
      const titleAttr = metric.description
        ? ` title="${escapeHtml(metric.description)}"`
        : '';
      return `
        <span class="movement-badge__metric movement-badge__metric--${metric.type || 'neutral'}"${titleAttr}>
          <span class="movement-badge__metric-label">${escapeHtml(metric.label)}</span>
          <span class="movement-badge__metric-value">${escapeHtml(metric.value ?? '—')}</span>
        </span>
      `;
    })
    .join('');
  const ariaAttr = movement.ariaLabel
    ? ` aria-label="${escapeHtml(movement.ariaLabel)}"`
    : '';
  return `
    <span class="movement-badge movement-badge--${movement.type}" style="--movement-badge-bg:${style.background};color:${style.color};"${ariaAttr}>
      ${iconMarkup}
      <span class="movement-badge__metrics">${metricsMarkup}</span>
    </span>
  `.trim();
}

function buildPlayerCellMarkup(player, { includeSchedule = false } = {}) {
  const displayName = getPlayerDisplayName(player);
  const safeName = escapeHtml(displayName);
  const scheduleLabel =
    includeSchedule && player?.preferredSchedule
      ? escapeHtml(SCHEDULE_LABELS[player.preferredSchedule] || player.preferredSchedule)
      : '';
  const photo = typeof player?.photo === 'string' ? player.photo : '';
  const hasPhoto = Boolean(photo);
  const avatarClasses = ['player-avatar', 'player-avatar--md'];
  let avatarContent = '';

  if (hasPhoto) {
    avatarContent = `<img src="${photo}" alt="Avatar de ${safeName}" />`;
  } else {
    avatarClasses.push('player-avatar--placeholder');
    avatarContent = escapeHtml(getPlayerInitial(player));
  }

  return `
    <div class="player-cell">
      <div class="${avatarClasses.join(' ')}">${avatarContent}</div>
      <div class="player-cell__info">
        <span class="player-cell__name">${safeName}</span>
        ${scheduleLabel ? `<span class="player-cell__meta">${scheduleLabel}</span>` : ''}
      </div>
    </div>
  `.trim();
}

const state = {
  token: null,
  user: null,
  categories: [],
  categoriesLoaded: false,
  leagues: [],
  players: [],
  myMatches: [],
  upcomingMatches: [],
  pendingApprovalMatches: [],
  completedMatches: [],
  selectedCategoryId: null,
  selectedLeagueId: '',
  selectedApp: 'tennis',
  rankingFilters: { league: '' },
  needsSetup: false,
  accountSummary: null,
  accountSummaryLoading: false,
  enrollments: new Map(),
  enrollmentRequests: new Map(),
  tournaments: [],
  tournamentDetails: new Map(),
  selectedTournamentId: '',
  selectedTournamentCategoriesId: '',
  selectedEnrollmentTournamentId: '',
  selectedEnrollmentCategoryId: TOURNAMENT_ENROLLMENT_ALL_OPTION,
  selectedMatchTournamentId: '',
  selectedMatchCategoryId: '',
  selectedOrderOfPlayDay: '',
  selectedDoublesTournamentId: '',
  selectedBracketTournamentId: '',
  selectedBracketCategoryId: '',
  tournamentEnrollments: new Map(),
  tournamentEnrollmentFilters: {
    search: '',
    gender: '',
  },
  tournamentMatches: new Map(),
  tournamentOrderOfPlayDays: new Map(),
  tournamentBracketMatches: new Map(),
  tournamentBracketAlignmentCallbacks: new Set(),
  tournamentBracketResizeHandler: null,
  tournamentPayments: new Map(),
  tournamentDoubles: new Map(),
  tournamentDoublesPairs: new Map(),
  tournamentPaymentFilters: {
    tournament: '',
    search: '',
  },
  tournamentPaymentsLoading: false,
  activeSection: 'section-dashboard',
  globalOverview: null,
  leagueDashboard: null,
  leagueDashboardPlayersPage: 1,
  tournamentDashboard: null,
  calendarMatches: [],
  calendarDate: new Date(),
  globalCalendarDate: new Date(),
  globalCalendarViewMode: 'month',
  matchPagination: {
    upcoming: {},
    pending: {},
    completed: {},
  },
  adminCategoryEditingId: null,
  adminPlayerEditingId: null,
  adminMatchEditingId: null,
  seasons: [],
  club: null,
  rankingsByCategory: new Map(),
  rankingsLoading: false,
  generalChatMessages: [],
  noticeUnreadCount: 0,
  tournamentBracketSeedsDirty: false,
  playerDirectoryFilters: {
    search: '',
    gender: '',
    role: '',
    category: '',
  },
  leaguePlayersFilters: {
    league: '',
    category: '',
    search: '',
    gender: '',
  },
  categoryFilters: {
    league: '',
  },
  leaguePlayersLoading: false,
  leagueDetails: new Map(),
  leaguePayments: new Map(),
  leaguePaymentFilters: {
    league: '',
    search: '',
  },
  leaguePaymentsLoading: false,
  courtReservations: [],
  courtAvailability: [],
  courtAvailabilityDate: new Date(),
  courtAvailabilityCourt: '',
  courtAvailabilityIgnoreManualLimit: false,
  courtAdminDate: new Date(),
  courtAdminCourt: '',
  courtAdminSchedule: [],
  courtAdminBlocks: [],
  courtAdminIgnoreManualLimit: false,
  courtCalendarDate: new Date(),
  courtCalendarEvents: [],
  courtCalendarViewMode: 'month',
  playerCourtCalendarDate: new Date(),
  courtBlocks: [],
  reservationPlayers: [],
  push: {
    supported: PUSH_SUPPORTED,
    permission: PUSH_SUPPORTED ? Notification.permission : 'default',
    enabled: false,
    configLoaded: false,
    serverEnabled: false,
    publicKey: null,
    subscriptionEndpoint: null,
    loading: false,
  },
};

const tabButtons = document.querySelectorAll('.tab-button');
const tabPanes = document.querySelectorAll('.tab-pane');
const authView = document.getElementById('auth-view');
const appView = document.getElementById('app-view');
const appMenu = document.getElementById('app-menu');
const appSidebar = document.getElementById('app-sidebar');
const mobileMenuToggle = document.getElementById('mobile-menu-toggle');
const mobileMenuBackdrop = document.getElementById('mobile-menu-backdrop');
const mobileMenuClose = document.getElementById('mobile-menu-close');
const mobileTopbarLogo = document.getElementById('mobile-topbar-logo');
const mobileTopbarTitle = document.getElementById('mobile-topbar-title');
const appSwitcher = document.getElementById('app-switcher');
const appSwitcherButtons = appSwitcher
  ? Array.from(appSwitcher.querySelectorAll('.app-switcher__button'))
  : [];
const authDescription = document.getElementById('auth-description');
const loginForm = document.getElementById('login-form');
const registerForm = document.getElementById('register-form');
const loginStatus = document.getElementById('login-status');
const loginEmailInput = loginForm ? loginForm.querySelector('input[name="email"]') : null;
const loginPasswordInput = loginForm ? loginForm.querySelector('input[name="password"]') : null;
const loginRememberCheckbox = document.getElementById('login-remember');
const registerStatus = document.getElementById('register-status');
const registerRoleWrapper = document.getElementById('register-role-wrapper');
const registerIsMemberCheckbox = document.getElementById('register-is-member');
const registerMembershipWrapper = document.getElementById('register-membership-wrapper');
const registerMembershipNumberInput = document.getElementById('register-membership-number');
const profileName = document.getElementById('profile-name');
const profileAvatar = document.getElementById('profile-avatar');
const profileEditButton = document.getElementById('profile-edit');
const profileForm = document.getElementById('profile-form');
const profileCancelButton = document.getElementById('profile-cancel');
const profileStatus = document.getElementById('profile-status');
const profileIsMemberCheckbox = document.getElementById('profile-is-member');
const profileMembershipWrapper = document.getElementById('profile-membership-wrapper');
const profileMembershipNumberInput = document.getElementById('profile-membership-number');
const accountOverview = document.getElementById('account-overview');
const accountPhoto = document.getElementById('account-photo');
const accountFullName = document.getElementById('account-full-name');
const accountEmail = document.getElementById('account-email');
const accountPhone = document.getElementById('account-phone');
const accountMembershipStatus = document.getElementById('account-membership');
const accountMembershipNumber = document.getElementById('account-membership-number');
const accountMembershipNumberRow = document.getElementById('account-membership-number-row');
const accountShirtSize = document.getElementById('account-shirt-size');
const accountBirthDate = document.getElementById('account-birth-date');
const accountSchedule = document.getElementById('account-schedule');
const accountNotes = document.getElementById('account-notes');
const accountPushStatus = document.getElementById('account-push-status');
const accountDashboardCard = document.getElementById('account-dashboard-card');
const accountDashboard = document.getElementById('account-dashboard');
const accountDashboardEmpty = document.getElementById('account-dashboard-empty');
const accountDashboardStatus = document.getElementById('account-dashboard-status');
const accountDashboardRefresh = document.getElementById('account-dashboard-refresh');
const accountEnrollmentsCount = document.getElementById('account-enrollments-count');
const accountUpcomingCount = document.getElementById('account-upcoming-count');
const accountRecentCount = document.getElementById('account-recent-count');
const accountPaymentsCount = document.getElementById('account-payments-count');
const accountPaymentsPaid = document.getElementById('account-payments-paid');
const accountPaymentsPending = document.getElementById('account-payments-pending');
const accountPaymentsTotal = document.getElementById('account-payments-total');
const accountEnrollmentsList = document.getElementById('account-enrollments-list');
const accountEnrollmentsEmpty = document.getElementById('account-enrollments-empty');
const accountUpcomingList = document.getElementById('account-upcoming-list');
const accountUpcomingEmpty = document.getElementById('account-upcoming-empty');
const accountRecentList = document.getElementById('account-recent-list');
const accountRecentEmpty = document.getElementById('account-recent-empty');
const accountPaymentsList = document.getElementById('account-payments-list');
const accountPaymentsEmpty = document.getElementById('account-payments-empty');
const appSections = document.querySelectorAll('.app-section');
const globalLeaguesCount = document.getElementById('global-leagues-count');
const globalTournamentsCount = document.getElementById('global-tournaments-count');
const globalCategoriesCount = document.getElementById('global-categories-count');
const globalCourtsCount = document.getElementById('global-courts-count');
const globalLeaguesList = document.getElementById('global-leagues-list');
const globalTournamentsList = document.getElementById('global-tournaments-list');
const globalUpcomingMatchesList = document.getElementById('global-upcoming-matches');
const leagueMetricPlayers = document.getElementById('league-metric-players');
const leagueMetricCategories = document.getElementById('league-metric-categories');
const leagueMetricUpcoming = document.getElementById('league-metric-upcoming');
const leagueActiveSummary = document.getElementById('league-active-summary');
const leagueActiveCount = document.getElementById('league-active-count');
const leagueActiveList = document.getElementById('league-active-list');
const leagueRankingCards = document.getElementById('league-ranking-cards');
const leagueUpcomingMatchesList = document.getElementById('league-upcoming-matches');
const leagueEnrolledPlayersList = document.getElementById('league-enrolled-players');
const leagueEnrolledPagination = document.getElementById('league-enrolled-pagination');
const tournamentMetricActive = document.getElementById('tournament-metric-active');
const tournamentMetricCategories = document.getElementById('tournament-metric-categories');
const tournamentMetricUpcoming = document.getElementById('tournament-metric-upcoming');
const tournamentDrawCards = document.getElementById('tournament-draw-cards');
const tournamentUpcomingMatchesList = document.getElementById('tournament-upcoming-matches');
const tournamentBracketTournamentSelect = document.getElementById('tournament-bracket-tournament');
const tournamentBracketCategorySelect = document.getElementById('tournament-bracket-category');
const tournamentBracketSizeSelect = document.getElementById('tournament-bracket-size');
const tournamentBracketSizeWrapper = document.getElementById('tournament-bracket-size-wrapper');
const tournamentBracketSeedsContainer = document.getElementById('tournament-bracket-seeds');
const tournamentBracketSeedsCard = document.getElementById('tournament-bracket-seeds-card');
const tournamentBracketLayout = document.querySelector('.tournament-bracket-layout');
const tournamentBracketViewCard = document.getElementById('tournament-bracket-view-card');
const tournamentBracketView = document.getElementById('tournament-bracket-view');
const tournamentBracketEmpty = document.getElementById('tournament-bracket-empty');
const tournamentBracketFullscreenButton = document.getElementById('tournament-bracket-fullscreen');
const tournamentConsolationViewCard = document.getElementById('tournament-consolation-view-card');
const tournamentConsolationFullscreenButton = document.getElementById('tournament-consolation-fullscreen');
const tournamentConsolationView = document.getElementById('tournament-consolation-view');
const tournamentConsolationEmpty = document.getElementById('tournament-consolation-empty');
const tournamentBracketStatus = document.getElementById('tournament-bracket-status');
const tournamentBracketSaveSeedsButton = document.getElementById('tournament-bracket-save-seeds');
const tournamentBracketPreviewButton = document.getElementById('tournament-bracket-preview');
const tournamentBracketGenerateButton = document.getElementById('tournament-bracket-generate');
const tournamentBracketClearButton = document.getElementById('tournament-bracket-clear');
const tournamentBracketRecalculateButton = document.getElementById('tournament-bracket-recalculate');
const topbarLogo = document.getElementById('topbar-logo');
const clubNameHeading = document.getElementById('club-name-heading');
const clubSloganHeading = document.getElementById('club-slogan');
const clubLogoDisplay = document.getElementById('club-logo-display');
const clubNameDisplay = document.getElementById('club-name-display');
const clubSloganDisplay = document.getElementById('club-slogan-display');
const clubDescription = document.getElementById('club-description');
const clubAddress = document.getElementById('club-address');
const clubContact = document.getElementById('club-contact');
const clubWebsite = document.getElementById('club-website');
const clubScheduleList = document.getElementById('club-schedule-list');
const clubScheduleEmpty = document.getElementById('club-schedule-empty');
const clubCourtsList = document.getElementById('club-courts-list');
const clubCourtsEmpty = document.getElementById('club-courts-empty');
const clubFacilitiesList = document.getElementById('club-facilities-list');
const clubFacilitiesEmpty = document.getElementById('club-facilities-empty');
const clubEditButton = document.getElementById('club-edit-button');
const clubStatus = document.getElementById('club-status');
const courtReservationForm = document.getElementById('court-reservation-form');
const courtReservationDateInput = document.getElementById('court-reservation-date');
const courtReservationTimeInput = document.getElementById('court-reservation-time');
const courtReservationDurationSelect = document.getElementById('court-reservation-duration');
const courtReservationCourtSelect = document.getElementById('court-reservation-court');
const courtReservationNotesInput = document.getElementById('court-reservation-notes');
const courtReservationStatus = document.getElementById('court-reservation-status');
const courtReservationSubmit = document.getElementById('court-reservation-submit');
const courtReservationList = document.getElementById('court-reservation-list');
const courtReservationEmpty = document.getElementById('court-reservation-empty');
const courtReservationParticipantsContainer = document.getElementById(
  'court-reservation-participants-container'
);
const courtReservationParticipantsHint = document.getElementById('court-reservation-participants-hint');
const defaultCourtReservationParticipantsHint = courtReservationParticipantsHint
  ? courtReservationParticipantsHint.textContent
  : '';
const playerCourtCalendarContainer = document.getElementById('player-court-calendar-container');
const playerCourtCalendarLabel = document.getElementById('player-court-calendar-label');
const playerCourtCalendarPrev = document.getElementById('player-court-calendar-prev');
const playerCourtCalendarNext = document.getElementById('player-court-calendar-next');
const playerCourtCalendarStatus = document.getElementById('player-court-calendar-status');
const playerCourtCalendarDateInput = document.getElementById('player-court-calendar-date');
const courtAvailabilityDateInput = document.getElementById('court-availability-date');
const courtAvailabilityList = document.getElementById('court-availability-list');
const courtAvailabilityEmpty = document.getElementById('court-availability-empty');
const courtAdminDateInput = document.getElementById('court-admin-date');
const courtAdminSchedule = document.getElementById('court-admin-schedule');
const courtAdminEmpty = document.getElementById('court-admin-empty');
const courtAdminStatus = document.getElementById('court-admin-status');
const courtCalendarContainer = document.getElementById('court-calendar-container');
const courtCalendarLabel = document.getElementById('court-calendar-label');
const courtCalendarPrev = document.getElementById('court-calendar-prev');
const courtCalendarNext = document.getElementById('court-calendar-next');
const courtCalendarStatus = document.getElementById('court-calendar-status');
const courtCalendarViewButtons = document.querySelectorAll('[data-court-calendar-view]');
const courtBlockForm = document.getElementById('court-block-form');
const courtBlockContextSelect = document.getElementById('court-block-context');
const courtBlockEntitySelect = document.getElementById('court-block-entity');
const courtBlockCourtsSelect = document.getElementById('court-block-courts');
const courtBlockStartInput = document.getElementById('court-block-start');
const courtBlockEndInput = document.getElementById('court-block-end');
const courtBlockNotesInput = document.getElementById('court-block-notes');
const courtBlockStatus = document.getElementById('court-block-status');
const courtBlocksList = document.getElementById('court-blocks-list');
const courtBlocksEmpty = document.getElementById('court-blocks-empty');
const courtBlockSubmit = courtBlockForm ? courtBlockForm.querySelector('button[type="submit"]') : null;
const rankingLeagueFilter = document.getElementById('ranking-league-filter');
const rankingPrintButton = document.getElementById('ranking-print-button');
const logoutButtons = Array.from(document.querySelectorAll('[data-action="logout"]'));
const globalMessage = document.getElementById('global-message');
const categoriesList = document.getElementById('categories-list');
const categoryLeagueFilter = document.getElementById('categories-league-filter');
const leaguesList = document.getElementById('leagues-list');
const notificationsList = document.getElementById('notifications-list');
const matchesMenuBadge = document.getElementById('menu-matches-badge');
const notificationsMenuBadge = document.getElementById('menu-notifications-badge');
const noticesMenuBadge = document.getElementById('menu-notices-badge');
const metricNotifications = document.getElementById('metric-notifications');
const tournamentsList = document.getElementById('tournaments-list');
const tournamentDetailCard = document.getElementById('tournament-detail-card');
const tournamentDetailTitle = document.getElementById('tournament-detail-title');
const tournamentDetailSubtitle = document.getElementById('tournament-detail-subtitle');
const tournamentDetailBody = document.getElementById('tournament-detail-body');
const tournamentAdminEnrollButton = document.getElementById('tournament-admin-enroll-button');
const tournamentCategoryTournamentSelect = document.getElementById('tournament-category-tournament');
const tournamentCategoriesList = document.getElementById('tournament-categories-list');
const tournamentCategoriesEmpty = document.getElementById('tournament-categories-empty');
const tournamentCategoriesPoster = document.getElementById('tournament-categories-poster');
const tournamentEnrollmentTournamentSelect = document.getElementById('tournament-enrollment-tournament');
const tournamentEnrollmentCategorySelect = document.getElementById('tournament-enrollment-category');
const tournamentEnrollmentCount = document.getElementById('tournament-enrollment-count');
const tournamentEnrollmentSearch = document.getElementById('tournament-enrollment-search');
const tournamentEnrollmentGender = document.getElementById('tournament-enrollment-gender');
const tournamentEnrollmentList = document.getElementById('tournament-enrollment-list');
const tournamentEnrollmentEmpty = document.getElementById('tournament-enrollment-empty');
const tournamentDoublesTournamentSelect = document.getElementById('tournament-doubles-tournament');
const tournamentDoublesContainer = document.getElementById('tournament-doubles-container');
const tournamentDoublesEmpty = document.getElementById('tournament-doubles-empty');
const tournamentMatchTournamentSelect = document.getElementById('tournament-match-tournament');
const tournamentMatchCategorySelect = document.getElementById('tournament-match-category');
const tournamentMatchesList = document.getElementById('tournament-matches-list');
const tournamentMatchesEmpty = document.getElementById('tournament-matches-empty');
const tournamentOrderDayInput = document.getElementById('tournament-order-day');
const tournamentOrderDownloadButton = document.getElementById('tournament-order-download');
const pushSettingsCard = document.getElementById('push-settings-card');
const pushStatusText = document.getElementById('push-status-text');
const pushEnableButton = document.getElementById('push-enable-button');
const pushDisableButton = document.getElementById('push-disable-button');
const pushPermissionWarning = document.getElementById('push-permission-warning');
const pushUnsupportedWarning = document.getElementById('push-unsupported-warning');

if (loginRememberCheckbox) {
  loginRememberCheckbox.addEventListener('change', () => {
    if (!loginRememberCheckbox.checked) {
      clearRememberedCredentials();
    }
  });
}

const upcomingList = document.getElementById('upcoming-matches');
const myMatchesList = document.getElementById('my-matches');
let activeProposalForm = null;
let activeProposalMatchId = null;
let pushServiceWorkerRegistration = null;
let pushServiceWorkerRegistrationPromise = null;
const pendingApprovalsList = document.getElementById('pending-approvals');
const completedMatchesList = document.getElementById('completed-matches');
let pendingTournamentDetailId = null;
let pendingLeagueDetailId = null;
let pendingTournamentEnrollmentKey = '';
let pendingTournamentMatchesKey = '';
let pendingTournamentBracketKey = '';
let pendingTournamentDoublesId = '';
const generalChatMessagesList = document.getElementById('general-chat-messages');
const generalChatForm = document.getElementById('general-chat-form');
const generalChatInput = document.getElementById('general-chat-input');
const generalChatToolbar = document.getElementById('general-chat-toolbar');
const generalChatEditor = document.getElementById('general-chat-editor');
const generalChatAttachmentInput = document.getElementById('general-chat-attachment-input');
const generalChatImageInput = document.getElementById('general-chat-image-input');
const generalChatAttachments = document.getElementById('general-chat-attachments');
const generalChatAttachmentsList = generalChatAttachments
  ? generalChatAttachments.querySelector('.chat-attachments-list')
  : null;
const leagueRulesContent = document.getElementById('rules-content');
const leagueRulesEditButton = document.getElementById('rules-edit-button');
const tournamentRulesContent = document.getElementById('tournament-rules-content');
const tournamentRulesEditButton = document.getElementById('tournament-rules-edit-button');
const rankingStatus = document.getElementById('ranking-status');
const rankingCategoryList = document.getElementById('ranking-category-list');
const rankingEmpty = document.getElementById('ranking-empty');
const menuButtons = appMenu ? Array.from(appMenu.querySelectorAll('.menu-button')) : [];
const leaguePaymentsMenuButton = appMenu
  ? appMenu.querySelector('[data-target="section-league-payments"]')
  : null;
const tournamentPaymentsMenuButton = appMenu
  ? appMenu.querySelector('[data-target="section-tournament-payments"]')
  : null;
const leaguePaymentsSection = document.getElementById('section-league-payments');
const tournamentPaymentsSection = document.getElementById('section-tournament-payments');
const adminMenuButtons = menuButtons.filter((button) => button.dataset.requiresAdmin === 'true');
const adminSectionIds = new Set(adminMenuButtons.map((button) => button.dataset.target));
const courtManagerMenuButtons = menuButtons.filter(
  (button) => button.dataset.requiresCourtManager === 'true'
);
const courtManagerSectionIds = new Set(
  courtManagerMenuButtons.map((button) => button.dataset.target)
);
const menuButtonInitialHidden = new Map(menuButtons.map((button) => [button, button.hidden]));
const adminToggleElements = document.querySelectorAll('[data-admin-visible="toggle"]');

function refreshTournamentBracketLayoutColumns() {
  if (!tournamentBracketLayout) {
    return;
  }
  const seedsVisible = tournamentBracketSeedsCard && !tournamentBracketSeedsCard.hidden;
  tournamentBracketLayout.classList.toggle('tournament-bracket-layout--single-column', !seedsVisible);
}

function setBracketFullscreenButtonState(button, active) {
  if (!button) {
    return;
  }
  button.dataset.fullscreen = active ? 'true' : 'false';
  button.setAttribute('aria-pressed', active ? 'true' : 'false');
  button.textContent = active ? 'Salir de pantalla completa' : 'Ver a pantalla completa';
}

function isFallbackBracketFullscreen(card) {
  return Boolean(card && card.classList.contains('tournament-bracket-card--fullscreen'));
}

function clearFallbackBracketFullscreen(card, button, { skipCard = null } = {}) {
  if (!card || card === skipCard) {
    return;
  }
  if (isFallbackBracketFullscreen(card)) {
    card.classList.remove('tournament-bracket-card--fullscreen');
    if (button) {
      setBracketFullscreenButtonState(button, false);
    }
  }
}

function updateBracketFallbackFullscreenLock() {
  const fallbackActive =
    isFallbackBracketFullscreen(tournamentBracketViewCard) ||
    isFallbackBracketFullscreen(tournamentConsolationViewCard);
  document.body.classList.toggle('tournament-fullscreen-active', fallbackActive);
}

function isCardInFullscreen(card) {
  if (!card) {
    return false;
  }
  return document.fullscreenElement === card || isFallbackBracketFullscreen(card);
}

async function toggleBracketCardFullscreen(card, button) {
  if (!card || !button) {
    return;
  }

  if (isCardInFullscreen(card)) {
    if (document.fullscreenElement === card && document.exitFullscreen) {
      try {
        await document.exitFullscreen();
      } catch (error) {
        // Ignorar fallos al salir de pantalla completa nativa.
      }
    }
    card.classList.remove('tournament-bracket-card--fullscreen');
    syncBracketFullscreenState();
    return;
  }

  clearFallbackBracketFullscreen(tournamentBracketViewCard, tournamentBracketFullscreenButton, {
    skipCard: card,
  });
  clearFallbackBracketFullscreen(
    tournamentConsolationViewCard,
    tournamentConsolationFullscreenButton,
    {
      skipCard: card,
    }
  );
  updateBracketFallbackFullscreenLock();

  if (document.fullscreenElement && document.fullscreenElement !== card && document.exitFullscreen) {
    try {
      await document.exitFullscreen();
    } catch (error) {
      // Ignorar fallos al salir de pantalla completa nativa.
    }
  }

  if (card.requestFullscreen) {
    try {
      await card.requestFullscreen();
      syncBracketFullscreenState();
      return;
    } catch (error) {
      // Si la API nativa falla, usar la alternativa basada en estilos.
    }
  }

  card.classList.add('tournament-bracket-card--fullscreen');
  syncBracketFullscreenState();
}

function syncBracketFullscreenState() {
  setBracketFullscreenButtonState(
    tournamentBracketFullscreenButton,
    isCardInFullscreen(tournamentBracketViewCard)
  );
  setBracketFullscreenButtonState(
    tournamentConsolationFullscreenButton,
    isCardInFullscreen(tournamentConsolationViewCard)
  );
  updateBracketFallbackFullscreenLock();
}

refreshTournamentBracketLayoutColumns();
syncBracketFullscreenState();

function setMenuGroupExpanded(menuGroup, expanded) {
  if (!menuGroup) return;
  const { parentButton, submenu, group } = menuGroup;
  if (expanded) {
    cancelScheduledCollapse(menuGroup);
  }
  if (parentButton) {
    parentButton.setAttribute('aria-expanded', expanded ? 'true' : 'false');
  }
  if (group) {
    group.classList.toggle('menu-group--expanded', expanded);
  }
  if (submenu) {
    submenu.hidden = !expanded;
  }
}

function focusFirstSubmenuButton(menuGroup) {
  const candidate = menuGroup?.submenu?.querySelector(
    '.menu-button:not([disabled]):not([hidden])'
  );
  if (!candidate) {
    return;
  }
  requestAnimationFrame(() => {
    candidate.focus();
  });
}

function expandMenuGroup(menuGroup, { focusFirstItem = false } = {}) {
  if (!menuGroup) {
    return;
  }
  collapsibleMenuGroups.forEach((otherGroup) => {
    if (otherGroup !== menuGroup) {
      setMenuGroupExpanded(otherGroup, false);
    }
  });
  setMenuGroupExpanded(menuGroup, true);
  if (focusFirstItem) {
    focusFirstSubmenuButton(menuGroup);
  }
}

const collapsibleMenuGroups = appMenu
  ? Array.from(appMenu.querySelectorAll('[data-collapsible="true"]'))
      .map((group) => {
        const parentButton = group.querySelector('.menu-button--parent');
        const submenu = group.querySelector('.menu-submenu');
        if (!parentButton || !submenu) {
          return null;
        }
        const menuGroup = {
          group,
          parentButton,
          submenu,
          target: parentButton.dataset.target || null,
          collapseTimeoutId: null,
        };
        setMenuGroupExpanded(menuGroup, false);
        return menuGroup;
      })
      .filter(Boolean)
  : [];

function cancelScheduledCollapse(menuGroup) {
  if (!menuGroup || menuGroup.collapseTimeoutId == null) {
    return;
  }
  clearTimeout(menuGroup.collapseTimeoutId);
  menuGroup.collapseTimeoutId = null;
}

const collapsibleMenuGroupsByElement = new Map();

const collapsibleMenuGroupsByTarget = new Map();
collapsibleMenuGroups.forEach((menuGroup) => {
  if (menuGroup.target) {
    collapsibleMenuGroupsByTarget.set(menuGroup.target, menuGroup);
  }

  if (menuGroup.group) {
    collapsibleMenuGroupsByElement.set(menuGroup.group, menuGroup);
  }

  const { group, parentButton, submenu } = menuGroup;
  if (!group) {
    return;
  }

  group.addEventListener('mouseenter', () => {
    if (!shouldUseHoverNavigation()) {
      return;
    }
    cancelScheduledCollapse(menuGroup);
    setMenuGroupExpanded(menuGroup, true);
  });

  group.addEventListener('mouseleave', (event) => {
    if (!shouldUseHoverNavigation()) {
      return;
    }
    const relatedTarget = event.relatedTarget;
    if (relatedTarget && group.contains(relatedTarget)) {
      return;
    }
    scheduleCollapseIfInactive(menuGroup);
  });

  group.addEventListener('focusin', () => {
    if (!shouldUseHoverNavigation()) {
      return;
    }
    cancelScheduledCollapse(menuGroup);
    setMenuGroupExpanded(menuGroup, true);
  });

  group.addEventListener('focusout', () => {
    if (!shouldUseHoverNavigation()) {
      return;
    }
    scheduleCollapseIfInactive(menuGroup);
  });

  if (parentButton) {
    parentButton.addEventListener('blur', () => {
      if (!shouldUseHoverNavigation()) {
        return;
      }
      scheduleCollapseIfInactive(menuGroup);
    });
  }

  if (submenu) {
    submenu.addEventListener('mouseenter', () => {
      if (!shouldUseHoverNavigation()) {
        return;
      }
      cancelScheduledCollapse(menuGroup);
      setMenuGroupExpanded(menuGroup, true);
    });
    submenu.addEventListener('focusout', () => {
      if (!shouldUseHoverNavigation()) {
        return;
      }
      scheduleCollapseIfInactive(menuGroup);
    });
    submenu.addEventListener('mouseleave', () => {
      if (!shouldUseHoverNavigation()) {
        return;
      }
      scheduleCollapseIfInactive(menuGroup);
    });
  }
});
const desktopMediaQuery = typeof window !== 'undefined' && window.matchMedia ? window.matchMedia('(min-width: 1025px)') : null;
const hoverMediaQuery = typeof window !== 'undefined' && window.matchMedia ? window.matchMedia('(hover: hover)') : null;

function shouldUseHoverNavigation() {
  return Boolean(desktopMediaQuery?.matches && hoverMediaQuery?.matches);
}

function isMenuGroupActive(menuGroup) {
  if (!menuGroup) {
    return false;
  }

  if (shouldUseHoverNavigation()) {
    const activeElement = document.activeElement;
    const hasFocus = menuGroup.group?.contains(activeElement);
    const isHovered = menuGroup.group?.matches(':hover');
    if (!hasFocus && !isHovered) {
      return false;
    }
  }

  if (menuGroup.parentButton?.classList.contains('active')) {
    return true;
  }
  return Boolean(menuGroup.submenu?.querySelector('.menu-button.active'));
}

function scheduleCollapseIfInactive(menuGroup) {
  if (!menuGroup) {
    return;
  }
  cancelScheduledCollapse(menuGroup);
  const delay = shouldUseHoverNavigation() ? 120 : 0;
  const collapse = () => {
    const activeElement = document.activeElement;
    if (menuGroup.group?.contains(activeElement)) {
      return;
    }
    if (isMenuGroupActive(menuGroup)) {
      return;
    }
    setMenuGroupExpanded(menuGroup, false);
    menuGroup.collapseTimeoutId = null;
  };
  if (delay > 0) {
    menuGroup.collapseTimeoutId = window.setTimeout(collapse, delay);
  } else {
    requestAnimationFrame(collapse);
  }
}

function collapseInactiveMenuGroups() {
  collapsibleMenuGroups.forEach((menuGroup) => {
    if (!isMenuGroupActive(menuGroup)) {
      setMenuGroupExpanded(menuGroup, false);
    }
  });
}

function handleOutsideMenuClick(event) {
  if (!shouldUseHoverNavigation()) {
    return;
  }
  if (event.defaultPrevented) {
    return;
  }
  const menuGroupElement = event.target.closest('.menu-group');
  if (menuGroupElement) {
    return;
  }
  collapsibleMenuGroups.forEach((menuGroup) => {
    if (!isMenuGroupActive(menuGroup)) {
      setMenuGroupExpanded(menuGroup, false);
    }
  });
}

function isMobileMenuSupported() {
  return Boolean(appSidebar && mobileMenuToggle);
}

function isMobileMenuOpen() {
  return appSidebar?.classList.contains('sidebar--mobile-open');
}

function openMobileMenu() {
  if (!isMobileMenuSupported()) return;

  appSidebar.classList.add('sidebar--mobile-open');
  document.body.classList.add('mobile-menu-open');
  if (mobileMenuToggle) {
    mobileMenuToggle.setAttribute('aria-expanded', 'true');
  }
  if (mobileMenuBackdrop) {
    mobileMenuBackdrop.hidden = false;
    requestAnimationFrame(() => {
      mobileMenuBackdrop.classList.add('is-active');
    });
  }

  const focusTarget = menuButtons.find((button) => !button.hidden && !button.disabled) || appSidebar;
  if (focusTarget) {
    requestAnimationFrame(() => {
      focusTarget.focus();
    });
  }
}

function closeMobileMenu({ restoreFocus = false } = {}) {
  if (!isMobileMenuSupported()) return;

  appSidebar.classList.remove('sidebar--mobile-open');
  document.body.classList.remove('mobile-menu-open');
  if (mobileMenuToggle) {
    mobileMenuToggle.setAttribute('aria-expanded', 'false');
  }

  if (mobileMenuBackdrop && !mobileMenuBackdrop.hidden) {
    const finalize = () => {
      mobileMenuBackdrop.hidden = true;
      mobileMenuBackdrop.classList.remove('is-active');
    };

    mobileMenuBackdrop.addEventListener('transitionend', finalize, { once: true });
    mobileMenuBackdrop.addEventListener('transitioncancel', finalize, { once: true });

    requestAnimationFrame(() => {
      mobileMenuBackdrop.classList.remove('is-active');
      const styles = getComputedStyle(mobileMenuBackdrop);
      const durations = styles.transitionDuration
        ? styles.transitionDuration.split(',').map((value) => parseFloat(value) || 0)
        : [0];
      const hasDuration = durations.some((duration) => duration > 0);
      if (!hasDuration) {
        finalize();
      }
    });
  }

  if (restoreFocus && mobileMenuToggle) {
    mobileMenuToggle.focus();
  }
}

function toggleMobileMenu() {
  if (!isMobileMenuSupported()) return;
  if (isMobileMenuOpen()) {
    closeMobileMenu({ restoreFocus: true });
  } else {
    openMobileMenu();
  }
}

function handleDesktopMediaChange(event) {
  if (event.matches) {
    closeMobileMenu();
    setActiveMenu(state.activeSection);
  } else {
    collapseInactiveMenuGroups();
  }
}

function handleHoverMediaChange() {
  if (shouldUseHoverNavigation()) {
    setActiveMenu(state.activeSection);
  } else {
    collapseInactiveMenuGroups();
  }
}
const adminCategoryForm = document.getElementById('admin-category-form');
const adminCategoryList = document.getElementById('admin-category-list');
const adminCategoryCancel = document.getElementById('admin-category-cancel');
const adminPlayerForm = document.getElementById('admin-player-form');
const adminPlayerList = document.getElementById('admin-player-list');
const adminPlayerCancel = document.getElementById('admin-player-cancel');
const adminEnrollmentForm = document.getElementById('admin-enrollment-form');
const adminEnrollmentCategory = document.getElementById('admin-enrollment-category');
const adminEnrollmentPlayer = document.getElementById('admin-enrollment-player');
const adminEnrollmentList = document.getElementById('admin-enrollment-list');
const adminEnrollmentStatus = document.getElementById('admin-enrollment-status');
const adminMatchForm = document.getElementById('admin-match-form');
const adminMatchSelect = document.getElementById('admin-match-select');
const adminMatchCategory = document.getElementById('admin-match-category');
const adminMatchStatus = document.getElementById('admin-match-status-select');
const adminMatchPlayer1 = document.getElementById('admin-match-player1');
const adminMatchPlayer2 = document.getElementById('admin-match-player2');
const adminMatchScheduleContainer = document.getElementById('admin-match-schedule-container');
const adminMatchDay = document.getElementById('admin-match-day');
const adminMatchSchedulePickerContainer = document.getElementById('admin-match-slot-picker');
const adminMatchClearSlot = document.getElementById('admin-match-clear-slot');
const adminMatchDatetimeField = document.getElementById('admin-match-datetime-field');
const adminMatchDatetimeInput = document.getElementById('admin-match-datetime');
const adminMatchDate = document.getElementById('admin-match-date');
const adminMatchCourt = document.getElementById('admin-match-court');
const adminMatchNotes = document.getElementById('admin-match-notes');
const adminMatchCancel = document.getElementById('admin-match-cancel');
const adminMatchDelete = document.getElementById('admin-match-delete');
const adminMatchList = document.getElementById('admin-match-list');
const adminStatus = document.getElementById('admin-status');
const adminMatchStatusMessage = document.getElementById('admin-match-status-message');
const calendarContainer = document.getElementById('dashboard-calendar');
const calendarLabel = document.getElementById('calendar-label');
const calendarPrev = document.getElementById('calendar-prev');
const calendarNext = document.getElementById('calendar-next');
const globalCalendarContainer = document.getElementById('global-calendar');
const globalCalendarLabel = document.getElementById('global-calendar-label');
const globalCalendarPrev = document.getElementById('global-calendar-prev');
const globalCalendarNext = document.getElementById('global-calendar-next');
const globalCalendarViewButtons = document.querySelectorAll('[data-global-calendar-view]');
const leaguePlayersList = document.getElementById('league-players-list');
const leaguePlayersCount = document.getElementById('league-players-count');
const leaguePlayersLeagueSelect = document.getElementById('league-players-league');
const leaguePlayersCategorySelect = document.getElementById('league-players-category');
const leaguePlayersSearch = document.getElementById('league-players-search');
const leaguePlayersGender = document.getElementById('league-players-gender');
const leaguePlayersEmpty = document.getElementById('league-players-empty');
const leaguePaymentsGroups = document.getElementById('league-payments-groups');
const leaguePaymentsPendingList = document.getElementById('league-payments-pending');
const leaguePaymentsPendingEmpty = document.getElementById('league-payments-pending-empty');
const leaguePaymentsPendingCount = document.getElementById('league-payments-pending-count');
const leaguePaymentsPendingTotal = document.getElementById('league-payments-pending-total');
const leaguePaymentsPaidList = document.getElementById('league-payments-paid');
const leaguePaymentsPaidEmpty = document.getElementById('league-payments-paid-empty');
const leaguePaymentsPaidCount = document.getElementById('league-payments-paid-count');
const leaguePaymentsPaidTotal = document.getElementById('league-payments-paid-total');
const leaguePaymentsCount = document.getElementById('league-payments-count');
const leaguePaymentsLeagueSelect = document.getElementById('league-payments-league');
const leaguePaymentsSearchInput = document.getElementById('league-payments-search');
const leaguePaymentsEmpty = document.getElementById('league-payments-empty');
const leaguePaymentsFeeBadge = document.getElementById('league-payments-fee');
const leaguePaymentsStatusMessage = document.getElementById('league-payments-status');
const tournamentPaymentsGroups = document.getElementById('tournament-payments-groups');
const tournamentPaymentsPendingList = document.getElementById('tournament-payments-pending');
const tournamentPaymentsPendingEmpty = document.getElementById('tournament-payments-pending-empty');
const tournamentPaymentsPendingCount = document.getElementById('tournament-payments-pending-count');
const tournamentPaymentsPendingTotal = document.getElementById('tournament-payments-pending-total');
const tournamentPaymentsPaidList = document.getElementById('tournament-payments-paid');
const tournamentPaymentsPaidEmpty = document.getElementById('tournament-payments-paid-empty');
const tournamentPaymentsPaidCount = document.getElementById('tournament-payments-paid-count');
const tournamentPaymentsPaidTotal = document.getElementById('tournament-payments-paid-total');
const tournamentPaymentsCount = document.getElementById('tournament-payments-count');
const tournamentPaymentsTournamentSelect = document.getElementById('tournament-payments-tournament');
const tournamentPaymentsSearchInput = document.getElementById('tournament-payments-search');
const tournamentPaymentsEmpty = document.getElementById('tournament-payments-empty');
const tournamentPaymentsFeeBadge = document.getElementById('tournament-payments-fee');
const tournamentPaymentsStatusMessage = document.getElementById('tournament-payments-status');
const playerDirectoryList = document.getElementById('user-directory-list');
const playerDirectoryCount = document.getElementById('user-directory-count');
const playerDirectorySearch = document.getElementById('user-directory-search');
const playerDirectoryGender = document.getElementById('user-directory-gender');
const playerDirectoryRole = document.getElementById('user-directory-role');
const playerDirectoryCategory = document.getElementById('user-directory-category');
const playerDirectoryEmpty = document.getElementById('user-directory-empty');
const demoModeGenerateButton = document.getElementById('demo-mode-generate-button');
const demoModeStatus = document.getElementById('demo-mode-status');
const demoModeResults = document.getElementById('demo-mode-results');
const demoModeCreated = document.getElementById('demo-mode-created');
const demoModeSkipped = document.getElementById('demo-mode-skipped');
const demoModePassword = document.getElementById('demo-mode-password');
const categoryCreateButton = document.getElementById('category-create-button');
const leagueCreateButton = document.getElementById('league-create-button');
const leagueDetailCard = document.getElementById('league-detail-card');
const leagueDetailTitle = document.getElementById('league-detail-title');
const leagueDetailSubtitle = document.getElementById('league-detail-subtitle');
const leagueDetailBody = document.getElementById('league-detail-body');
const leagueEditButton = document.getElementById('league-edit-button');
const matchCreateButton = document.getElementById('match-create-button');
const matchGenerateButton = document.getElementById('match-generate-button');
const playerCreateButton = document.getElementById('player-create-button');
const tournamentCreateButton = document.getElementById('tournament-create-button');
const tournamentEditButton = document.getElementById('tournament-edit-button');
const tournamentCategoryCreateButton = document.getElementById(
  'tournament-category-create-button'
);
const tournamentEnrollmentAddButton = document.getElementById(
  'tournament-enrollment-add-button'
);
const tournamentDrawGenerateButton = document.getElementById('tournament-draw-generate-button');
const modalOverlay = document.getElementById('modal-overlay');
const modalTitle = document.getElementById('modal-title');
const modalBody = document.getElementById('modal-body');
const modalClose = document.getElementById('modal-close');

let activeModalCleanup = null;
let noticeDraftAttachments = [];
let adminMatchSchedulePicker = null;
let adminMatchClearSlotHandler = null;

if (adminMatchDatetimeInput) {
  adminMatchDatetimeInput.step = String(CALENDAR_TIME_SLOT_STEP_SECONDS);
  const handleAdminManualScheduleChange = () => {
    if (!getClubMatchScheduleTemplates().length) {
      syncAdminMatchScheduledValue();
    }
  };
  adminMatchDatetimeInput.addEventListener('change', handleAdminManualScheduleChange);
  adminMatchDatetimeInput.addEventListener('input', handleAdminManualScheduleChange);
}

updateAdminMatchScheduleVisibility();

function translateGender(value) {
  if (value === 'femenino') return 'Femenino';
  if (value === 'masculino') return 'Masculino';
  if (value === 'mixto') return 'Mixto';
  return value;
}

function formatTournamentMatchType(value) {
  if (!value) return '';
  return TOURNAMENT_MATCH_TYPE_LABELS[value] || value;
}

function formatTournamentMatchFormat(value) {
  if (!value) return '';
  return MATCH_FORMAT_LABELS[value] || value;
}

function translateSchedule(value) {
  return SCHEDULE_LABELS[value] || 'Sin preferencia';
}

function translateRole(role) {
  if (role === 'admin') return 'Administrador';
  if (role === 'player') return 'Jugador';
  if (role === 'court_manager') return 'Gestor de pistas';
  return role;
}

function formatSkillLevelLabel(value) {
  const option = CATEGORY_SKILL_LEVEL_OPTIONS.find((entry) => entry.value === value);
  return option ? option.label : value || '';
}

function formatRoles(roles) {
  const list = Array.isArray(roles)
    ? roles
    : typeof roles === 'string' && roles
    ? [roles]
    : [];
  if (!list.length) {
    return translateRole('player');
  }
  return list.map((role) => translateRole(role)).join(' · ');
}

function entityHasRole(entity, role) {
  if (!entity || !role) return false;
  const roles = Array.isArray(entity.roles)
    ? entity.roles
    : typeof entity.role === 'string'
    ? [entity.role]
    : [];
  return roles.includes(role);
}

function readFileAsDataUrl(file) {
  return new Promise((resolve, reject) => {
    const reader = new FileReader();
    reader.onload = () => resolve(reader.result);
    reader.onerror = () => reject(new Error('No se pudo leer la imagen seleccionada.'));
    reader.readAsDataURL(file);
  });
}

async function extractPhotoFromForm(form, fieldName = 'photo') {
  if (!form?.elements?.[fieldName]) return undefined;
  const input = form.elements[fieldName];
  const file = input.files?.[0];
  if (!file) return undefined;
  if (!file.type.startsWith('image/')) {
    throw new Error('La fotografía debe ser una imagen válida.');
  }
  if (file.size > MAX_PHOTO_SIZE) {
    throw new Error('La fotografía no puede superar los 2 MB.');
  }

  return readFileAsDataUrl(file);
}

function setStatusMessage(element, type, message) {
  if (!element) return;
  element.textContent = message || '';
  element.className = 'status-message';
  if (!message) {
    element.style.display = 'none';
    return;
  }
  if (type) {
    element.classList.add(type);
  }
  element.style.display = 'block';
}

function closeModal() {
  if (!modalOverlay || !modalBody) return;
  if (activeModalCleanup) {
    try {
      activeModalCleanup();
    } catch (error) {
      console.warn('Error al ejecutar la limpieza del modal', error);
    }
    activeModalCleanup = null;
  }
  modalOverlay.classList.remove('open');
  modalOverlay.hidden = true;
  modalBody.innerHTML = '';
  if (modalTitle) {
    modalTitle.textContent = '';
  }
}

function openModal({ title, content, onClose } = {}) {
  if (!modalOverlay || !modalBody) return;
  modalTitle.textContent = title || '';
  modalBody.innerHTML = '';
  if (typeof content === 'function') {
    content(modalBody);
  } else if (content instanceof Node) {
    modalBody.appendChild(content);
  }
  activeModalCleanup = typeof onClose === 'function' ? onClose : null;
  modalOverlay.hidden = false;
  requestAnimationFrame(() => {
    modalOverlay.classList.add('open');
  });
}

function openConfirmationDialog({
  title = 'Confirmación',
  message = '¿Seguro que deseas continuar?',
  confirmLabel = 'Aceptar',
  cancelLabel = 'Cancelar',
} = {}) {
  return new Promise((resolve) => {
    let settled = false;
    const settle = (value) => {
      if (settled) return;
      settled = true;
      resolve(Boolean(value));
    };

    const container = document.createElement('div');
    container.className = 'modal-confirm';

    const text = document.createElement('p');
    text.textContent = message;
    container.appendChild(text);

    const actions = document.createElement('div');
    actions.className = 'form-actions';

    const cancelButton = document.createElement('button');
    cancelButton.type = 'button';
    cancelButton.className = 'ghost';
    cancelButton.textContent = cancelLabel;
    cancelButton.addEventListener('click', () => {
      settle(false);
      closeModal();
    });

    const confirmButton = document.createElement('button');
    confirmButton.type = 'button';
    confirmButton.className = 'primary';
    confirmButton.textContent = confirmLabel;
    confirmButton.addEventListener('click', () => {
      settle(true);
      closeModal();
    });

    actions.appendChild(cancelButton);
    actions.appendChild(confirmButton);
    container.appendChild(actions);

    openModal({
      title,
      content: container,
      onClose: () => {
        settle(false);
      },
    });
  });
}

function showGlobalMessage(message = '', type = 'info') {
  globalMessage.textContent = message;
  globalMessage.classList.remove('show', 'error');
  if (!message) {
    return;
  }
  if (type === 'error') {
    globalMessage.classList.add('error');
  }
  globalMessage.classList.add('show');
}

function getCachedTournamentBracketMatches(tournamentId, categoryId) {
  if (!tournamentId || !categoryId) {
    return [];
  }

  if (!(state.tournamentBracketMatches instanceof Map)) {
    return [];
  }

  const cacheKey = getTournamentBracketCacheKey(tournamentId, categoryId);
  const cached = state.tournamentBracketMatches.get(cacheKey);
  return Array.isArray(cached) ? cached : [];
}

function bracketMatchesHaveRecordedResults(matches = []) {
  return matches.some((match) => {
    if (!match || typeof match !== 'object') {
      return false;
    }

    if (typeof match.resultStatus === 'string' && match.resultStatus !== 'sin_resultado') {
      return true;
    }

    if (match.status === 'completado') {
      return true;
    }

    if (match.result && match.result.winner) {
      return true;
    }

    return false;
  });
}

function updateLeagueActionAvailability() {
  if (leagueEditButton) {
    leagueEditButton.disabled = !state.selectedLeagueId;
  }
}

function updateTournamentActionAvailability() {
  if (tournamentEditButton) {
    tournamentEditButton.disabled = !state.selectedTournamentId;
  }

  if (tournamentAdminEnrollButton) {
    tournamentAdminEnrollButton.disabled = !state.selectedTournamentId;
  }

  const hasTournaments = Array.isArray(state.tournaments) && state.tournaments.length > 0;

  if (tournamentCategoryCreateButton) {
    tournamentCategoryCreateButton.disabled = !hasTournaments;
  }

  if (tournamentEnrollmentAddButton) {
    tournamentEnrollmentAddButton.disabled = !hasTournaments;
  }

  if (tournamentDrawGenerateButton) {
    tournamentDrawGenerateButton.disabled = !hasTournaments;
  }

  const hasBracketSelection =
    Boolean(state.selectedBracketTournamentId) && Boolean(state.selectedBracketCategoryId);

  const cachedMatches = hasBracketSelection
    ? getCachedTournamentBracketMatches(
        state.selectedBracketTournamentId,
        state.selectedBracketCategoryId
      )
    : [];

  if (tournamentBracketSaveSeedsButton) {
    tournamentBracketSaveSeedsButton.disabled =
      !isAdmin() || !hasBracketSelection || !state.tournamentBracketSeedsDirty;
  }

  if (tournamentBracketPreviewButton) {
    tournamentBracketPreviewButton.disabled = !isAdmin() || !hasBracketSelection;
  }

  if (tournamentBracketGenerateButton) {
    let disableGenerate = !isAdmin() || !hasBracketSelection;
    let tooltipMessage = '';

    if (!disableGenerate) {
      if (bracketMatchesHaveRecordedResults(cachedMatches)) {
        tooltipMessage = TOURNAMENT_BRACKET_RESULTS_REPLACEMENT_TOOLTIP;
      } else if (cachedMatches.length) {
        tooltipMessage = TOURNAMENT_BRACKET_REPLACEMENT_TOOLTIP;
      }
    }

    tournamentBracketGenerateButton.disabled = disableGenerate;
    if (tooltipMessage) {
      tournamentBracketGenerateButton.title = tooltipMessage;
    } else {
      tournamentBracketGenerateButton.removeAttribute('title');
    }
  }

  if (tournamentBracketRecalculateButton) {
    tournamentBracketRecalculateButton.disabled = !isAdmin() || !hasBracketSelection;
  }

  if (tournamentBracketClearButton) {
    tournamentBracketClearButton.disabled =
      !isAdmin() || !hasBracketSelection || cachedMatches.length === 0;
  }

  updateTournamentOrderOfPlayControls();
}

function getMatchDayKey(match) {
  if (!match || !match.scheduledAt) {
    return '';
  }

  const date = new Date(match.scheduledAt);
  if (Number.isNaN(date.getTime())) {
    return '';
  }

  const year = date.getFullYear();
  const month = String(date.getMonth() + 1).padStart(2, '0');
  const day = String(date.getDate()).padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function getTournamentOrderOfPlayDays(tournamentId) {
  if (!tournamentId) {
    return [];
  }

  if (!(state.tournamentOrderOfPlayDays instanceof Map)) {
    state.tournamentOrderOfPlayDays = new Map();
    return [];
  }

  const days = state.tournamentOrderOfPlayDays.get(tournamentId);
  if (!days) {
    return [];
  }

  return Array.from(days).sort();
}

function recomputeTournamentOrderOfPlayDays(tournamentId) {
  if (!(state.tournamentOrderOfPlayDays instanceof Map)) {
    state.tournamentOrderOfPlayDays = new Map();
  }

  const normalizedTournamentId = normalizeId(tournamentId);
  if (!normalizedTournamentId) {
    return;
  }

  const days = new Set();

  if (state.tournamentMatches instanceof Map) {
    const prefix = `${normalizedTournamentId}:`;
    state.tournamentMatches.forEach((matches, key) => {
      if (typeof key !== 'string' || !key.startsWith(prefix)) {
        return;
      }
      if (!Array.isArray(matches)) {
        return;
      }
      matches.forEach((match) => {
        const day = getMatchDayKey(match);
        if (day) {
          days.add(day);
        }
      });
    });
  }

  if (days.size > 0) {
    state.tournamentOrderOfPlayDays.set(normalizedTournamentId, days);
  } else {
    state.tournamentOrderOfPlayDays.delete(normalizedTournamentId);
  }

  if (state.selectedMatchTournamentId === normalizedTournamentId) {
    updateTournamentOrderOfPlayControls();
  }
}

function updateTournamentOrderOfPlayControls() {
  if (!tournamentOrderDayInput && !tournamentOrderDownloadButton) {
    return;
  }

  const tournamentId = state.selectedMatchTournamentId || '';
  const hasTournament = Boolean(tournamentId);
  const availableDays = hasTournament ? getTournamentOrderOfPlayDays(tournamentId) : [];

  if (hasTournament && availableDays.length > 0 && !state.selectedOrderOfPlayDay) {
    state.selectedOrderOfPlayDay = availableDays[0];
  }

  if (!hasTournament) {
    state.selectedOrderOfPlayDay = '';
  }

  if (tournamentOrderDayInput) {
    tournamentOrderDayInput.disabled = !hasTournament;
    if (hasTournament) {
      tournamentOrderDayInput.value = state.selectedOrderOfPlayDay || '';
    } else {
      tournamentOrderDayInput.value = '';
    }
  }

  if (tournamentOrderDownloadButton) {
    tournamentOrderDownloadButton.disabled =
      !hasTournament || !state.selectedOrderOfPlayDay;
  }
}

function updateMatchesMenuBadge(count = 0) {
  if (!matchesMenuBadge) return;
  matchesMenuBadge.textContent = String(count);
  matchesMenuBadge.hidden = count <= 0;
}

function updateNotificationsMenuBadge(count = 0) {
  if (!notificationsMenuBadge) return;
  notificationsMenuBadge.textContent = String(count);
  notificationsMenuBadge.hidden = count <= 0;
}

function updateNotificationCounts(value = 0) {
  let count = 0;
  if (Array.isArray(value)) {
    count = value.reduce((acc, entry) => {
      const weight = Number(entry?.countValue);
      if (Number.isFinite(weight) && weight > 0) {
        return acc + Math.trunc(weight);
      }
      return acc + 1;
    }, 0);
  } else {
    const parsed = Number(value);
    count = Number.isFinite(parsed) ? Math.max(0, Math.trunc(parsed)) : 0;
  }

  if (metricNotifications) {
    metricNotifications.textContent = String(count);
    metricNotifications.hidden = count <= 0;
  }
  updateNotificationsMenuBadge(count);
  return count;
}

function ensureRankingFilters() {
  if (!state.rankingFilters || typeof state.rankingFilters !== 'object') {
    state.rankingFilters = { league: '' };
  } else if (typeof state.rankingFilters.league !== 'string') {
    state.rankingFilters.league = String(state.rankingFilters.league || '');
  }
  return state.rankingFilters;
}

function ensureCategoryFilters() {
  if (!state.categoryFilters) {
    state.categoryFilters = { league: '' };
  } else if (typeof state.categoryFilters.league !== 'string') {
    state.categoryFilters.league = String(state.categoryFilters.league || '');
  }
  return state.categoryFilters;
}

function ensureLeaguePlayerFilters() {
  if (!state.leaguePlayersFilters) {
    state.leaguePlayersFilters = {
      league: '',
      category: '',
      search: '',
      gender: '',
    };
  }
  return state.leaguePlayersFilters;
}

function ensureLeaguePaymentFilters() {
  if (!state.leaguePaymentFilters) {
    state.leaguePaymentFilters = {
      league: '',
      search: '',
    };
  }
  return state.leaguePaymentFilters;
}

function ensureTournamentPaymentFilters() {
  if (!state.tournamentPaymentFilters) {
    state.tournamentPaymentFilters = {
      tournament: '',
      search: '',
    };
  }
  return state.tournamentPaymentFilters;
}

function tournamentHasEnrollmentFee(tournament) {
  if (!tournament) return false;
  const fees = Array.isArray(tournament.fees) ? tournament.fees : [];
  return fees.some((fee) => {
    const memberAmount = Number(fee?.memberAmount);
    const nonMemberAmount = Number(fee?.nonMemberAmount);
    const legacyAmount = Number(fee?.amount);
    return (
      (Number.isFinite(memberAmount) && memberAmount >= 0) ||
      (Number.isFinite(nonMemberAmount) && nonMemberAmount >= 0) ||
      (Number.isFinite(legacyAmount) && legacyAmount >= 0)
    );
  });
}

function getTournamentsWithEnrollmentFee() {
  return Array.isArray(state.tournaments)
    ? state.tournaments.filter((tournament) => tournamentHasEnrollmentFee(tournament))
    : [];
}

function compareTournamentsBySchedule(tournamentA, tournamentB) {
  const startA = Date.parse(tournamentA?.startDate);
  const startB = Date.parse(tournamentB?.startDate);
  const hasStartA = Number.isFinite(startA);
  const hasStartB = Number.isFinite(startB);
  if (hasStartA || hasStartB) {
    if (!hasStartA) return 1;
    if (!hasStartB) return -1;
    if (startA !== startB) {
      return startA - startB;
    }
  }

  const endA = Date.parse(tournamentA?.endDate);
  const endB = Date.parse(tournamentB?.endDate);
  const hasEndA = Number.isFinite(endA);
  const hasEndB = Number.isFinite(endB);
  if (hasEndA || hasEndB) {
    if (!hasEndA) return 1;
    if (!hasEndB) return -1;
    if (endA !== endB) {
      return endA - endB;
    }
  }

  const nameA = String(tournamentA?.name || '').toLocaleLowerCase('es');
  const nameB = String(tournamentB?.name || '').toLocaleLowerCase('es');
  return nameA.localeCompare(nameB, 'es');
}

function leagueHasEnrollmentFee(league) {
  if (!league) return false;
  const fee = Number(league.enrollmentFee);
  return Number.isFinite(fee) && fee > 0;
}

function getLeaguesWithEnrollmentFee() {
  return Array.isArray(state.leagues)
    ? state.leagues.filter((league) => leagueHasEnrollmentFee(league))
    : [];
}

function compareLeaguesByHistory(leagueA, leagueB) {
  const yearA = Number.parseInt(leagueA?.year, 10);
  const yearB = Number.parseInt(leagueB?.year, 10);
  const hasYearA = Number.isFinite(yearA);
  const hasYearB = Number.isFinite(yearB);
  if (hasYearA || hasYearB) {
    if (!hasYearA) return 1;
    if (!hasYearB) return -1;
    if (yearA !== yearB) {
      return yearA - yearB;
    }
  }

  const startA = Date.parse(leagueA?.startDate);
  const startB = Date.parse(leagueB?.startDate);
  const hasStartA = Number.isFinite(startA);
  const hasStartB = Number.isFinite(startB);
  if (hasStartA || hasStartB) {
    if (!hasStartA) return 1;
    if (!hasStartB) return -1;
    if (startA !== startB) {
      return startA - startB;
    }
  }

  const createdA = Date.parse(leagueA?.createdAt);
  const createdB = Date.parse(leagueB?.createdAt);
  const hasCreatedA = Number.isFinite(createdA);
  const hasCreatedB = Number.isFinite(createdB);
  if (hasCreatedA || hasCreatedB) {
    if (!hasCreatedA) return 1;
    if (!hasCreatedB) return -1;
    if (createdA !== createdB) {
      return createdA - createdB;
    }
  }

  return formatLeagueOptionLabel(leagueA).localeCompare(
    formatLeagueOptionLabel(leagueB),
    'es'
  );
}

function getLeagueById(leagueId) {
  const normalized = normalizeId(leagueId);
  if (!normalized) return null;
  if (!Array.isArray(state.leagues)) return null;
  return state.leagues.find((league) => normalizeId(league) === normalized) || null;
}

function getLeagueCategories(leagueId) {
  if (!leagueId) return [];
  const categories = Array.isArray(state.categories) ? state.categories : [];
  return categories.filter((category) => normalizeId(category?.league) === leagueId);
}

function getLeagueIdForCategory(categoryId) {
  if (!categoryId) return '';
  const category = Array.isArray(state.categories)
    ? state.categories.find((entry) => normalizeId(entry) === categoryId)
    : null;
  return category ? normalizeId(category.league) : '';
}

function invalidateLeaguePaymentsByCategory(categoryId) {
  const leagueId = getLeagueIdForCategory(categoryId);
  if (leagueId && state.leaguePayments instanceof Map) {
    state.leaguePayments.delete(leagueId);
  }
}

function pruneLeagueCaches() {
  const leagues = Array.isArray(state.leagues) ? state.leagues : [];
  const activeLeagueIds = new Set(
    leagues.map((league) => normalizeId(league)).filter((value) => Boolean(value))
  );

  if (state.leagueDetails instanceof Map) {
    Array.from(state.leagueDetails.keys()).forEach((leagueId) => {
      if (!activeLeagueIds.has(leagueId)) {
        state.leagueDetails.delete(leagueId);
      }
    });
  }

  if (state.leaguePayments instanceof Map) {
    Array.from(state.leaguePayments.keys()).forEach((leagueId) => {
      if (!activeLeagueIds.has(leagueId)) {
        state.leaguePayments.delete(leagueId);
      }
    });
  }

  const filters = ensureLeaguePaymentFilters();
  let filtersReset = false;
  if (filters.league && !activeLeagueIds.has(filters.league)) {
    filters.league = '';
    filters.search = '';
    filtersReset = true;
  }

  return { filtersReset };
}

function formatLeagueOptionLabel(league) {
  if (!league) return 'Liga';
  const name = league.name || 'Liga';
  const year = league.year ? ` · ${league.year}` : '';
  return `${name}${year}`;
}

function updateLeaguePlayersCategoryOptions() {
  if (!leaguePlayersCategorySelect) return [];
  const filters = ensureLeaguePlayerFilters();
  const leagueId = filters.league;
  const categories = getLeagueCategories(leagueId);
  const previousCategory = filters.category;
  const options = categories
    .slice()
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'));

  leaguePlayersCategorySelect.innerHTML = '<option value="">Todas las categorías</option>';
  const availableIds = new Set();

  options.forEach((category) => {
    const id = normalizeId(category);
    if (!id || availableIds.has(id)) {
      return;
    }
    availableIds.add(id);
    const option = document.createElement('option');
    option.value = id;
    option.textContent = `${category.name} (${translateGender(category.gender)})`;
    leaguePlayersCategorySelect.appendChild(option);
  });

  let nextCategory = '';
  if (previousCategory && availableIds.has(previousCategory)) {
    nextCategory = previousCategory;
  }
  filters.category = nextCategory;
  leaguePlayersCategorySelect.value = nextCategory;
  leaguePlayersCategorySelect.disabled = !options.length;
  return options;
}

function updateLeaguePlayersControls({ resetSelection = false } = {}) {
  if (!leaguePlayersLeagueSelect) return;

  const filters = ensureLeaguePlayerFilters();
  const categories = Array.isArray(state.categories) ? state.categories : [];
  const leagues = Array.isArray(state.leagues) ? state.leagues : [];
  const previousLeague = !resetSelection ? filters.league : '';

  const leaguesWithCategories = leagues.filter((league) => {
    const leagueId = normalizeId(league);
    return categories.some((category) => normalizeId(category.league) === leagueId);
  });

  const sortedLeagues = leaguesWithCategories
    .slice()
    .sort((a, b) => {
      const yearA = Number(a.year) || 0;
      const yearB = Number(b.year) || 0;
      if (yearA !== yearB) {
        return yearA - yearB;
      }
      if (a.status !== b.status) {
        return a.status === 'activa' ? -1 : 1;
      }
      return (a.name || '').localeCompare(b.name || '', 'es');
    });

  leaguePlayersLeagueSelect.innerHTML = '<option value="">Selecciona una liga</option>';
  const availableLeagueIds = new Set();

  sortedLeagues.forEach((league) => {
    const id = normalizeId(league);
    if (!id || availableLeagueIds.has(id)) {
      return;
    }
    availableLeagueIds.add(id);
    const option = document.createElement('option');
    option.value = id;
    option.textContent = formatLeagueOptionLabel(league);
    leaguePlayersLeagueSelect.appendChild(option);
  });

  let nextLeague = '';
  if (previousLeague && availableLeagueIds.has(previousLeague)) {
    nextLeague = previousLeague;
  } else if (availableLeagueIds.size) {
    const firstOption = leaguePlayersLeagueSelect.options[1];
    nextLeague = firstOption?.value || '';
  }

  filters.league = nextLeague;
  leaguePlayersLeagueSelect.value = nextLeague;
  leaguePlayersLeagueSelect.disabled = !availableLeagueIds.size;

  const leagueCategories = updateLeaguePlayersCategoryOptions();
  const hasActiveSelection = Boolean(nextLeague) && leagueCategories.length > 0;

  if (leaguePlayersSearch) {
    if (!hasActiveSelection) {
      leaguePlayersSearch.value = '';
    } else {
      leaguePlayersSearch.value = filters.search || '';
    }
    leaguePlayersSearch.disabled = !hasActiveSelection;
  }

  if (leaguePlayersGender) {
    if (!hasActiveSelection) {
      leaguePlayersGender.value = '';
    } else {
      leaguePlayersGender.value = filters.gender || '';
    }
    leaguePlayersGender.disabled = !hasActiveSelection;
  }

  if (!hasActiveSelection && leaguePlayersList) {
    leaguePlayersList.innerHTML = '';
  }

  if (!hasActiveSelection && leaguePlayersCount) {
    leaguePlayersCount.textContent = '0';
  }

  if (!hasActiveSelection && leaguePlayersEmpty) {
    leaguePlayersEmpty.hidden = false;
    leaguePlayersEmpty.textContent = availableLeagueIds.size
      ? 'Selecciona una liga para ver los jugadores inscritos.'
      : 'Aún no hay ligas con categorías registradas.';
  }
}

function updateLeaguePaymentFeeIndicator(feeValue) {
  if (!leaguePaymentsFeeBadge) return;

  let resolvedFee = feeValue;
  if (typeof resolvedFee === 'undefined') {
    const filters = ensureLeaguePaymentFilters();
    const league = resolveLeague(filters.league);
    const fee = league ? Number(league.enrollmentFee) : NaN;
    resolvedFee = Number.isFinite(fee) ? fee : null;
  }

  if (Number.isFinite(resolvedFee) && resolvedFee > 0) {
    const formatted = formatCurrencyValue(resolvedFee, DEFAULT_LEAGUE_CURRENCY);
    leaguePaymentsFeeBadge.textContent = formatted || `${resolvedFee.toFixed(2)} ${DEFAULT_LEAGUE_CURRENCY}`;
    leaguePaymentsFeeBadge.hidden = false;
  } else {
    leaguePaymentsFeeBadge.textContent = '';
    leaguePaymentsFeeBadge.hidden = true;
  }
}

function formatLeaguePaymentTotal(amount = 0) {
  const numericAmount = Number(amount);
  const safeAmount = Number.isFinite(numericAmount) ? numericAmount : 0;
  return (
    formatCurrencyValue(safeAmount, DEFAULT_LEAGUE_CURRENCY) ||
    `${safeAmount.toFixed(2)} ${DEFAULT_LEAGUE_CURRENCY}`
  );
}

function updateLeaguePaymentTotalElement(element, amount = 0) {
  if (!element) return;
  element.textContent = formatLeaguePaymentTotal(amount);
}

function calculateLeaguePaymentTotal(entries = []) {
  if (!Array.isArray(entries)) {
    return 0;
  }
  return entries.reduce((total, entry) => {
    const amount = Number(entry?.amount);
    return Number.isFinite(amount) ? total + amount : total;
  }, 0);
}

function updateTournamentPaymentFeeIndicator(feeInfo) {
  if (!tournamentPaymentsFeeBadge) return;

  const info = feeInfo || createEmptyTournamentFeeInfo();

  const formatEntry = (entry, fallbackLabel = '') => {
    if (!entry || !Number.isFinite(entry.amount)) {
      return '';
    }
    const entryCurrency = entry.currency || info.currency || DEFAULT_TOURNAMENT_CURRENCY;
    const formatted =
      formatCurrencyValue(entry.amount, entryCurrency) ||
      `${entry.amount.toFixed(2)} ${entryCurrency}`;
    const label = (entry.label || fallbackLabel || '').toString().trim();
    return label ? `${label}: ${formatted}` : formatted;
  };

  const parts = [];
  const memberText = formatEntry(info.member);
  if (memberText) {
    parts.push(memberText);
  }
  const nonMemberText = formatEntry(info.nonMember);
  if (nonMemberText) {
    parts.push(nonMemberText);
  }

  if (!parts.length) {
    const generalText = formatEntry(info.general, 'Cuota');
    if (generalText) {
      parts.push(generalText);
    }
  }

  if (parts.length) {
    tournamentPaymentsFeeBadge.textContent = `Cuota sugerida por categoría: ${parts.join(' · ')}`;
    tournamentPaymentsFeeBadge.hidden = false;
  } else {
    tournamentPaymentsFeeBadge.textContent = '';
    tournamentPaymentsFeeBadge.hidden = true;
  }
}

function formatTournamentPaymentTotal(amount = 0, currency = DEFAULT_TOURNAMENT_CURRENCY) {
  const numericAmount = Number(amount);
  const safeAmount = Number.isFinite(numericAmount) ? numericAmount : 0;
  const resolvedCurrency = currency || DEFAULT_TOURNAMENT_CURRENCY;
  return (
    formatCurrencyValue(safeAmount, resolvedCurrency) || `${safeAmount.toFixed(2)} ${resolvedCurrency}`
  );
}

function updateTournamentPaymentTotalElement(element, amount = 0, currency = DEFAULT_TOURNAMENT_CURRENCY) {
  if (!element) return;
  element.textContent = formatTournamentPaymentTotal(amount, currency);
}

function calculateTournamentPaymentTotal(entries = []) {
  if (!Array.isArray(entries)) {
    return 0;
  }
  return entries.reduce((total, entry) => {
    const amount = Number(entry?.amount);
    return Number.isFinite(amount) ? total + amount : total;
  }, 0);
}

function resetLeaguePaymentGroups() {
  if (leaguePaymentsPendingList) {
    leaguePaymentsPendingList.innerHTML = '';
  }
  if (leaguePaymentsPaidList) {
    leaguePaymentsPaidList.innerHTML = '';
  }
  if (leaguePaymentsPendingCount) {
    leaguePaymentsPendingCount.textContent = '0';
  }
  if (leaguePaymentsPaidCount) {
    leaguePaymentsPaidCount.textContent = '0';
  }
  updateLeaguePaymentTotalElement(leaguePaymentsPendingTotal, 0);
  updateLeaguePaymentTotalElement(leaguePaymentsPaidTotal, 0);
  if (leaguePaymentsPendingEmpty) {
    leaguePaymentsPendingEmpty.hidden = true;
  }
  if (leaguePaymentsPaidEmpty) {
    leaguePaymentsPaidEmpty.hidden = true;
  }
}

function resetTournamentPaymentGroups() {
  if (tournamentPaymentsPendingList) {
    tournamentPaymentsPendingList.innerHTML = '';
  }
  if (tournamentPaymentsPaidList) {
    tournamentPaymentsPaidList.innerHTML = '';
  }
  if (tournamentPaymentsPendingCount) {
    tournamentPaymentsPendingCount.textContent = '0';
  }
  if (tournamentPaymentsPaidCount) {
    tournamentPaymentsPaidCount.textContent = '0';
  }
  updateTournamentPaymentTotalElement(tournamentPaymentsPendingTotal, 0, DEFAULT_TOURNAMENT_CURRENCY);
  updateTournamentPaymentTotalElement(tournamentPaymentsPaidTotal, 0, DEFAULT_TOURNAMENT_CURRENCY);
  if (tournamentPaymentsPendingEmpty) {
    tournamentPaymentsPendingEmpty.hidden = true;
  }
  if (tournamentPaymentsPaidEmpty) {
    tournamentPaymentsPaidEmpty.hidden = true;
  }
}

function updateLeaguePaymentControls({ resetSelection = false } = {}) {
  if (!leaguePaymentsLeagueSelect) return;

  const filters = ensureLeaguePaymentFilters();
  const previousLeague = filters.league || '';
  const leaguesWithFee = getLeaguesWithEnrollmentFee();
  const sorted = leaguesWithFee
    .slice()
    .sort(compareLeaguesByHistory);

  const availableIds = new Set();
  leaguePaymentsLeagueSelect.innerHTML = '<option value="">Selecciona una liga con cuota</option>';

  sorted.forEach((league) => {
    const id = normalizeId(league);
    if (!id || availableIds.has(id)) {
      return;
    }
    availableIds.add(id);
    const option = document.createElement('option');
    option.value = id;
    option.textContent = formatLeagueOptionLabel(league);
    leaguePaymentsLeagueSelect.appendChild(option);
  });

  const preferredLeague = resetSelection ? '' : previousLeague;
  let nextLeague = preferredLeague && availableIds.has(preferredLeague) ? preferredLeague : '';
  if (!nextLeague && availableIds.size) {
    const firstOption = leaguePaymentsLeagueSelect.options[1];
    nextLeague = firstOption?.value || '';
  }

  const resolvedLeague = nextLeague || '';
  const selectionChanged = resolvedLeague !== previousLeague;
  const shouldResetFilters = resetSelection || selectionChanged || !resolvedLeague;

  filters.league = resolvedLeague;
  if (shouldResetFilters) {
    filters.search = '';
  }

  leaguePaymentsLeagueSelect.value = resolvedLeague;
  leaguePaymentsLeagueSelect.disabled = !availableIds.size;

  const hasSelection = Boolean(resolvedLeague);

  if (leaguePaymentsSearchInput) {
    if (!hasSelection || shouldResetFilters) {
      leaguePaymentsSearchInput.value = '';
    } else {
      leaguePaymentsSearchInput.value = filters.search || '';
    }
    leaguePaymentsSearchInput.disabled = !hasSelection;
  }

  if (!hasSelection) {
    resetLeaguePaymentGroups();
  }

  if (!hasSelection && leaguePaymentsCount) {
    leaguePaymentsCount.textContent = '0';
  }

  if (!hasSelection && leaguePaymentsEmpty) {
    leaguePaymentsEmpty.hidden = false;
    leaguePaymentsEmpty.textContent = availableIds.size
      ? 'Selecciona una liga con cuota para ver los pagos.'
      : 'Configura una liga con cuota de inscripción para gestionar pagos.';
  }

  if (hasSelection && leaguePaymentsEmpty) {
    leaguePaymentsEmpty.hidden = true;
  }

  updateLeaguePaymentFeeIndicator();
  updateLeaguePaymentMenuVisibility();

  if (selectionChanged && hasSelection && state.activeSection === 'section-league-payments') {
    refreshLeaguePayments().catch((error) => {
      console.warn('No se pudo actualizar el listado de pagos de liga', error);
    });
  }
}

function updateTournamentPaymentControls({ resetSelection = false } = {}) {
  if (!tournamentPaymentsTournamentSelect) return;

  const filters = ensureTournamentPaymentFilters();
  const previousTournament = resetSelection ? '' : filters.tournament || '';
  const tournamentsWithFee = getTournamentsWithEnrollmentFee();
  const sorted = tournamentsWithFee.slice().sort(compareTournamentsBySchedule);

  tournamentPaymentsTournamentSelect.innerHTML =
    '<option value="">Selecciona un torneo con cuotas</option>';

  const availableIds = new Set();
  sorted.forEach((tournament) => {
    const id = normalizeId(tournament);
    if (!id || availableIds.has(id)) {
      return;
    }
    availableIds.add(id);
    const option = document.createElement('option');
    option.value = id;
    option.textContent = tournament.name || 'Torneo';
    tournamentPaymentsTournamentSelect.appendChild(option);
  });

  let nextTournament = '';
  if (previousTournament && availableIds.has(previousTournament)) {
    nextTournament = previousTournament;
  } else if (availableIds.size) {
    const firstOption = tournamentPaymentsTournamentSelect.options[1];
    nextTournament = firstOption?.value || '';
  }

  const resolvedTournament = nextTournament || '';
  const selectionChanged = resolvedTournament !== previousTournament;

  filters.tournament = resolvedTournament;
  if (resetSelection || selectionChanged || !resolvedTournament) {
    filters.search = '';
  }

  tournamentPaymentsTournamentSelect.value = resolvedTournament;
  tournamentPaymentsTournamentSelect.disabled = !availableIds.size;

  const hasSelection = Boolean(resolvedTournament);

  updateTournamentPaymentMenuVisibility();

  if (tournamentPaymentsSearchInput) {
    tournamentPaymentsSearchInput.value = hasSelection ? filters.search || '' : '';
    tournamentPaymentsSearchInput.disabled = !hasSelection;
  }

  if (!hasSelection) {
    if (tournamentPaymentsCount) {
      tournamentPaymentsCount.textContent = '0';
    }
    resetTournamentPaymentGroups();
    if (tournamentPaymentsEmpty) {
      tournamentPaymentsEmpty.hidden = false;
      tournamentPaymentsEmpty.textContent = availableIds.size
        ? 'Selecciona un torneo con cuotas para gestionar los pagos.'
        : 'Configura cuotas de inscripción para habilitar el seguimiento de pagos.';
    }
    updateTournamentPaymentFeeIndicator(null);
    setStatusMessage(tournamentPaymentsStatusMessage, '', '');
    return;
  }

  if (tournamentPaymentsEmpty) {
    tournamentPaymentsEmpty.hidden = true;
  }

  refreshTournamentPayments({ force: resetSelection || selectionChanged });
}

let leaguePlayersRequestToken = 0;
let leaguePaymentsRequestToken = 0;
let tournamentPaymentsRequestToken = 0;

async function refreshLeaguePlayers({ force = false } = {}) {
  if (!leaguePlayersList) return;

  const filters = ensureLeaguePlayerFilters();
  const leagueId = filters.league;

  leaguePlayersList.innerHTML = '';

  if (leaguePlayersCount) {
    leaguePlayersCount.textContent = '0';
  }

  if (!leagueId) {
    if (leaguePlayersEmpty) {
      leaguePlayersEmpty.hidden = false;
      leaguePlayersEmpty.textContent = leaguePlayersLeagueSelect?.disabled
        ? 'Aún no hay ligas con categorías registradas.'
        : 'Selecciona una liga para ver los jugadores inscritos.';
    }
    return;
  }

  const categories = getLeagueCategories(leagueId);
  if (!categories.length) {
    if (leaguePlayersEmpty) {
      leaguePlayersEmpty.hidden = false;
      leaguePlayersEmpty.textContent = 'La liga seleccionada todavía no tiene categorías registradas.';
    }
    return;
  }

  const categoryFilter = filters.category;
  const targetCategories = categoryFilter
    ? categories.filter((category) => normalizeId(category) === categoryFilter)
    : categories;

  if (!targetCategories.length) {
    filters.category = '';
    return refreshLeaguePlayers({ force });
  }

  const categoryIds = targetCategories
    .map((category) => normalizeId(category))
    .filter(Boolean);

  if (!categoryIds.length) {
    if (leaguePlayersEmpty) {
      leaguePlayersEmpty.hidden = false;
      leaguePlayersEmpty.textContent = 'No hay categorías disponibles para la liga seleccionada.';
    }
    return;
  }

  const requestToken = ++leaguePlayersRequestToken;
  state.leaguePlayersLoading = true;

  if (leaguePlayersEmpty) {
    leaguePlayersEmpty.hidden = false;
    leaguePlayersEmpty.textContent = 'Cargando jugadores inscritos...';
  }

  try {
    await Promise.all(
      categoryIds.map((categoryId) => loadEnrollments(categoryId, { force }).catch((error) => {
        console.warn('No fue posible cargar las inscripciones de la categoría', categoryId, error);
        throw error;
      }))
    );
  } catch (error) {
    if (requestToken === leaguePlayersRequestToken) {
      leaguePlayersList.innerHTML = '';
      if (leaguePlayersEmpty) {
        leaguePlayersEmpty.hidden = false;
        leaguePlayersEmpty.textContent = 'No fue posible cargar los jugadores inscritos.';
      }
      if (leaguePlayersCount) {
        leaguePlayersCount.textContent = '0';
      }
    }
    state.leaguePlayersLoading = false;
    return;
  }

  if (requestToken !== leaguePlayersRequestToken) {
    state.leaguePlayersLoading = false;
    return;
  }

  const categoriesById = new Map();
  targetCategories.forEach((category) => {
    const id = normalizeId(category);
    if (id) {
      categoriesById.set(id, category);
    }
  });

  const playerMap = new Map();

  categoryIds.forEach((categoryId) => {
    const enrollments = state.enrollments.get(categoryId) || [];
    enrollments.forEach((enrollment) => {
      const player = enrollment?.user || {};
      const playerId = normalizeId(player);
      if (!playerId) return;

      if (!playerMap.has(playerId)) {
        playerMap.set(playerId, {
          player,
          categories: new Set(),
        });
      }
      playerMap.get(playerId).categories.add(categoryId);
    });
  });

  const searchTerm = (filters.search || '').toLowerCase();
  const genderFilter = filters.gender || '';

  const entries = Array.from(playerMap.values())
    .filter(({ player }) => {
      if (genderFilter && player.gender !== genderFilter) {
        return false;
      }
      if (searchTerm) {
        const haystack = `${player.fullName || ''} ${player.email || ''} ${player.phone || ''}`.toLowerCase();
        if (!haystack.includes(searchTerm)) {
          return false;
        }
      }
      return true;
    })
    .sort((a, b) => {
      const nameA = (a.player.fullName || '').toLocaleLowerCase('es');
      const nameB = (b.player.fullName || '').toLocaleLowerCase('es');
      return nameA.localeCompare(nameB, 'es');
    });

  if (leaguePlayersCount) {
    leaguePlayersCount.textContent = String(entries.length);
  }

  if (!entries.length) {
    leaguePlayersList.innerHTML = '';
    if (leaguePlayersEmpty) {
      leaguePlayersEmpty.hidden = false;
      leaguePlayersEmpty.textContent =
        filters.search || filters.gender
          ? 'Aún no hay jugadores inscritos que coincidan con el filtro seleccionado.'
          : 'Aún no hay jugadores inscritos en la selección actual.';
    }
    state.leaguePlayersLoading = false;
    return;
  }

  if (leaguePlayersEmpty) {
    leaguePlayersEmpty.hidden = true;
  }

  leaguePlayersList.innerHTML = '';

  entries.forEach(({ player, categories: playerCategories }) => {
    const item = document.createElement('li');
    item.appendChild(buildPlayerCell(player, { includeSchedule: true }));

    const contact = document.createElement('div');
    contact.className = 'meta';
    if (player.email) {
      contact.appendChild(document.createElement('span')).textContent = player.email;
    }
    if (player.phone) {
      contact.appendChild(document.createElement('span')).textContent = player.phone;
    }
    if (contact.childNodes.length) {
      item.appendChild(contact);
    }

    const details = document.createElement('div');
    details.className = 'meta';
    const genderLabel = translateGender(player.gender) || 'Sin definir';
    details.appendChild(document.createElement('span')).textContent = `Género: ${genderLabel}`;

    const categoryNames = Array.from(playerCategories)
      .map((categoryId) => categoriesById.get(categoryId)?.name)
      .filter(Boolean)
      .sort((a, b) => a.localeCompare(b, 'es'));

    details.appendChild(document.createElement('span')).textContent = `Categorías: ${
      categoryNames.length ? categoryNames.join(', ') : 'Sin asignar'
    }`;

    item.appendChild(details);

    leaguePlayersList.appendChild(item);
  });

  state.leaguePlayersLoading = false;
}

async function fetchLeagueDetail(leagueId, { force = false } = {}) {
  const normalized = normalizeId(leagueId);
  if (!normalized) {
    return null;
  }

  if (!force && state.leagueDetails instanceof Map && state.leagueDetails.has(normalized)) {
    return state.leagueDetails.get(normalized);
  }

  try {
    const response = await request(`/leagues/${normalized}`);
    const detail = response?.league || null;
    if (!(state.leagueDetails instanceof Map)) {
      state.leagueDetails = new Map();
    }
    if (detail) {
      state.leagueDetails.set(normalized, detail);
    } else {
      state.leagueDetails.delete(normalized);
    }
    return detail;
  } catch (error) {
    if (state.leagueDetails instanceof Map) {
      state.leagueDetails.delete(normalized);
    }
    throw error;
  }
}

async function getLeaguePaymentData(leagueId, { force = false } = {}) {
  const normalized = normalizeId(leagueId);
  if (!normalized) {
    return { entries: [], fee: null };
  }

  if (!force && state.leaguePayments instanceof Map && state.leaguePayments.has(normalized)) {
    return state.leaguePayments.get(normalized);
  }

  const detail = await fetchLeagueDetail(normalized, { force });
  if (!detail) {
    if (state.leaguePayments instanceof Map) {
      state.leaguePayments.delete(normalized);
    }
    return { entries: [], fee: null };
  }

  const categories = getLeagueCategories(normalized);
  const categoryIds = categories.map((category) => normalizeId(category)).filter(Boolean);

  if (categoryIds.length) {
    await Promise.all(categoryIds.map((categoryId) => loadEnrollments(categoryId, { force })));
  }

  const categoriesById = new Map();
  categories.forEach((category) => {
    const id = normalizeId(category);
    if (id) {
      categoriesById.set(id, category);
    }
  });

  const payments = Array.isArray(detail.payments) ? detail.payments : [];
  const paymentByUser = new Map();
  payments.forEach((payment) => {
    const userId = normalizeId(payment?.user);
    if (!userId) return;
    paymentByUser.set(userId, payment);
  });

  const playerMap = new Map();
  categoryIds.forEach((categoryId) => {
    const enrollments = state.enrollments.get(categoryId) || [];
    enrollments.forEach((enrollment) => {
      const player = enrollment?.user || {};
      const playerId = normalizeId(player);
      if (!playerId) return;
      if (!playerMap.has(playerId)) {
        playerMap.set(playerId, {
          player,
          categories: new Set(),
        });
      }
      playerMap.get(playerId).categories.add(categoryId);
    });
  });

  const feeValue = Number(detail.enrollmentFee);
  const normalizedFee = Number.isFinite(feeValue) && feeValue > 0 ? feeValue : null;

  const createEntry = ({ player, playerId, categories: playerCategories, payment, hasEnrollment }) => {
    const normalizedPlayer = player && typeof player === 'object' ? player : {};
    const amountValue = Number(payment?.amount);
    const resolvedAmount = Number.isFinite(amountValue) && amountValue >= 0
      ? amountValue
      : normalizedFee;

    return {
      player: normalizedPlayer,
      playerId,
      categories: playerCategories,
      paymentRecord: payment || null,
      paymentId: payment ? normalizeId(payment) : '',
      status: payment?.status && PAYMENT_STATUS_LABELS[payment.status] ? payment.status : 'pendiente',
      amount: typeof resolvedAmount === 'number' ? resolvedAmount : null,
      method: payment?.method || '',
      reference: payment?.reference || '',
      notes: payment?.notes || '',
      paidAt: payment?.paidAt || null,
      recordedBy: payment?.recordedBy || null,
      updatedAt: payment?.updatedAt || payment?.createdAt || null,
      hasEnrollment,
    };
  };

  const entries = [];

  playerMap.forEach(({ player, categories: playerCategories }, playerId) => {
    const payment = paymentByUser.get(playerId) || null;
    if (payment) {
      paymentByUser.delete(playerId);
    }
    const categoriesForPlayer = Array.from(playerCategories)
      .map((categoryId) => categoriesById.get(categoryId))
      .filter(Boolean);

    entries.push(
      createEntry({
        player,
        playerId,
        categories: categoriesForPlayer,
        payment,
        hasEnrollment: true,
      })
    );
  });

  paymentByUser.forEach((payment, userId) => {
    const player = typeof payment?.user === 'object' ? payment.user : {};
    entries.push(
      createEntry({
        player,
        playerId: userId,
        categories: [],
        payment,
        hasEnrollment: false,
      })
    );
  });

  entries.sort((a, b) => {
    const statusWeightA = PAYMENT_STATUS_ORDER[a.status] ?? 99;
    const statusWeightB = PAYMENT_STATUS_ORDER[b.status] ?? 99;
    if (statusWeightA !== statusWeightB) {
      return statusWeightA - statusWeightB;
    }
    const nameA = (a.player.fullName || a.player.email || '').toLocaleLowerCase('es');
    const nameB = (b.player.fullName || b.player.email || '').toLocaleLowerCase('es');
    if (nameA && nameB) {
      return nameA.localeCompare(nameB, 'es');
    }
    if (nameA) return -1;
    if (nameB) return 1;
    return 0;
  });

  const result = {
    entries,
    fee: normalizedFee,
  };

  if (!(state.leaguePayments instanceof Map)) {
    state.leaguePayments = new Map();
  }
  state.leaguePayments.set(normalized, result);

  return result;
}

function createEmptyTournamentFeeInfo() {
  return {
    currency: DEFAULT_TOURNAMENT_CURRENCY,
    member: null,
    nonMember: null,
    general: null,
    memberTiers: {},
    nonMemberTiers: {},
    generalTiers: {},
  };
}

function resolveTournamentFeeInfo(detail) {
  const fees = Array.isArray(detail?.fees) ? detail.fees : [];

  const info = createEmptyTournamentFeeInfo();

  const normalizeCurrency = (value) => {
    if (!value) return '';
    const trimmed = value.toString().trim();
    return trimmed ? trimmed.toUpperCase() : '';
  };

  const parseCategoryCount = (label) => {
    if (!label) return null;
    const match = label.match(/(\d+)/);
    if (!match) {
      return null;
    }
    const count = Number(match[1]);
    return Number.isFinite(count) && count > 0 ? count : null;
  };

  let resolvedCurrency = '';

  fees.forEach((fee) => {
    const baseLabel = fee?.label ? fee.label.toString().trim() : '';
    const categoryCount = parseCategoryCount(baseLabel);
    const rawCurrency = normalizeCurrency(fee?.currency);

    if (rawCurrency) {
      resolvedCurrency = rawCurrency;
    }

    const entryCurrency = rawCurrency || resolvedCurrency || DEFAULT_TOURNAMENT_CURRENCY;

    const registerEntry = (type, amount, suffix) => {
      if (!Number.isFinite(amount) || amount < 0) {
        return;
      }

      const buildLabel = () => {
        const trimmedSuffix = (suffix || '').toString().trim();
        if (baseLabel && trimmedSuffix) {
          return `${baseLabel} · ${trimmedSuffix}`;
        }
        if (baseLabel) {
          return baseLabel;
        }
        return trimmedSuffix;
      };

      const entry = {
        amount,
        currency: entryCurrency,
        label: buildLabel(),
        categoryCount: categoryCount,
      };

      if (!info[type]) {
        info[type] = entry;
      }

      if (categoryCount) {
        const tierKey = `${type}Tiers`;
        const tierId = String(categoryCount);
        info[tierKey][tierId] = entry;
      }
    };

    registerEntry('member', Number(fee?.memberAmount), 'Socios');
    registerEntry('nonMember', Number(fee?.nonMemberAmount), 'No socios');
    registerEntry('general', Number(fee?.amount), '');
  });

  const fallbackCurrency =
    resolvedCurrency ||
    info.member?.currency ||
    info.nonMember?.currency ||
    info.general?.currency ||
    DEFAULT_TOURNAMENT_CURRENCY;

  info.currency = fallbackCurrency;

  ['member', 'nonMember', 'general'].forEach((key) => {
    if (info[key] && !info[key].currency) {
      info[key].currency = fallbackCurrency;
    }
  });

  return info;
}

async function getTournamentPaymentData(tournamentId, { force = false } = {}) {
  const normalized = normalizeId(tournamentId);
  if (!normalized) {
    return {
      entries: [],
      feeInfo: createEmptyTournamentFeeInfo(),
      currency: DEFAULT_TOURNAMENT_CURRENCY,
    };
  }

  if (!force && state.tournamentPayments instanceof Map && state.tournamentPayments.has(normalized)) {
    return state.tournamentPayments.get(normalized);
  }

  if (force && state.tournamentPayments instanceof Map) {
    state.tournamentPayments.delete(normalized);
  }

  if (force && state.tournamentDetails instanceof Map && state.tournamentDetails.has(normalized)) {
    state.tournamentDetails.delete(normalized);
  }

  const detail = await loadTournamentDetail(normalized);
  if (!detail) {
    if (state.tournamentPayments instanceof Map) {
      state.tournamentPayments.delete(normalized);
    }
    return {
      entries: [],
      feeInfo: createEmptyTournamentFeeInfo(),
      currency: DEFAULT_TOURNAMENT_CURRENCY,
    };
  }

  const categories = getTournamentCategories(normalized);
  const categoryIds = categories.map((category) => normalizeId(category)).filter(Boolean);

  const categoriesById = new Map();
  categories.forEach((category) => {
    const id = normalizeId(category);
    if (id) {
      categoriesById.set(id, category);
    }
  });

  const enrollmentMap = new Map();
  await Promise.all(
    categoryIds.map(async (categoryId) => {
      try {
        const enrollments = await fetchTournamentEnrollments(normalized, categoryId, { forceReload: force });
        enrollmentMap.set(categoryId, Array.isArray(enrollments) ? enrollments : []);
      } catch (error) {
        const cacheKey = `${normalized}:${categoryId}`;
        const cached = state.tournamentEnrollments.get(cacheKey) || [];
        enrollmentMap.set(categoryId, cached);
      }
    })
  );

  const payments = Array.isArray(detail.payments) ? detail.payments : [];
  const paymentByUser = new Map();
  payments.forEach((payment) => {
    const userId = normalizeId(payment?.user);
    if (!userId) return;
    paymentByUser.set(userId, payment);
  });

  const playerMap = new Map();
  enrollmentMap.forEach((enrollments, categoryId) => {
    enrollments.forEach((enrollment) => {
      const player = enrollment?.user || {};
      const playerId = normalizeId(player);
      if (!playerId) return;
      if (!playerMap.has(playerId)) {
        playerMap.set(playerId, {
          player,
          categories: new Set(),
        });
      }
      playerMap.get(playerId).categories.add(categoryId);
    });
  });

  const feeInfo = resolveTournamentFeeInfo(detail);
  const baseCurrency =
    feeInfo.currency ||
    feeInfo.member?.currency ||
    feeInfo.nonMember?.currency ||
    feeInfo.general?.currency ||
    DEFAULT_TOURNAMENT_CURRENCY;

  const computeSuggestedAmount = (player, playerCategories = []) => {
    const categoryCount = Array.isArray(playerCategories) ? playerCategories.length : 0;
    if (categoryCount <= 0) {
      return null;
    }

    const isMember = Boolean(player?.isMember);
    const getTierEntry = (entry, tiers, count) => {
      if (!count || !tiers) {
        return entry;
      }
      const tierEntry = tiers[String(count)] || tiers[count];
      if (Number.isFinite(tierEntry?.amount) && tierEntry.amount >= 0) {
        return tierEntry;
      }
      return entry;
    };

    const memberEntry = getTierEntry(feeInfo.member, feeInfo.memberTiers, categoryCount);
    const nonMemberEntry = getTierEntry(feeInfo.nonMember, feeInfo.nonMemberTiers, categoryCount);
    const generalEntry = getTierEntry(feeInfo.general, feeInfo.generalTiers, categoryCount);

    const options = [];

    if (isMember) {
      if (memberEntry) options.push(memberEntry);
      if (generalEntry) options.push(generalEntry);
      if (nonMemberEntry) options.push(nonMemberEntry);
    } else {
      if (nonMemberEntry) options.push(nonMemberEntry);
      if (generalEntry) options.push(generalEntry);
      if (memberEntry) options.push(memberEntry);
    }

    const baseEntry = options.find((entry) => Number.isFinite(entry?.amount) && entry.amount >= 0);

    if (!baseEntry) {
      return null;
    }

    const baseCategoryCount = Number(baseEntry?.categoryCount);
    let amount;

    if (Number.isFinite(baseCategoryCount) && baseCategoryCount > 0) {
      if (baseCategoryCount === categoryCount) {
        amount = baseEntry.amount;
      } else if (baseCategoryCount === 1) {
        amount = baseEntry.amount * categoryCount;
      } else {
        const perCategory = baseEntry.amount / baseCategoryCount;
        amount = perCategory * categoryCount;
      }
    } else {
      amount = baseEntry.amount * categoryCount;
    }

    const suggestionCurrency = baseEntry.currency || baseCurrency;

    return {
      amount,
      currency: suggestionCurrency,
      baseAmount: baseEntry.amount,
      baseLabel: baseEntry.label || '',
      baseCategoryCount: Number.isFinite(baseCategoryCount) && baseCategoryCount > 0 ? baseCategoryCount : null,
      categoryCount,
      isMember,
    };
  };

  const createEntry = ({ player, playerId, categories: playerCategories, payment, hasEnrollment }) => {
    const normalizedPlayer = player && typeof player === 'object' ? player : {};
    const categoriesForPlayer = Array.isArray(playerCategories) ? playerCategories : [];
    const suggestion = computeSuggestedAmount(normalizedPlayer, categoriesForPlayer);
    const amountValue = Number(payment?.amount);
    const recordedAmount = Number.isFinite(amountValue) && amountValue >= 0 ? amountValue : null;
    const suggestionAmount = suggestion?.amount;
    const resolvedAmount =
      recordedAmount !== null
        ? recordedAmount
        : Number.isFinite(suggestionAmount)
        ? suggestionAmount
        : null;
    const entryCurrency =
      (recordedAmount !== null ? baseCurrency : suggestion?.currency) || baseCurrency;

    return {
      player: normalizedPlayer,
      playerId,
      categories: categoriesForPlayer,
      paymentRecord: payment || null,
      paymentId: payment ? normalizeId(payment) : '',
      status: payment?.status && PAYMENT_STATUS_LABELS[payment.status] ? payment.status : 'pendiente',
      amount: typeof resolvedAmount === 'number' ? resolvedAmount : null,
      recordedAmount,
      suggestedAmount: Number.isFinite(suggestionAmount) ? suggestionAmount : null,
      suggestion,
      amountSource: recordedAmount !== null ? 'recorded' : suggestion ? 'suggested' : 'none',
      method: payment?.method || '',
      reference: payment?.reference || '',
      notes: payment?.notes || '',
      paidAt: payment?.paidAt || null,
      recordedBy: payment?.recordedBy || null,
      updatedAt: payment?.updatedAt || payment?.createdAt || null,
      hasEnrollment,
      currency: entryCurrency,
    };
  };

  const entries = [];

  playerMap.forEach(({ player, categories: playerCategories }, playerId) => {
    const payment = paymentByUser.get(playerId) || null;
    if (payment) {
      paymentByUser.delete(playerId);
    }

    const categoriesForPlayer = Array.from(playerCategories)
      .map((categoryId) => categoriesById.get(categoryId))
      .filter(Boolean);

    entries.push(
      createEntry({
        player,
        playerId,
        categories: categoriesForPlayer,
        payment,
        hasEnrollment: true,
      })
    );
  });

  paymentByUser.forEach((payment, userId) => {
    const player = typeof payment?.user === 'object' ? payment.user : {};
    entries.push(
      createEntry({
        player,
        playerId: userId,
        categories: [],
        payment,
        hasEnrollment: false,
      })
    );
  });

  entries.sort((a, b) => {
    const statusWeightA = PAYMENT_STATUS_ORDER[a.status] ?? 99;
    const statusWeightB = PAYMENT_STATUS_ORDER[b.status] ?? 99;
    if (statusWeightA !== statusWeightB) {
      return statusWeightA - statusWeightB;
    }
    const nameA = (a.player.fullName || a.player.email || '').toLocaleLowerCase('es');
    const nameB = (b.player.fullName || b.player.email || '').toLocaleLowerCase('es');
    if (nameA && nameB) {
      return nameA.localeCompare(nameB, 'es');
    }
    if (nameA) return -1;
    if (nameB) return 1;
    return 0;
  });

  feeInfo.currency = baseCurrency;

  const result = {
    entries,
    feeInfo,
    currency: baseCurrency,
  };

  if (!(state.tournamentPayments instanceof Map)) {
    state.tournamentPayments = new Map();
  }
  state.tournamentPayments.set(normalized, result);

  return result;
}

function createLeaguePaymentItem(entry, { fee = null } = {}) {
  const listItem = document.createElement('li');
  listItem.className = 'league-payment-entry';

  const item = document.createElement('details');
  item.className = 'league-payment-item';
  const statusValue = entry.status || 'pendiente';
  item.dataset.paymentStatus = statusValue;
  if (statusValue !== 'pagado') {
    item.open = true;
  }

  const summary = document.createElement('summary');

  const header = document.createElement('div');
  header.className = 'league-payment-header';

  const playerCell = buildPlayerCell(entry.player || {}, { includeSchedule: false, size: 'sm' });
  header.appendChild(playerCell);
  summary.appendChild(header);

  const headerMeta = document.createElement('div');
  headerMeta.className = 'league-payment-header-meta';

  const statusBadge = document.createElement('span');
  statusBadge.className = `tag payment-status payment-status--${statusValue}`;
  statusBadge.textContent = PAYMENT_STATUS_LABELS[statusValue] || statusValue || 'Pendiente';
  headerMeta.appendChild(statusBadge);

  if (Number.isFinite(entry.amount)) {
    const amountSpan = document.createElement('span');
    amountSpan.className = 'league-payment-amount';
    amountSpan.textContent =
      formatCurrencyValue(entry.amount, DEFAULT_LEAGUE_CURRENCY) ||
      `${entry.amount.toFixed(2)} ${DEFAULT_LEAGUE_CURRENCY}`;
    headerMeta.appendChild(amountSpan);
  }

  if (entry.paidAt) {
    const paidAtSpan = document.createElement('span');
    paidAtSpan.textContent = `Pago: ${formatShortDate(entry.paidAt)}`;
    headerMeta.appendChild(paidAtSpan);
  }

  if (!entry.hasEnrollment) {
    const noteSpan = document.createElement('span');
    noteSpan.textContent = 'Sin inscripción activa';
    headerMeta.appendChild(noteSpan);
  }

  summary.appendChild(headerMeta);
  item.appendChild(summary);

  const body = document.createElement('div');
  body.className = 'league-payment-body';

  const categoryNames = Array.isArray(entry.categories)
    ? entry.categories.map((category) => category?.name || '').filter(Boolean)
    : [];
  const categoriesMeta = document.createElement('div');
  categoriesMeta.className = 'league-payment-meta';
  categoriesMeta.textContent = categoryNames.length
    ? `Categorías: ${categoryNames.join(', ')}`
    : 'Categorías: Sin asignar';
  body.appendChild(categoriesMeta);

  if (entry.player?.email || entry.player?.phone) {
    const contactMeta = document.createElement('div');
    contactMeta.className = 'league-payment-meta';
    if (entry.player.email) {
      contactMeta.appendChild(document.createElement('span')).textContent = entry.player.email;
    }
    if (entry.player.phone) {
      contactMeta.appendChild(document.createElement('span')).textContent = entry.player.phone;
    }
    body.appendChild(contactMeta);
  }

  if (entry.reference) {
    const referenceMeta = document.createElement('div');
    referenceMeta.className = 'league-payment-meta';
    referenceMeta.textContent = `Referencia: ${entry.reference}`;
    body.appendChild(referenceMeta);
  }

  if (entry.recordedBy?.fullName) {
    const recordedMeta = document.createElement('div');
    recordedMeta.className = 'league-payment-meta';
    recordedMeta.textContent = `Actualizado por ${entry.recordedBy.fullName}`;
    body.appendChild(recordedMeta);
  }

  const form = document.createElement('form');
  form.className = 'league-payment-form';
  form.dataset.leaguePaymentForm = 'true';
  if (entry.playerId) {
    form.dataset.userId = entry.playerId;
  }
  if (entry.paymentId) {
    form.dataset.paymentId = entry.paymentId;
  }

  const statusRow = document.createElement('div');
  statusRow.className = 'form-row';

  const statusLabel = document.createElement('label');
  statusLabel.textContent = 'Estado';
  const statusSelect = document.createElement('select');
  statusSelect.name = 'status';
  Object.entries(PAYMENT_STATUS_LABELS).forEach(([value, label]) => {
    const option = document.createElement('option');
    option.value = value;
    option.textContent = label;
    if (value === statusValue) {
      option.selected = true;
    }
    statusSelect.appendChild(option);
  });
  statusLabel.appendChild(statusSelect);
  statusRow.appendChild(statusLabel);

  const amountLabel = document.createElement('label');
  amountLabel.textContent = 'Importe';
  const amountInput = document.createElement('input');
  amountInput.type = 'number';
  amountInput.name = 'amount';
  amountInput.min = '0';
  amountInput.step = '0.01';
  if (Number.isFinite(entry.amount)) {
    amountInput.value = entry.amount.toFixed(2);
  } else if (Number.isFinite(fee) && fee > 0) {
    const formattedFee =
      formatCurrencyValue(fee, DEFAULT_LEAGUE_CURRENCY) || `${fee.toFixed(2)} ${DEFAULT_LEAGUE_CURRENCY}`;
    amountInput.placeholder = formattedFee;
  }
  amountLabel.appendChild(amountInput);
  statusRow.appendChild(amountLabel);
  form.appendChild(statusRow);

  const detailsRow = document.createElement('div');
  detailsRow.className = 'form-row';

  const methodLabel = document.createElement('label');
  methodLabel.textContent = 'Método';
  const methodSelect = document.createElement('select');
  methodSelect.name = 'method';
  const methodValue = (entry.method || '').toString().trim();
  const methodValueLower = methodValue.toLowerCase();
  const placeholderOption = document.createElement('option');
  placeholderOption.value = '';
  placeholderOption.textContent = 'Sin especificar';
  if (!methodValue) {
    placeholderOption.selected = true;
  }
  methodSelect.appendChild(placeholderOption);

  let matchedMethod = false;
  LEAGUE_PAYMENT_METHOD_OPTIONS.forEach((label) => {
    const option = document.createElement('option');
    option.value = label;
    option.textContent = label;
    if (methodValueLower && methodValueLower === label.toLowerCase()) {
      option.selected = true;
      matchedMethod = true;
    }
    methodSelect.appendChild(option);
  });

  if (!matchedMethod && methodValue) {
    const customOption = document.createElement('option');
    customOption.value = methodValue;
    customOption.textContent = methodValue;
    customOption.selected = true;
    methodSelect.appendChild(customOption);
  }

  methodLabel.appendChild(methodSelect);
  detailsRow.appendChild(methodLabel);

  const referenceLabel = document.createElement('label');
  referenceLabel.textContent = 'Referencia';
  const referenceInput = document.createElement('input');
  referenceInput.type = 'text';
  referenceInput.name = 'reference';
  referenceInput.placeholder = 'Identificador o concepto';
  referenceInput.value = entry.reference || '';
  referenceLabel.appendChild(referenceInput);
  detailsRow.appendChild(referenceLabel);
  form.appendChild(detailsRow);

  const notesRow = document.createElement('div');
  notesRow.className = 'form-row';

  const paidAtLabel = document.createElement('label');
  paidAtLabel.textContent = 'Fecha de pago';
  const paidAtInput = document.createElement('input');
  paidAtInput.type = 'date';
  paidAtInput.name = 'paidAt';
  paidAtInput.value = entry.paidAt ? formatDateInput(entry.paidAt) : '';
  paidAtLabel.appendChild(paidAtInput);
  notesRow.appendChild(paidAtLabel);

  const notesLabel = document.createElement('label');
  notesLabel.textContent = 'Notas';
  const notesInput = document.createElement('input');
  notesInput.type = 'text';
  notesInput.name = 'notes';
  notesInput.placeholder = 'Añade una nota interna';
  notesInput.value = entry.notes || '';
  notesLabel.appendChild(notesInput);
  notesRow.appendChild(notesLabel);
  form.appendChild(notesRow);

  const actionsRow = document.createElement('div');
  actionsRow.className = 'form-actions';
  const submitButton = document.createElement('button');
  submitButton.type = 'submit';
  submitButton.className = 'primary';
  submitButton.textContent = entry.paymentId ? 'Actualizar pago' : 'Registrar pago';
  actionsRow.appendChild(submitButton);
  form.appendChild(actionsRow);

  body.appendChild(form);
  item.appendChild(body);

  listItem.appendChild(item);

  return listItem;
}

function createTournamentPaymentItem(entry, { feeInfo = null } = {}) {
  const listItem = document.createElement('li');
  listItem.className = 'tournament-payment-entry';

  const item = document.createElement('details');
  item.className = 'tournament-payment-item';
  const statusValue = entry.status || 'pendiente';
  item.dataset.paymentStatus = statusValue;
  if (statusValue !== 'pagado') {
    item.open = true;
  }

  const summary = document.createElement('summary');

  const header = document.createElement('div');
  header.className = 'tournament-payment-header';
  const playerCell = buildPlayerCell(entry.player || {}, { includeSchedule: false, size: 'sm' });
  header.appendChild(playerCell);
  summary.appendChild(header);

  const headerMeta = document.createElement('div');
  headerMeta.className = 'tournament-payment-header-meta';

  const statusBadge = document.createElement('span');
  statusBadge.className = `tag payment-status payment-status--${statusValue}`;
  statusBadge.textContent = PAYMENT_STATUS_LABELS[statusValue] || statusValue || 'Pendiente';
  headerMeta.appendChild(statusBadge);

  const entryCurrency = entry.currency || feeInfo?.currency || DEFAULT_TOURNAMENT_CURRENCY;
  const suggestion = entry.suggestion || null;
  const hasRecordedAmount = typeof entry.recordedAmount === 'number' && Number.isFinite(entry.recordedAmount);
  const hasSuggestedAmount = typeof entry.suggestedAmount === 'number' && Number.isFinite(entry.suggestedAmount);
  const recordedAmountValue = hasRecordedAmount ? entry.recordedAmount : null;
  const suggestedAmountValue = hasSuggestedAmount ? entry.suggestedAmount : null;

  if (Number.isFinite(entry.amount)) {
    const amountSpan = document.createElement('span');
    amountSpan.className = 'tournament-payment-amount';
    amountSpan.textContent =
      formatCurrencyValue(entry.amount, entryCurrency) ||
      `${entry.amount.toFixed(2)} ${entryCurrency}`;
    headerMeta.appendChild(amountSpan);
  }

  if (entry.paidAt) {
    const paidAtSpan = document.createElement('span');
    paidAtSpan.textContent = `Pago: ${formatShortDate(entry.paidAt)}`;
    headerMeta.appendChild(paidAtSpan);
  }

  if (!entry.hasEnrollment) {
    const noteSpan = document.createElement('span');
    noteSpan.textContent = 'Sin inscripción activa';
    headerMeta.appendChild(noteSpan);
  }

  summary.appendChild(headerMeta);
  item.appendChild(summary);

  const body = document.createElement('div');
  body.className = 'tournament-payment-body';

  const categoryNames = Array.isArray(entry.categories)
    ? entry.categories.map((category) => category?.name || '').filter(Boolean)
    : [];
  const categoriesMeta = document.createElement('div');
  categoriesMeta.className = 'tournament-payment-meta';
  categoriesMeta.textContent = categoryNames.length
    ? `Categorías: ${categoryNames.join(', ')}`
    : 'Categorías: Sin asignar';
  body.appendChild(categoriesMeta);

  if (entry.player?.email || entry.player?.phone) {
    const contactMeta = document.createElement('div');
    contactMeta.className = 'tournament-payment-meta';
    if (entry.player.email) {
      contactMeta.appendChild(document.createElement('span')).textContent = entry.player.email;
    }
    if (entry.player.phone) {
      contactMeta.appendChild(document.createElement('span')).textContent = entry.player.phone;
    }
    body.appendChild(contactMeta);
  }

  if (suggestion && Number.isFinite(suggestion.amount)) {
    const suggestionMeta = document.createElement('div');
    suggestionMeta.className = 'tournament-payment-meta';
    const membershipLabel = suggestion.isMember ? 'socio' : 'no socio';
    const categoryLabel = suggestion.categoryCount === 1 ? 'categoría' : 'categorías';
    const suggestionCurrency = suggestion.currency || entryCurrency;
    const formattedSuggestion =
      formatCurrencyValue(suggestion.amount, suggestionCurrency) ||
      `${suggestion.amount.toFixed(2)} ${suggestionCurrency}`;
    suggestionMeta.textContent = `Importe sugerido (${suggestion.categoryCount} ${categoryLabel} · ${membershipLabel}): ${formattedSuggestion}`;
    body.appendChild(suggestionMeta);
  }

  if (entry.reference) {
    const referenceMeta = document.createElement('div');
    referenceMeta.className = 'tournament-payment-meta';
    referenceMeta.textContent = `Referencia: ${entry.reference}`;
    body.appendChild(referenceMeta);
  }

  if (entry.recordedBy?.fullName) {
    const recordedMeta = document.createElement('div');
    recordedMeta.className = 'tournament-payment-meta';
    recordedMeta.textContent = `Actualizado por ${entry.recordedBy.fullName}`;
    body.appendChild(recordedMeta);
  }

  const form = document.createElement('form');
  form.className = 'tournament-payment-form';
  form.dataset.tournamentPaymentForm = 'true';
  if (entry.playerId) {
    form.dataset.userId = entry.playerId;
  }
  if (entry.paymentId) {
    form.dataset.paymentId = entry.paymentId;
  }

  const statusRow = document.createElement('div');
  statusRow.className = 'form-row';

  const statusLabel = document.createElement('label');
  statusLabel.textContent = 'Estado';
  const statusSelect = document.createElement('select');
  statusSelect.name = 'status';
  Object.entries(PAYMENT_STATUS_LABELS).forEach(([value, label]) => {
    const option = document.createElement('option');
    option.value = value;
    option.textContent = label;
    if (value === statusValue) {
      option.selected = true;
    }
    statusSelect.appendChild(option);
  });
  statusLabel.appendChild(statusSelect);
  statusRow.appendChild(statusLabel);

  const amountLabel = document.createElement('label');
  amountLabel.textContent = 'Importe';
  const amountInput = document.createElement('input');
  amountInput.type = 'number';
  amountInput.name = 'amount';
  amountInput.min = '0';
  amountInput.step = '0.01';

  if (hasRecordedAmount) {
    amountInput.value = recordedAmountValue.toFixed(2);
  } else if (hasSuggestedAmount) {
    amountInput.value = suggestedAmountValue.toFixed(2);
  } else {
    const fallbackEntry = feeInfo?.member || feeInfo?.nonMember || feeInfo?.general || null;
    const fallbackAmount = Number(fallbackEntry?.amount);
    const fallbackCurrency = fallbackEntry?.currency || feeInfo?.currency || entryCurrency;
    if (Number.isFinite(fallbackAmount) && fallbackAmount >= 0) {
      const formatted =
        formatCurrencyValue(fallbackAmount, fallbackCurrency) ||
        `${fallbackAmount.toFixed(2)} ${fallbackCurrency}`;
      amountInput.placeholder = formatted;
    }
  }

  amountLabel.appendChild(amountInput);
  statusRow.appendChild(amountLabel);
  form.appendChild(statusRow);

  const detailsRow = document.createElement('div');
  detailsRow.className = 'form-row';

  const methodLabel = document.createElement('label');
  methodLabel.textContent = 'Método';
  const methodSelect = document.createElement('select');
  methodSelect.name = 'method';
  const methodValue = (entry.method || '').toString().trim();
  const methodValueLower = methodValue.toLowerCase();
  const placeholderOption = document.createElement('option');
  placeholderOption.value = '';
  placeholderOption.textContent = 'Sin especificar';
  if (!methodValue) {
    placeholderOption.selected = true;
  }
  methodSelect.appendChild(placeholderOption);

  let matchedMethod = false;
  TOURNAMENT_PAYMENT_METHOD_OPTIONS.forEach((label) => {
    const option = document.createElement('option');
    option.value = label;
    option.textContent = label;
    if (methodValueLower && methodValueLower === label.toLowerCase()) {
      option.selected = true;
      matchedMethod = true;
    }
    methodSelect.appendChild(option);
  });

  if (!matchedMethod && methodValue) {
    const customOption = document.createElement('option');
    customOption.value = methodValue;
    customOption.textContent = methodValue;
    customOption.selected = true;
    methodSelect.appendChild(customOption);
  }

  methodLabel.appendChild(methodSelect);
  detailsRow.appendChild(methodLabel);

  const referenceLabel = document.createElement('label');
  referenceLabel.textContent = 'Referencia';
  const referenceInput = document.createElement('input');
  referenceInput.type = 'text';
  referenceInput.name = 'reference';
  referenceInput.placeholder = 'Identificador o concepto';
  referenceInput.value = entry.reference || '';
  referenceLabel.appendChild(referenceInput);
  detailsRow.appendChild(referenceLabel);
  form.appendChild(detailsRow);

  const notesRow = document.createElement('div');
  notesRow.className = 'form-row';

  const paidAtLabel = document.createElement('label');
  paidAtLabel.textContent = 'Fecha de pago';
  const paidAtInput = document.createElement('input');
  paidAtInput.type = 'date';
  paidAtInput.name = 'paidAt';
  paidAtInput.value = entry.paidAt ? formatDateInput(entry.paidAt) : '';
  paidAtLabel.appendChild(paidAtInput);
  notesRow.appendChild(paidAtLabel);

  const notesLabel = document.createElement('label');
  notesLabel.textContent = 'Notas';
  const notesInput = document.createElement('input');
  notesInput.type = 'text';
  notesInput.name = 'notes';
  notesInput.placeholder = 'Añade una nota interna';
  notesInput.value = entry.notes || '';
  notesLabel.appendChild(notesInput);
  notesRow.appendChild(notesLabel);
  form.appendChild(notesRow);

  const actionsRow = document.createElement('div');
  actionsRow.className = 'form-actions';
  const submitButton = document.createElement('button');
  submitButton.type = 'submit';
  submitButton.className = 'primary';
  submitButton.textContent = entry.paymentId ? 'Actualizar pago' : 'Registrar pago';
  actionsRow.appendChild(submitButton);
  form.appendChild(actionsRow);

  body.appendChild(form);
  item.appendChild(body);

  listItem.appendChild(item);

  return listItem;
}

function renderLeaguePayments(entries = [], { fee = null } = {}) {
  if (!leaguePaymentsGroups) return;

  if (leaguePaymentsCount) {
    leaguePaymentsCount.textContent = String(entries.length);
  }

  updateLeaguePaymentFeeIndicator(fee);

  resetLeaguePaymentGroups();

  const pendingEntries = entries.filter((entry) => (entry.status || 'pendiente') !== 'pagado');
  const paidEntries = entries.filter((entry) => (entry.status || 'pendiente') === 'pagado');

  updateLeaguePaymentTotalElement(
    leaguePaymentsPendingTotal,
    calculateLeaguePaymentTotal(pendingEntries)
  );
  updateLeaguePaymentTotalElement(leaguePaymentsPaidTotal, calculateLeaguePaymentTotal(paidEntries));

  if (!entries.length) {
    if (leaguePaymentsPendingCount) {
      leaguePaymentsPendingCount.textContent = '0';
    }
    if (leaguePaymentsPaidCount) {
      leaguePaymentsPaidCount.textContent = '0';
    }
    if (leaguePaymentsPendingEmpty) {
      leaguePaymentsPendingEmpty.hidden = false;
      leaguePaymentsPendingEmpty.textContent = 'No hay pagos pendientes.';
    }
    if (leaguePaymentsPaidEmpty) {
      leaguePaymentsPaidEmpty.hidden = false;
      leaguePaymentsPaidEmpty.textContent = 'No hay pagos registrados.';
    }
    if (leaguePaymentsEmpty) {
      leaguePaymentsEmpty.hidden = false;
      leaguePaymentsEmpty.textContent = 'No hay registros de pago para la selección actual.';
    }
    return;
  }

  if (leaguePaymentsEmpty) {
    leaguePaymentsEmpty.hidden = true;
  }

  const groups = [
    {
      entries: pendingEntries,
      list: leaguePaymentsPendingList,
      emptyElement: leaguePaymentsPendingEmpty,
      countElement: leaguePaymentsPendingCount,
      emptyText: 'No hay pagos pendientes.',
    },
    {
      entries: paidEntries,
      list: leaguePaymentsPaidList,
      emptyElement: leaguePaymentsPaidEmpty,
      countElement: leaguePaymentsPaidCount,
      emptyText: 'No hay pagos registrados.',
    },
  ];

  groups.forEach(({ entries: groupEntries, list, emptyElement, countElement, emptyText }) => {
    if (countElement) {
      countElement.textContent = String(groupEntries.length);
    }

    if (!list) {
      return;
    }

    list.innerHTML = '';

    if (!groupEntries.length) {
      if (emptyElement) {
        emptyElement.hidden = false;
        emptyElement.textContent = emptyText;
      }
      return;
    }

    if (emptyElement) {
      emptyElement.hidden = true;
    }

    groupEntries.forEach((entry) => {
      list.appendChild(createLeaguePaymentItem(entry, { fee }));
    });
  });
}

function renderTournamentPayments(
  entries = [],
  { feeInfo = null, currency = DEFAULT_TOURNAMENT_CURRENCY } = {}
) {
  if (!tournamentPaymentsGroups) return;

  if (tournamentPaymentsCount) {
    tournamentPaymentsCount.textContent = String(entries.length);
  }

  updateTournamentPaymentFeeIndicator(feeInfo);

  resetTournamentPaymentGroups();

  const pendingEntries = entries.filter((entry) => (entry.status || 'pendiente') !== 'pagado');
  const paidEntries = entries.filter((entry) => (entry.status || 'pendiente') === 'pagado');

  updateTournamentPaymentTotalElement(
    tournamentPaymentsPendingTotal,
    calculateTournamentPaymentTotal(pendingEntries),
    currency
  );
  updateTournamentPaymentTotalElement(
    tournamentPaymentsPaidTotal,
    calculateTournamentPaymentTotal(paidEntries),
    currency
  );

  if (!entries.length) {
    if (tournamentPaymentsPendingCount) {
      tournamentPaymentsPendingCount.textContent = '0';
    }
    if (tournamentPaymentsPaidCount) {
      tournamentPaymentsPaidCount.textContent = '0';
    }
    if (tournamentPaymentsPendingEmpty) {
      tournamentPaymentsPendingEmpty.hidden = false;
      tournamentPaymentsPendingEmpty.textContent = 'No hay pagos pendientes.';
    }
    if (tournamentPaymentsPaidEmpty) {
      tournamentPaymentsPaidEmpty.hidden = false;
      tournamentPaymentsPaidEmpty.textContent = 'No hay pagos registrados.';
    }
    if (tournamentPaymentsEmpty) {
      tournamentPaymentsEmpty.hidden = false;
      tournamentPaymentsEmpty.textContent = 'No hay registros de pago para la selección actual.';
    }
    return;
  }

  if (tournamentPaymentsEmpty) {
    tournamentPaymentsEmpty.hidden = true;
  }

  const groups = [
    {
      entries: pendingEntries,
      list: tournamentPaymentsPendingList,
      emptyElement: tournamentPaymentsPendingEmpty,
      countElement: tournamentPaymentsPendingCount,
      emptyText: 'No hay pagos pendientes.',
    },
    {
      entries: paidEntries,
      list: tournamentPaymentsPaidList,
      emptyElement: tournamentPaymentsPaidEmpty,
      countElement: tournamentPaymentsPaidCount,
      emptyText: 'No hay pagos registrados.',
    },
  ];

  groups.forEach(({ entries: groupEntries, list, emptyElement, countElement, emptyText }) => {
    if (countElement) {
      countElement.textContent = String(groupEntries.length);
    }

    if (!list) {
      return;
    }

    list.innerHTML = '';

    if (!groupEntries.length) {
      if (emptyElement) {
        emptyElement.hidden = false;
        emptyElement.textContent = emptyText;
      }
      return;
    }

    if (emptyElement) {
      emptyElement.hidden = true;
    }

    groupEntries.forEach((entry) => {
      list.appendChild(createTournamentPaymentItem(entry, { feeInfo }));
    });
  });
}

async function refreshLeaguePayments({ force = false } = {}) {
  if (!leaguePaymentsGroups) return;

  const filters = ensureLeaguePaymentFilters();
  const leagueId = filters.league;

  if (!leagueId) {
    resetLeaguePaymentGroups();
    if (leaguePaymentsCount) {
      leaguePaymentsCount.textContent = '0';
    }
    const hasOptions = getLeaguesWithEnrollmentFee().length > 0;
    if (leaguePaymentsEmpty) {
      leaguePaymentsEmpty.hidden = false;
      leaguePaymentsEmpty.textContent = hasOptions
        ? 'Selecciona una liga con cuota para ver los pagos.'
        : 'Configura una liga con cuota de inscripción para gestionar pagos.';
    }
    updateLeaguePaymentFeeIndicator();
    setStatusMessage(leaguePaymentsStatusMessage, '', '');
    return;
  }

  const usingCachedData = !force && state.leaguePayments instanceof Map && state.leaguePayments.has(leagueId);

  if (!usingCachedData) {
    resetLeaguePaymentGroups();
    if (leaguePaymentsStatusMessage) {
      setStatusMessage(leaguePaymentsStatusMessage, 'info', 'Cargando registros de pago...');
    }
    if (leaguePaymentsEmpty) {
      leaguePaymentsEmpty.hidden = false;
      leaguePaymentsEmpty.textContent = 'Cargando registros de pago...';
    }
  }

  const requestToken = ++leaguePaymentsRequestToken;
  state.leaguePaymentsLoading = true;

  try {
    const data = await getLeaguePaymentData(leagueId, { force });
    if (requestToken !== leaguePaymentsRequestToken) {
      return;
    }

    const activeFilters = ensureLeaguePaymentFilters();
    const searchTerm = (activeFilters.search || '').trim().toLowerCase();

    const filteredEntries = (data.entries || []).filter((entry) => {
      if (searchTerm) {
        const categoryNames = entry.categories.map((category) => category?.name || '').join(' ');
        const haystack = `${entry.player?.fullName || ''} ${entry.player?.email || ''} ${
          entry.player?.phone || ''
        } ${categoryNames}`
          .toLowerCase()
          .trim();
        if (!haystack.includes(searchTerm)) {
          return false;
        }
      }
      return true;
    });

    renderLeaguePayments(filteredEntries, { fee: data.fee });

    if (leaguePaymentsStatusMessage) {
      setStatusMessage(leaguePaymentsStatusMessage, '', '');
    }
  } catch (error) {
    if (requestToken !== leaguePaymentsRequestToken) {
      return;
    }

    if (leaguePaymentsStatusMessage) {
      setStatusMessage(leaguePaymentsStatusMessage, 'error', error.message);
    }
    resetLeaguePaymentGroups();
    if (leaguePaymentsCount) {
      leaguePaymentsCount.textContent = '0';
    }
    if (leaguePaymentsEmpty) {
      leaguePaymentsEmpty.hidden = false;
      leaguePaymentsEmpty.textContent = 'No fue posible cargar los registros de pago.';
    }
  } finally {
    if (requestToken === leaguePaymentsRequestToken) {
      state.leaguePaymentsLoading = false;
    }
  }
}

async function refreshTournamentPayments({ force = false } = {}) {
  if (!tournamentPaymentsGroups) return;

  const filters = ensureTournamentPaymentFilters();
  const tournamentId = filters.tournament;

  if (!tournamentId) {
    resetTournamentPaymentGroups();
    if (tournamentPaymentsCount) {
      tournamentPaymentsCount.textContent = '0';
    }
    const hasOptions = getTournamentsWithEnrollmentFee().length > 0;
    if (tournamentPaymentsEmpty) {
      tournamentPaymentsEmpty.hidden = false;
      tournamentPaymentsEmpty.textContent = hasOptions
        ? 'Selecciona un torneo con cuotas para gestionar los pagos.'
        : 'Configura cuotas de inscripción para habilitar el seguimiento de pagos.';
    }
    updateTournamentPaymentFeeIndicator(null);
    setStatusMessage(tournamentPaymentsStatusMessage, '', '');
    return;
  }

  const usingCachedData =
    !force &&
    state.tournamentPayments instanceof Map &&
    state.tournamentPayments.has(tournamentId);

  if (!usingCachedData) {
    resetTournamentPaymentGroups();
    if (tournamentPaymentsStatusMessage) {
      setStatusMessage(tournamentPaymentsStatusMessage, 'info', 'Cargando registros de pago...');
    }
    if (tournamentPaymentsEmpty) {
      tournamentPaymentsEmpty.hidden = false;
      tournamentPaymentsEmpty.textContent = 'Cargando registros de pago...';
    }
  }

  const requestToken = ++tournamentPaymentsRequestToken;
  state.tournamentPaymentsLoading = true;

  try {
    const data = await getTournamentPaymentData(tournamentId, { force });
    if (requestToken !== tournamentPaymentsRequestToken) {
      return;
    }

    const activeFilters = ensureTournamentPaymentFilters();
    const searchTerm = (activeFilters.search || '').trim().toLowerCase();

    const filteredEntries = (data.entries || []).filter((entry) => {
      if (searchTerm) {
        const categoryNames = Array.isArray(entry.categories)
          ? entry.categories.map((category) => category?.name || '').join(' ')
          : '';
        const haystack = `${entry.player?.fullName || ''} ${entry.player?.email || ''} ${
          entry.player?.phone || ''
        } ${categoryNames}`
          .toLowerCase()
          .trim();
        if (!haystack.includes(searchTerm)) {
          return false;
        }
      }
      return true;
    });

    renderTournamentPayments(filteredEntries, { feeInfo: data.feeInfo, currency: data.currency });

    if (tournamentPaymentsStatusMessage) {
      setStatusMessage(tournamentPaymentsStatusMessage, '', '');
    }
  } catch (error) {
    if (requestToken !== tournamentPaymentsRequestToken) {
      return;
    }

    if (tournamentPaymentsStatusMessage) {
      setStatusMessage(tournamentPaymentsStatusMessage, 'error', error.message);
    }
    resetTournamentPaymentGroups();
    if (tournamentPaymentsCount) {
      tournamentPaymentsCount.textContent = '0';
    }
    if (tournamentPaymentsEmpty) {
      tournamentPaymentsEmpty.hidden = false;
      tournamentPaymentsEmpty.textContent = 'No fue posible cargar los registros de pago.';
    }
  } finally {
    if (requestToken === tournamentPaymentsRequestToken) {
      state.tournamentPaymentsLoading = false;
    }
  }
}

async function handleLeaguePaymentFormSubmit(form) {
  if (!form) return;
  const filters = ensureLeaguePaymentFilters();
  const leagueId = filters.league;
  if (!leagueId) {
    setStatusMessage(leaguePaymentsStatusMessage, 'error', 'Selecciona una liga con cuota.');
    return;
  }

  const paymentId = form.dataset.paymentId || '';
  const userId = form.dataset.userId || '';
  const formData = new FormData(form);

  const payload = {};
  const statusValue = formData.get('status');
  if (statusValue && PAYMENT_STATUS_LABELS[statusValue]) {
    payload.status = statusValue;
  }

  const amountRaw = formData.get('amount');
  if (amountRaw !== null && amountRaw !== undefined) {
    const trimmed = String(amountRaw).trim();
    if (trimmed) {
      const normalizedAmount = Number.parseFloat(trimmed.replace(',', '.'));
      if (Number.isNaN(normalizedAmount) || normalizedAmount < 0) {
        setStatusMessage(leaguePaymentsStatusMessage, 'error', 'Introduce un importe válido.');
        return;
      }
      payload.amount = normalizedAmount;
    }
  }

  ['method', 'reference', 'notes'].forEach((field) => {
    if (formData.has(field)) {
      const value = (formData.get(field) || '').toString().trim();
      payload[field] = value || null;
    }
  });

  const paidAtValue = (formData.get('paidAt') || '').toString().trim();
  if (paidAtValue) {
    payload.paidAt = paidAtValue;
  } else if (paymentId) {
    payload.paidAt = null;
  }

  try {
    setStatusMessage(
      leaguePaymentsStatusMessage,
      'info',
      paymentId ? 'Actualizando pago...' : 'Registrando pago...'
    );

    if (paymentId) {
      await request(`/leagues/${leagueId}/payments/${paymentId}`, { method: 'PATCH', body: payload });
    } else {
      if (!userId) {
        throw new Error('No se puede registrar el pago sin un jugador asociado.');
      }
      await request(`/leagues/${leagueId}/payments`, {
        method: 'POST',
        body: { ...payload, user: userId },
      });
    }

    await fetchLeagueDetail(leagueId, { force: true });
    if (state.selectedLeagueId === leagueId) {
      renderLeagueDetail();
    }
    if (state.leaguePayments instanceof Map) {
      state.leaguePayments.delete(leagueId);
    }

    await refreshLeaguePayments({ force: true });

    setStatusMessage(
      leaguePaymentsStatusMessage,
      'success',
      paymentId ? 'Pago actualizado correctamente.' : 'Pago registrado correctamente.'
    );
  } catch (error) {
    setStatusMessage(leaguePaymentsStatusMessage, 'error', error.message);
  }
}

async function handleTournamentPaymentFormSubmit(form) {
  if (!form) return;
  const filters = ensureTournamentPaymentFilters();
  const tournamentId = filters.tournament;
  if (!tournamentId) {
    setStatusMessage(tournamentPaymentsStatusMessage, 'error', 'Selecciona un torneo con cuotas.');
    return;
  }

  const paymentId = form.dataset.paymentId || '';
  const userId = form.dataset.userId || '';
  const formData = new FormData(form);

  const payload = {};
  const statusValue = formData.get('status');
  if (statusValue && PAYMENT_STATUS_LABELS[statusValue]) {
    payload.status = statusValue;
  }

  const amountRaw = formData.get('amount');
  if (amountRaw !== null && amountRaw !== undefined) {
    const trimmed = String(amountRaw).trim();
    if (trimmed) {
      const normalizedAmount = Number.parseFloat(trimmed.replace(',', '.'));
      if (Number.isNaN(normalizedAmount) || normalizedAmount < 0) {
        setStatusMessage(tournamentPaymentsStatusMessage, 'error', 'Introduce un importe válido.');
        return;
      }
      payload.amount = normalizedAmount;
    }
  }

  ['method', 'reference', 'notes'].forEach((field) => {
    if (formData.has(field)) {
      const value = (formData.get(field) || '').toString().trim();
      payload[field] = value || null;
    }
  });

  const paidAtValue = (formData.get('paidAt') || '').toString().trim();
  if (paidAtValue) {
    payload.paidAt = paidAtValue;
  } else if (paymentId) {
    payload.paidAt = null;
  }

  try {
    setStatusMessage(
      tournamentPaymentsStatusMessage,
      'info',
      paymentId ? 'Actualizando pago...' : 'Registrando pago...'
    );

    if (paymentId) {
      await request(`/tournaments/${tournamentId}/payments/${paymentId}`, { method: 'PATCH', body: payload });
    } else {
      if (!userId) {
        throw new Error('No se puede registrar el pago sin un jugador asociado.');
      }
      await request(`/tournaments/${tournamentId}/payments`, {
        method: 'POST',
        body: { ...payload, user: userId },
      });
    }

    if (state.tournamentDetails instanceof Map) {
      state.tournamentDetails.delete(tournamentId);
    }
    await loadTournamentDetail(tournamentId);
    if (state.selectedTournamentId === tournamentId) {
      await refreshTournamentDetail(tournamentId);
    }

    if (state.tournamentPayments instanceof Map) {
      state.tournamentPayments.delete(tournamentId);
    }

    await refreshTournamentPayments({ force: true });

    setStatusMessage(
      tournamentPaymentsStatusMessage,
      'success',
      paymentId ? 'Pago actualizado correctamente.' : 'Pago registrado correctamente.'
    );
  } catch (error) {
    setStatusMessage(tournamentPaymentsStatusMessage, 'error', error.message);
  }
}

function collectEnrollmentRequestAlerts() {
  if (!isAdmin()) {
    state.pendingEnrollmentRequestCount = 0;
    return { alerts: [], total: 0 };
  }

  const categories = Array.isArray(state.categories) ? state.categories : [];
  let total = 0;
  const alerts = [];

  categories.forEach((category) => {
    const pendingCount = Number(category?.pendingRequestCount || 0);
    if (!Number.isFinite(pendingCount) || pendingCount <= 0) {
      return;
    }

    total += pendingCount;
    const categoryId = normalizeId(category);
    const categoryName = category?.name || 'Categoría';

    let scheduledFor = new Date();
    if (category?.pendingRequestLatestAt) {
      const candidate = new Date(category.pendingRequestLatestAt);
      if (!Number.isNaN(candidate.getTime())) {
        scheduledFor = candidate;
      }
    }

    alerts.push({
      type: 'enrollment-request',
      categoryId,
      categoryName,
      pendingCount,
      countValue: pendingCount,
      scheduledFor: scheduledFor.toISOString(),
      channel: 'solicitudes',
      title: `Solicitudes de inscripción · ${categoryName}`,
      message:
        pendingCount === 1
          ? `Hay 1 solicitud pendiente para ${categoryName}.`
          : `Hay ${pendingCount} solicitudes pendientes para ${categoryName}.`,
    });
  });

  alerts.sort((a, b) => new Date(b.scheduledFor) - new Date(a.scheduledFor));

  const tournaments = Array.isArray(state.tournaments) ? state.tournaments : [];
  tournaments.forEach((tournament) => {
    const tournamentId = normalizeId(tournament);
    const tournamentName = tournament?.name || 'Torneo';
    const tournamentCategories = Array.isArray(tournament.categories) ? tournament.categories : [];
    tournamentCategories.forEach((category) => {
      const pendingCount = Number(
        category?.pendingEnrollmentCount || category?.enrollmentStats?.pending || 0
      );
      if (!Number.isFinite(pendingCount) || pendingCount <= 0) {
        return;
      }

      total += pendingCount;
      const categoryId = normalizeId(category);
      const categoryName = category?.name || 'Categoría';

      alerts.push({
        type: 'tournament-enrollment-request',
        tournamentId,
        categoryId,
        tournamentName,
        categoryName,
        pendingCount,
        countValue: pendingCount,
        scheduledFor: new Date().toISOString(),
        channel: 'torneos',
        title: `${tournamentName} · ${categoryName}`,
        message:
          pendingCount === 1
            ? `Hay 1 solicitud pendiente en ${categoryName} del torneo ${tournamentName}.`
            : `Hay ${pendingCount} solicitudes pendientes en ${categoryName} del torneo ${tournamentName}.`,
      });
    });
  });

  alerts.sort((a, b) => new Date(b.scheduledFor) - new Date(a.scheduledFor));
  state.pendingEnrollmentRequestCount = total;

  return { alerts, total };
}

function combineNotificationsWithEnrollmentRequests(notifications = []) {
  const base = Array.isArray(notifications) ? [...notifications] : [];
  const { alerts } = collectEnrollmentRequestAlerts();
  return base.concat(alerts);
}

function updateNoticesMenuBadge(count = 0) {
  if (!noticesMenuBadge) return;
  noticesMenuBadge.textContent = String(count);
  noticesMenuBadge.hidden = count <= 0;
}

function getNoticeStorageKey(userId) {
  if (!userId) return null;
  return `${NOTICE_LAST_SEEN_PREFIX}${userId}`;
}

function readNoticeLastSeen(userId) {
  const key = getNoticeStorageKey(userId);
  if (!key) return 0;
  try {
    const raw = localStorage.getItem(key);
    if (!raw) return 0;
    const numeric = Number(raw);
    if (Number.isFinite(numeric)) {
      return numeric;
    }
    const parsed = Date.parse(raw);
    return Number.isFinite(parsed) ? parsed : 0;
  } catch (error) {
    console.warn('No fue posible leer la última visita al panel de avisos', error);
    return 0;
  }
}

function writeNoticeLastSeen(userId, timestamp) {
  const key = getNoticeStorageKey(userId);
  if (!key) return;
  const value = Number(timestamp);
  if (!Number.isFinite(value) || value <= 0) return;
  try {
    localStorage.setItem(key, String(Math.floor(value)));
  } catch (error) {
    console.warn('No fue posible guardar la última visita al panel de avisos', error);
  }
}

function syncNoticeBoardState(messages = state.generalChatMessages) {
  const currentUserId = normalizeId(state.user);
  if (!currentUserId) {
    state.noticeUnreadCount = 0;
    updateNoticesMenuBadge(0);
    return;
  }

  const list = Array.isArray(messages) ? messages : [];
  const lastSeen = readNoticeLastSeen(currentUserId);
  let latestTimestamp = lastSeen;
  let unread = 0;

  list.forEach((message) => {
    const timestamp = Date.parse(message?.createdAt);
    if (!Number.isFinite(timestamp)) {
      return;
    }
    if (timestamp > latestTimestamp) {
      latestTimestamp = timestamp;
    }
    const senderId = normalizeId(message?.sender);
    if (senderId && senderId === currentUserId) {
      return;
    }
    if (!lastSeen || timestamp > lastSeen) {
      unread += 1;
    }
  });

  if (state.activeSection === 'section-chat') {
    if (latestTimestamp > 0) {
      writeNoticeLastSeen(currentUserId, latestTimestamp);
    }
    unread = 0;
  }

  state.noticeUnreadCount = unread;
  updateNoticesMenuBadge(unread);
}

function addParentTargets(button, activeTargets, visitedTargets = new Set()) {
  let currentButton = button;
  while (currentButton) {
    const parentTarget = currentButton.dataset?.parentTarget;
    if (!parentTarget || visitedTargets.has(parentTarget)) {
      return;
    }

    visitedTargets.add(parentTarget);
    activeTargets.add(parentTarget);

    const parentButton = menuButtons.find((candidate) => candidate.dataset.target === parentTarget);
    if (!parentButton || parentButton === currentButton) {
      return;
    }
    currentButton = parentButton;
  }
}

function setActiveMenu(targetId = null) {
  if (!menuButtons.length) return;

  const activeTargets = new Set();

  if (targetId) {
    activeTargets.add(targetId);
    const matchingButtons = menuButtons.filter((button) => button.dataset.target === targetId);
    const targetButton = matchingButtons[0];
    if (targetButton) {
      addParentTargets(targetButton, activeTargets);
    }
  }

  menuButtons.forEach((button) => {
    const target = button.dataset.target;
    button.classList.toggle('active', target ? activeTargets.has(target) : false);
  });

  if (collapsibleMenuGroups.length) {
    const allowAutomaticExpansion = !shouldUseHoverNavigation();
    collapsibleMenuGroups.forEach((menuGroup) => {
      const shouldExpand =
        allowAutomaticExpansion && menuGroup.target ? activeTargets.has(menuGroup.target) : false;
      setMenuGroupExpanded(menuGroup, shouldExpand);
    });
  }
}

function updateAdminMenuVisibility() {
  if (!adminMenuButtons.length) return;
  const shouldShow = isAdmin();
  adminMenuButtons.forEach((button) => {
    button.hidden = !shouldShow;
  });

  if (adminToggleElements.length) {
    adminToggleElements.forEach((element) => {
      if (!element) return;
      element.hidden = !shouldShow;
    });
    refreshTournamentBracketLayoutColumns();
  }

  if (generalChatForm) {
    generalChatForm.hidden = !shouldShow;
  }

  if (generalChatInput) {
    generalChatInput.disabled = !shouldShow;
  }

  updateLeaguePaymentMenuVisibility();
  updateTournamentPaymentMenuVisibility();

  if (!shouldShow && adminSectionIds.size) {
    adminSectionIds.forEach((sectionId) => {
      const section = document.getElementById(sectionId);
      if (section) {
        section.hidden = true;
      }
    });
  }

  if (!shouldShow && adminSectionIds.has(state.activeSection)) {
    showSection('section-dashboard');
  }
}

function updateLeaguePaymentMenuVisibility() {
  if (!leaguePaymentsMenuButton) return;

  const adminUser = isAdmin();
  const hasFeeLeagues = adminUser && getLeaguesWithEnrollmentFee().length > 0;
  leaguePaymentsMenuButton.hidden = !hasFeeLeagues;

  if (!hasFeeLeagues) {
    if (leaguePaymentsSection) {
      leaguePaymentsSection.hidden = true;
    }
    if (adminUser && state.activeSection === 'section-league-payments') {
      showSection('section-league-dashboard');
    }
  }
}

function updateTournamentPaymentMenuVisibility() {
  if (!tournamentPaymentsMenuButton) return;

  const adminUser = isAdmin();
  const hasFeeTournaments = adminUser && getTournamentsWithEnrollmentFee().length > 0;
  tournamentPaymentsMenuButton.hidden = !hasFeeTournaments;

  if (!hasFeeTournaments) {
    if (tournamentPaymentsSection) {
      tournamentPaymentsSection.hidden = true;
    }
    if (adminUser && state.activeSection === 'section-tournament-payments') {
      showSection('section-tournament-dashboard');
    }
  }
}

function updateCourtManagerMenuVisibility() {
  if (!courtManagerMenuButtons.length) return;
  const shouldShow = hasCourtManagementAccess();
  courtManagerMenuButtons.forEach((button) => {
    button.hidden = !shouldShow;
  });

  if (!shouldShow && courtManagerSectionIds.has(state.activeSection)) {
    showSection('section-dashboard');
  }
}

function applyCourtManagerMenuRestrictions() {
  if (!menuButtons.length) return;

  const restricted = isCourtManager() && !isAdmin();
  const allowedTargets = new Set(['section-court-reservations', 'section-court-admin', 'section-account']);

  menuButtons.forEach((button) => {
    if (button.dataset.requiresAdmin === 'true' || button.dataset.requiresCourtManager === 'true') {
      return;
    }

    const initialHidden = menuButtonInitialHidden.get(button) === true;
    if (!restricted) {
      button.hidden = initialHidden;
      return;
    }

    const target = button.dataset.target;
    if (!target || button.dataset.action === 'logout') {
      button.hidden = initialHidden;
      return;
    }

    button.hidden = !allowedTargets.has(target);
  });
}

function showSection(sectionId, { syncHistory = true, replace = false } = {}) {
  if (!sectionId || !appSections.length) return;

  const targetSection = document.getElementById(sectionId);
  if (!targetSection) return;

  let resolvedSectionId = sectionId;
  if (targetSection.dataset.adminOnly === 'true' && !isAdmin()) {
    resolvedSectionId = 'section-dashboard';
    showGlobalMessage('Necesitas permisos de administrador para acceder a esta sección.', 'error');
  } else if (targetSection.dataset.requiresCourtManager === 'true' && !hasCourtManagementAccess()) {
    resolvedSectionId = 'section-dashboard';
    showGlobalMessage('Necesitas permisos de gestor de pistas para acceder a esta sección.', 'error');
  } else if (isCourtManager() && !isAdmin()) {
    const allowed = new Set(['section-court-reservations', 'section-court-admin', 'section-account']);
    if (!allowed.has(sectionId)) {
      resolvedSectionId = 'section-court-admin';
      showGlobalMessage('Tu perfil solo tiene acceso a la gestión de pistas y reservas.', 'error');
    }
  }

  const previousSectionId = state.activeSection;
  state.activeSection = resolvedSectionId;

  if (syncHistory) {
    const shouldReplaceHistory =
      replace || shouldReplaceHistoryOnNextSection || !previousSectionId;
    syncSectionRoute(resolvedSectionId, { replace: shouldReplaceHistory });
  }
  shouldReplaceHistoryOnNextSection = false;

  appSections.forEach((section) => {
    section.hidden = section.id !== resolvedSectionId;
  });

  if (resolvedSectionId !== 'section-account') {
    toggleProfileForm(false);
  }

  setActiveMenu(resolvedSectionId);
  closeMobileMenu();
  syncNoticeBoardState();

  if (resolvedSectionId === 'section-dashboard') {
    loadGlobalOverview({ force: false });
  } else if (resolvedSectionId === 'section-league-dashboard') {
    loadLeagueDashboard({ force: false });
  } else if (resolvedSectionId === 'section-league-payments') {
    refreshLeaguePayments().catch((error) => {
      console.warn('No se pudo cargar los pagos de liga', error);
    });
  } else if (resolvedSectionId === 'section-tournament-dashboard') {
    loadTournamentDashboard({ force: false });
  } else if (resolvedSectionId === 'section-tournament-doubles') {
    refreshTournamentDoubles();
  } else if (resolvedSectionId === 'section-tournament-brackets') {
    if (state.selectedBracketTournamentId && !state.tournamentDetails.has(state.selectedBracketTournamentId)) {
      refreshTournamentDetail(state.selectedBracketTournamentId).catch((error) => {
        setStatusMessage(tournamentBracketStatus, 'error', error.message);
      });
    } else {
      updateBracketCategoryOptions();
    }

    if (state.selectedBracketTournamentId && state.selectedBracketCategoryId) {
      loadTournamentBracketContext({ forceMatches: false });
    }
  } else if (resolvedSectionId === 'section-account') {
    loadAccountSummary({ force: false });
  }
}

async function request(path, { method = 'GET', body, requireAuth = true } = {}) {
  const headers = {
    Accept: 'application/json',
  };

  const isFormData = typeof FormData !== 'undefined' && body instanceof FormData;

  if (body && !isFormData) {
    headers['Content-Type'] = 'application/json';
  }

  if (requireAuth) {
    if (!state.token) {
      throw new Error('Debes iniciar sesión para realizar esta acción.');
    }
    headers.Authorization = `Bearer ${state.token}`;
  }

  let response;
  try {
    response = await fetch(`${API_BASE}${path}`, {
      method,
      headers,
      body: body ? (isFormData ? body : JSON.stringify(body)) : undefined,
    });
  } catch (error) {
    throw new Error('No fue posible conectar con el servidor.');
  }

  const contentType = response.headers.get('content-type') || '';
  let data = null;
  if (contentType.includes('application/json')) {
    data = await response.json();
  }

  if (!response.ok) {
    const message = data?.message || data?.errors?.[0]?.msg || response.statusText;
    if (response.status === 401) {
      clearSession();
      state.token = null;
      state.user = null;
      updateAuthUI();
    }
    throw new Error(message);
  }

  return data;
}

function resetDemoModeResults() {
  if (demoModeResults) {
    demoModeResults.hidden = true;
  }
  if (demoModeCreated) {
    demoModeCreated.textContent = '';
    demoModeCreated.removeAttribute('title');
  }
  if (demoModeSkipped) {
    demoModeSkipped.textContent = '';
    demoModeSkipped.removeAttribute('title');
  }
  if (demoModePassword) {
    demoModePassword.textContent = '';
    demoModePassword.hidden = true;
  }
}

function renderDemoModeResults(result) {
  if (!demoModeResults || !result) {
    return;
  }

  const {
    totalCreated = 0,
    totalSkipped = 0,
    created = [],
    skipped = [],
    password = '',
  } = result;

  if (demoModeCreated) {
    demoModeCreated.textContent = `Jugadores creados: ${totalCreated}`;
    if (Array.isArray(created) && created.length) {
      demoModeCreated.title = created.join(', ');
    } else {
      demoModeCreated.removeAttribute('title');
    }
  }

  if (demoModeSkipped) {
    demoModeSkipped.textContent = `Jugadores ya existentes: ${totalSkipped}`;
    if (Array.isArray(skipped) && skipped.length) {
      demoModeSkipped.title = skipped.join(', ');
    } else {
      demoModeSkipped.removeAttribute('title');
    }
  }

  if (demoModePassword) {
    if (password) {
      demoModePassword.textContent = `Contraseña de las cuentas demo: ${password}`;
      demoModePassword.hidden = false;
    } else {
      demoModePassword.textContent = '';
      demoModePassword.hidden = true;
    }
  }

  demoModeResults.hidden = false;
}

function persistRememberedCredentials(email, password, remember) {
  if (!remember) {
    clearRememberedCredentials();
    return;
  }

  const payload = {
    email: typeof email === 'string' ? email : '',
    password: typeof password === 'string' ? password : '',
  };

  localStorage.setItem(REMEMBER_CREDENTIALS_KEY, JSON.stringify(payload));
}

function clearRememberedCredentials() {
  localStorage.removeItem(REMEMBER_CREDENTIALS_KEY);
}

function loadRememberedCredentials() {
  if (!loginEmailInput || !loginPasswordInput || !loginRememberCheckbox) {
    return;
  }

  const storedRaw = localStorage.getItem(REMEMBER_CREDENTIALS_KEY);
  if (!storedRaw) {
    loginRememberCheckbox.checked = false;
    return;
  }

  try {
    const stored = JSON.parse(storedRaw);
    const savedEmail = typeof stored?.email === 'string' ? stored.email : '';
    const savedPassword = typeof stored?.password === 'string' ? stored.password : '';

    loginEmailInput.value = savedEmail;
    loginPasswordInput.value = savedPassword;
    loginRememberCheckbox.checked = Boolean(savedEmail || savedPassword);
  } catch (error) {
    clearRememberedCredentials();
    loginRememberCheckbox.checked = false;
  }
}

function persistSession() {
  if (state.token && state.user) {
    localStorage.setItem(STORAGE_KEY, JSON.stringify({ token: state.token, user: state.user }));
  }
}

function clearSession() {
  localStorage.removeItem(STORAGE_KEY);
}

function urlBase64ToUint8Array(base64String) {
  const padding = '='.repeat((4 - (base64String.length % 4)) % 4);
  const base64 = (base64String + padding).replace(/-/g, '+').replace(/_/g, '/');
  const rawData = window.atob(base64);
  const outputArray = new Uint8Array(rawData.length);
  for (let i = 0; i < rawData.length; i += 1) {
    outputArray[i] = rawData.charCodeAt(i);
  }
  return outputArray;
}

function ensurePushServiceWorker() {
  if (!state.push.supported) {
    return Promise.resolve(null);
  }

  if (!pushServiceWorkerRegistrationPromise) {
    pushServiceWorkerRegistrationPromise = navigator.serviceWorker
      .register('/app/service-worker.js')
      .then(() => navigator.serviceWorker.ready)
      .then((registration) => {
        pushServiceWorkerRegistration = registration;
        return registration;
      })
      .catch((error) => {
        console.warn('No se pudo registrar el service worker de notificaciones push', error);
        pushServiceWorkerRegistrationPromise = null;
        pushServiceWorkerRegistration = null;
        return null;
      });
  }

  return pushServiceWorkerRegistrationPromise;
}

async function getPushRegistration() {
  if (!state.push.supported) {
    return null;
  }

  if (pushServiceWorkerRegistration) {
    return pushServiceWorkerRegistration;
  }

  const registration = await ensurePushServiceWorker();
  pushServiceWorkerRegistration = registration;
  return registration;
}

function getPushStatusLabel() {
  if (!state.user) {
    return 'Disponible tras iniciar sesión';
  }

  if (!state.push.supported) {
    return 'No compatible';
  }

  if (!state.push.serverEnabled) {
    return 'No disponible';
  }

  if (state.push.permission === 'denied') {
    return 'Bloqueadas en el navegador';
  }

  return state.push.enabled ? 'Activadas' : 'Pendiente de activar';
}

function updatePushSettingsUI() {
  if (accountPushStatus) {
    accountPushStatus.textContent = getPushStatusLabel();
  }

  if (!pushSettingsCard) {
    return;
  }

  const supported = state.push.supported;
  const loggedIn = Boolean(state.token);
  const permission = supported && typeof Notification !== 'undefined' ? Notification.permission : 'default';
  state.push.permission = permission;
  const serverEnabled = state.push.serverEnabled && Boolean(state.push.publicKey);
  const loading = state.push.loading;

  let statusMessage = '';
  if (!supported) {
    statusMessage = 'Tu navegador no es compatible con las notificaciones push.';
  } else if (!loggedIn) {
    statusMessage = 'Inicia sesión para configurar las notificaciones push en este dispositivo.';
  } else if (!state.push.configLoaded) {
    statusMessage = 'Verificando la disponibilidad de las notificaciones push...';
  } else if (!serverEnabled) {
    statusMessage = 'Las notificaciones push todavía no están habilitadas en el servidor.';
  } else if (permission === 'denied') {
    statusMessage = 'Has bloqueado las notificaciones push desde el navegador.';
  } else if (state.push.enabled) {
    statusMessage = 'Recibirás avisos inmediatos del club en este dispositivo.';
  } else {
    statusMessage = 'Activa las notificaciones push para recibir avisos en tiempo real del club.';
  }

  if (pushStatusText) {
    pushStatusText.textContent = statusMessage;
  }

  const canEnable =
    supported &&
    loggedIn &&
    serverEnabled &&
    permission !== 'denied' &&
    Boolean(state.push.publicKey);

  if (pushEnableButton) {
    pushEnableButton.hidden = !canEnable || state.push.enabled;
    pushEnableButton.disabled = loading || !canEnable;
  }

  if (pushDisableButton) {
    pushDisableButton.hidden = !state.push.enabled;
    pushDisableButton.disabled = loading;
  }

  if (pushPermissionWarning) {
    pushPermissionWarning.hidden = permission !== 'denied';
  }

  if (pushUnsupportedWarning) {
    pushUnsupportedWarning.hidden = supported;
  }
}

async function fetchPushConfig() {
  if (!state.token || !state.push.supported) {
    state.push.configLoaded = true;
    state.push.serverEnabled = false;
    state.push.publicKey = null;
    updatePushSettingsUI();
    return null;
  }

  try {
    const config = await request('/push/config');
    state.push.publicKey = config?.publicKey || null;
    state.push.serverEnabled = Boolean(config?.enabled && config?.publicKey);
    state.push.configLoaded = true;
    return config;
  } catch (error) {
    state.push.publicKey = null;
    state.push.serverEnabled = false;
    state.push.configLoaded = true;
    throw error;
  } finally {
    updatePushSettingsUI();
  }
}

function serializePushSubscription(subscription) {
  if (!subscription) {
    return null;
  }

  const json = subscription.toJSON();
  return {
    endpoint: subscription.endpoint,
    expirationTime: subscription.expirationTime,
    keys: json?.keys || {},
    userAgent: navigator.userAgent,
  };
}

async function syncPushSubscriptionState() {
  if (!state.token || !state.push.supported) {
    state.push.enabled = false;
    state.push.subscriptionEndpoint = null;
    updatePushSettingsUI();
    return;
  }

  state.push.loading = true;
  updatePushSettingsUI();

  try {
    if (!state.push.configLoaded) {
      try {
        await fetchPushConfig();
      } catch (error) {
        console.warn('No se pudo obtener la configuración de notificaciones push', error);
      }
    }

    if (!state.push.serverEnabled || !state.push.publicKey) {
      state.push.enabled = false;
      return;
    }

    const registration = await getPushRegistration();
    if (!registration) {
      state.push.enabled = false;
      return;
    }

    const existing = await registration.pushManager.getSubscription();
    state.push.subscriptionEndpoint = existing?.endpoint || null;
    state.push.permission = typeof Notification !== 'undefined' ? Notification.permission : 'default';

    if (existing && state.push.permission === 'granted') {
      const payload = serializePushSubscription(existing);
      if (payload) {
        try {
          await request('/push/subscriptions', { method: 'POST', body: payload });
          state.push.enabled = true;
        } catch (error) {
          console.warn('No se pudo sincronizar la suscripción push', error);
        }
      }
    } else {
      state.push.enabled = false;
    }
  } catch (error) {
    console.warn('Error al sincronizar las notificaciones push', error);
  } finally {
    state.push.loading = false;
    updatePushSettingsUI();
  }
}

async function enablePushNotifications() {
  if (!state.push.supported || !state.token) {
    showGlobalMessage('Las notificaciones push no están disponibles en este dispositivo.', 'error');
    return;
  }

  state.push.loading = true;
  updatePushSettingsUI();

  try {
    if (!state.push.configLoaded || !state.push.publicKey) {
      await fetchPushConfig();
    }

    if (!state.push.serverEnabled || !state.push.publicKey) {
      showGlobalMessage('Las notificaciones push aún no están habilitadas en el servidor.', 'error');
      return;
    }

    const permission = await Notification.requestPermission();
    state.push.permission = permission;
    if (permission !== 'granted') {
      showGlobalMessage('Debes permitir las notificaciones para activarlas.', 'error');
      return;
    }

    const registration = await getPushRegistration();
    if (!registration) {
      showGlobalMessage('No se pudo preparar el servicio de notificaciones.', 'error');
      return;
    }

    let subscription = await registration.pushManager.getSubscription();
    if (!subscription) {
      const applicationServerKey = urlBase64ToUint8Array(state.push.publicKey);
      subscription = await registration.pushManager.subscribe({
        userVisibleOnly: true,
        applicationServerKey,
      });
    }

    const payload = serializePushSubscription(subscription);
    if (!payload) {
      showGlobalMessage('No se pudo registrar la suscripción push.', 'error');
      return;
    }

    await request('/push/subscriptions', { method: 'POST', body: payload });
    state.push.enabled = true;
    state.push.subscriptionEndpoint = subscription.endpoint;
    showGlobalMessage('Notificaciones push activadas correctamente.');
  } catch (error) {
    console.warn('No se pudo activar las notificaciones push', error);
    const message = error?.message || 'No se pudo activar las notificaciones push.';
    showGlobalMessage(message, 'error');
  } finally {
    state.push.loading = false;
    state.push.permission = state.push.supported && typeof Notification !== 'undefined' ? Notification.permission : 'default';
    updatePushSettingsUI();
  }
}

async function disablePushNotifications() {
  if (!state.push.supported) {
    return;
  }

  state.push.loading = true;
  updatePushSettingsUI();

  try {
    const registration = await getPushRegistration();
    if (!registration) {
      state.push.enabled = false;
      return;
    }

    const subscription = await registration.pushManager.getSubscription();
    if (subscription) {
      try {
        await request('/push/subscriptions', {
          method: 'DELETE',
          body: { endpoint: subscription.endpoint },
        });
      } catch (error) {
        console.warn('No se pudo eliminar la suscripción push del servidor', error);
      }
      await subscription.unsubscribe().catch(() => null);
    }

    state.push.enabled = false;
    state.push.subscriptionEndpoint = null;
    showGlobalMessage('Notificaciones push desactivadas en este dispositivo.');
  } catch (error) {
    console.warn('No se pudo desactivar las notificaciones push', error);
    showGlobalMessage('No se pudo desactivar las notificaciones push.', 'error');
  } finally {
    state.push.loading = false;
    updatePushSettingsUI();
  }
}

function restoreSession() {
  try {
    const raw = localStorage.getItem(STORAGE_KEY);
    if (!raw) return;
    const stored = JSON.parse(raw);
    if (stored?.token && stored?.user) {
      state.token = stored.token;
      state.user = stored.user;
    }
  } catch (error) {
    console.warn('No fue posible restaurar la sesión previa', error);
  }
}

function switchTab(target) {
  tabButtons.forEach((button) => {
    const isActive = button.dataset.target === target;
    button.classList.toggle('active', isActive);
    button.setAttribute('aria-selected', isActive ? 'true' : 'false');
  });

  tabPanes.forEach((pane) => {
    pane.hidden = pane.dataset.pane !== target;
  });
}

if (appSwitcher) {
  appSwitcher.addEventListener('click', handleAppSwitcherClick);
}
updateAppSwitcherButtons();

tabButtons.forEach((button) => {
  button.addEventListener('click', () => switchTab(button.dataset.target));
});

if (appMenu) {
  appMenu.addEventListener('click', (event) => {
    const button = event.target.closest('.menu-button');
    if (!button || button.hidden || button.disabled) return;
    const targetId = button.dataset.target;
    const menuGroupElement = button.closest('.menu-group');
    const menuGroup = menuGroupElement ? collapsibleMenuGroupsByElement.get(menuGroupElement) : null;
    const hasSubmenu = Boolean(menuGroup?.submenu);
    const submenuExpanded = hasSubmenu ? !menuGroup.submenu.hidden : false;
    const focusFirstItem = shouldUseHoverNavigation();
    const isParentButton = menuGroup?.parentButton === button;
    const instantNavigate = button.dataset.instantNavigate === 'true';

    if (hasSubmenu && !submenuExpanded) {
      if (isParentButton && instantNavigate) {
        setMenuGroupExpanded(menuGroup, true);
      } else {
        event.preventDefault();
        expandMenuGroup(menuGroup, { focusFirstItem });
        return;
      }
    }

    if (hasSubmenu && !focusFirstItem && isParentButton) {
      if (!instantNavigate) {
        event.preventDefault();
        setMenuGroupExpanded(menuGroup, false);
        return;
      }
    }

    if (!targetId) {
      return;
    }

    const isModifiedClick =
      event.defaultPrevented ||
      event.button === 1 ||
      event.metaKey ||
      event.ctrlKey ||
      event.shiftKey ||
      event.altKey;

    if (isModifiedClick) {
      return;
    }

    event.preventDefault();
    closeMobileMenu();
    showSection(targetId);
  });
}

mobileMenuToggle?.addEventListener('click', (event) => {
  event.preventDefault();
  toggleMobileMenu();
});

mobileMenuBackdrop?.addEventListener('click', () => {
  closeMobileMenu({ restoreFocus: true });
});

mobileMenuClose?.addEventListener('click', () => {
  closeMobileMenu({ restoreFocus: true });
});

if (desktopMediaQuery?.addEventListener) {
  desktopMediaQuery.addEventListener('change', handleDesktopMediaChange);
} else if (desktopMediaQuery?.addListener) {
  desktopMediaQuery.addListener(handleDesktopMediaChange);
}

if (desktopMediaQuery) {
  handleDesktopMediaChange(desktopMediaQuery);
}

if (hoverMediaQuery?.addEventListener) {
  hoverMediaQuery.addEventListener('change', handleHoverMediaChange);
} else if (hoverMediaQuery?.addListener) {
  hoverMediaQuery.addListener(handleHoverMediaChange);
}

if (hoverMediaQuery) {
  handleHoverMediaChange();
}

document.addEventListener('click', handleOutsideMenuClick);

if (typeof window !== 'undefined') {
  window.addEventListener('popstate', (event) => {
    const stateSection = typeof event.state?.section === 'string' ? event.state.section : null;
    let targetSectionId = stateSection || null;

    if (!targetSectionId) {
      const resolvedFromPath = getSectionIdFromPath(window.location.pathname);
      targetSectionId = resolvedFromPath || 'section-dashboard';
      if (!resolvedFromPath) {
        shouldReplaceHistoryOnNextSection = true;
      }
    }

    if (!state.token) {
      state.activeSection = targetSectionId;
      const expectedPath = buildPathFromSection(targetSectionId);
      const normalizedExpected = normalizeHistoryPath(expectedPath);
      const normalizedCurrent = normalizeHistoryPath(window.location.pathname || '/');
      if (normalizedExpected !== normalizedCurrent) {
        shouldReplaceHistoryOnNextSection = true;
      }
      return;
    }

    if (!document.getElementById(targetSectionId)) {
      shouldReplaceHistoryOnNextSection = true;
      showSection('section-dashboard', { replace: true });
      return;
    }

    if (targetSectionId === state.activeSection) {
      const expectedPath = buildPathFromSection(state.activeSection);
      const normalizedExpected = normalizeHistoryPath(expectedPath);
      const normalizedCurrent = normalizeHistoryPath(window.location.pathname || '/');
      if (normalizedExpected !== normalizedCurrent) {
        showSection(targetSectionId, { replace: true });
      }
      return;
    }

    showSection(targetSectionId, { replace: true });
  });
}

function updateProfileCard() {
  if (!state.user) return;

  if (profileName) {
    profileName.textContent = state.user.fullName || '';
  }
  const photo = state.user.photo;
  if (profileAvatar) {
    profileAvatar.style.backgroundImage = photo ? `url('${photo}')` : '';
  }
  if (accountPhoto) {
    accountPhoto.style.backgroundImage = photo ? `url('${photo}')` : '';
  }

  if (accountFullName) {
    accountFullName.textContent = state.user.fullName || '—';
  }

  if (accountEmail) {
    accountEmail.textContent = state.user.email || '—';
  }

  if (accountPhone) {
    accountPhone.textContent = state.user.phone || '—';
  }

  if (accountMembershipStatus) {
    if (state.user.isMember) {
      accountMembershipStatus.textContent = state.user.membershipNumberVerified
        ? 'Socio del club (validado)'
        : 'Socio del club (pendiente de validación)';
    } else {
      accountMembershipStatus.textContent = 'No es socio';
    }
  }

  if (accountMembershipNumber) {
    accountMembershipNumber.textContent = state.user.membershipNumber || '—';
  }

  if (accountMembershipNumberRow) {
    const showMembershipNumber = Boolean(state.user.isMember && state.user.membershipNumber);
    accountMembershipNumberRow.hidden = !showMembershipNumber;
  }

  if (accountBirthDate) {
    accountBirthDate.textContent = state.user.birthDate
      ? formatShortDate(state.user.birthDate)
      : '—';
  }

  if (accountShirtSize) {
    accountShirtSize.textContent = state.user.shirtSize || '—';
  }

  if (accountSchedule) {
    accountSchedule.textContent = state.user.preferredSchedule
      ? translateSchedule(state.user.preferredSchedule)
      : 'Sin preferencia definida';
  }

  if (accountNotes) {
    accountNotes.textContent = state.user.notes || 'Sin notas registradas.';
  }

  if (accountPushStatus) {
    accountPushStatus.textContent = getPushStatusLabel();
  }

  if (profileForm && !profileForm.hidden) {
    fillProfileForm();
  }
}

function fillProfileForm() {
  if (!profileForm || !state.user) return;

  const { elements } = profileForm;
  if (!elements) return;

  elements.fullName.value = state.user.fullName || '';
  elements.email.value = state.user.email || '';
  elements.phone.value = state.user.phone || '';
  if (elements.preferredSchedule) {
    elements.preferredSchedule.value = state.user.preferredSchedule || 'flexible';
  }
  if (elements.shirtSize) {
    elements.shirtSize.value = state.user.shirtSize || '';
  }
  if (elements.gender) {
    elements.gender.value = state.user.gender || 'masculino';
  }
  if (elements.birthDate) {
    elements.birthDate.value = formatDateInput(state.user.birthDate);
  }
  if (elements.isMember) {
    elements.isMember.checked = state.user.isMember === true;
  }
  if (elements.membershipNumber) {
    elements.membershipNumber.value = state.user.membershipNumber || '';
  }
  if (elements.photo) {
    elements.photo.value = '';
  }
  if (elements.notes) {
    elements.notes.value = state.user.notes || '';
  }
  if (elements.password) {
    elements.password.value = '';
  }
  if (elements.notifyMatchRequests) {
    elements.notifyMatchRequests.checked = state.user.notifyMatchRequests !== false;
  }
  if (elements.notifyMatchResults) {
    elements.notifyMatchResults.checked = state.user.notifyMatchResults !== false;
  }

  toggleMembershipField(profileIsMemberCheckbox, profileMembershipWrapper, profileMembershipNumberInput, {
    clearWhenDisabled: !state.user.isMember,
  });
}

function toggleProfileForm(show) {
  if (!profileForm) return;

  if (show) {
    fillProfileForm();
    profileForm.hidden = false;
    if (profileEditButton) {
      profileEditButton.hidden = true;
    }
    if (accountOverview) {
      accountOverview.hidden = true;
    }
    setStatusMessage(profileStatus, '', '');
    return;
  }

  profileForm.hidden = true;
  if (profileEditButton) {
    profileEditButton.hidden = false;
  }
  if (accountOverview) {
    accountOverview.hidden = false;
  }
  profileForm.reset();
  if (profileForm.elements?.password) {
    profileForm.elements.password.value = '';
  }
  toggleMembershipField(profileIsMemberCheckbox, profileMembershipWrapper, profileMembershipNumberInput, {
    clearWhenDisabled: true,
  });
  setStatusMessage(profileStatus, '', '');
}

function updateAppSwitcherButtons() {
  if (!appSwitcherButtons.length) return;

  let activeIndex = 0;

  appSwitcherButtons.forEach((button, index) => {
    const isActive = button.dataset.app === state.selectedApp;
    button.classList.toggle('app-switcher__button--active', isActive);
    button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
    if (isActive) {
      activeIndex = index;
    }
  });

  if (appSwitcher) {
    appSwitcher.style.setProperty('--active-index', activeIndex);
  }
}

function handleAppSwitcherClick(event) {
  const button = event.target.closest('.app-switcher__button');
  if (!button) return;

  const { app } = button.dataset;
  if (!app || app === state.selectedApp) {
    return;
  }

  if (app === 'padel') {
    window.alert('La aplicación de Pádel estará disponible próximamente.');
    updateAppSwitcherButtons();
    return;
  }

  state.selectedApp = app;
  updateAppSwitcherButtons();
}

function resetData() {
  toggleProfileForm(false);
  state.selectedApp = 'tennis';
  updateAppSwitcherButtons();
  state.accountSummary = null;
  state.accountSummaryLoading = false;
  renderAccountSummary(null);
  if (accountDashboardStatus) {
    setStatusMessage(accountDashboardStatus, '', '');
  }
  state.enrollments.clear();
  state.myMatches = [];
  state.upcomingMatches = [];
  state.pendingApprovalMatches = [];
  state.completedMatches = [];
  state.leagues = [];
  state.categoryFilters = { league: '' };
  state.globalOverview = null;
  state.leagueDashboard = null;
  state.leagueDashboardPlayersPage = 1;
  if (state.leagueDetails instanceof Map) {
    state.leagueDetails.clear();
  } else {
    state.leagueDetails = new Map();
  }
  if (state.leaguePayments instanceof Map) {
    state.leaguePayments.clear();
  } else {
    state.leaguePayments = new Map();
  }
  state.leaguePaymentFilters = {
    league: '',
    search: '',
  };
  state.leaguePaymentsLoading = false;
  state.tournamentDashboard = null;
  state.tournaments = [];
  state.tournamentDetails = new Map();
  state.selectedTournamentId = '';
  state.selectedTournamentCategoriesId = '';
  state.selectedEnrollmentTournamentId = '';
  state.selectedEnrollmentCategoryId = TOURNAMENT_ENROLLMENT_ALL_OPTION;
  state.selectedMatchTournamentId = '';
  state.selectedMatchCategoryId = '';
  state.selectedDoublesTournamentId = '';
  if (state.tournamentDoubles instanceof Map) {
    state.tournamentDoubles.clear();
  } else {
    state.tournamentDoubles = new Map();
  }
  if (state.tournamentDoublesPairs instanceof Map) {
    state.tournamentDoublesPairs.clear();
  } else {
    state.tournamentDoublesPairs = new Map();
  }
  if (state.tournamentEnrollments instanceof Map) {
    state.tournamentEnrollments.clear();
  } else {
    state.tournamentEnrollments = new Map();
  }
  state.tournamentEnrollmentFilters = {
    search: '',
    gender: '',
  };
  if (state.tournamentMatches instanceof Map) {
    state.tournamentMatches.clear();
  } else {
    state.tournamentMatches = new Map();
  }
  if (state.tournamentOrderOfPlayDays instanceof Map) {
    state.tournamentOrderOfPlayDays.clear();
  } else {
    state.tournamentOrderOfPlayDays = new Map();
  }
  state.selectedOrderOfPlayDay = '';
  updateTournamentOrderOfPlayControls();
  if (state.tournamentPayments instanceof Map) {
    state.tournamentPayments.clear();
  } else {
    state.tournamentPayments = new Map();
  }
  state.tournamentPaymentFilters = {
    tournament: '',
    search: '',
  };
  state.tournamentPaymentsLoading = false;
  state.courtReservations = [];
  state.courtAvailability = [];
  state.courtAvailabilityCourt = '';
  state.courtAvailabilityDate = new Date();
  state.playerCourtCalendarDate = new Date();
  state.courtAdminSchedule = [];
  state.courtAdminBlocks = [];
  state.courtCalendarEvents = [];
  state.courtCalendarViewMode = 'month';
  state.courtBlocks = [];
  state.courtCalendarDate = new Date();
  state.reservationPlayers = [];
  state.generalChatMessages = [];
  state.noticeUnreadCount = 0;
  updateCategoryControlsAvailability();
  if (categoryLeagueFilter) {
    categoryLeagueFilter.innerHTML = '';
    categoryLeagueFilter.value = '';
    categoryLeagueFilter.disabled = true;
  }
  if (leaguesList) {
    leaguesList.innerHTML =
      '<li class="empty-state">Inicia sesión para revisar las ligas disponibles.</li>';
  }
  categoriesList.innerHTML = '<li class="empty-state">Inicia sesión para ver las categorías.</li>';
  if (tournamentsList) {
    tournamentsList.innerHTML =
      '<li class="empty-state">Inicia sesión para consultar los torneos disponibles.</li>';
  }
  if (tournamentDetailTitle) {
    tournamentDetailTitle.textContent = 'Detalle del torneo';
  }
  if (tournamentDetailSubtitle) {
    tournamentDetailSubtitle.textContent = 'Selecciona un torneo para ver la información ampliada.';
  }
  if (tournamentDetailBody) {
    tournamentDetailBody.innerHTML =
      '<p class="empty-state">Inicia sesión para conocer la información de los torneos.</p>';
  }
  if (tournamentCategoriesList) {
    tournamentCategoriesList.innerHTML = '';
  }
  if (tournamentCategoriesEmpty) {
    tournamentCategoriesEmpty.hidden = false;
    tournamentCategoriesEmpty.textContent = 'Inicia sesión para revisar las categorías de los torneos.';
  }
  if (tournamentCategoryTournamentSelect) {
    tournamentCategoryTournamentSelect.innerHTML = '';
    tournamentCategoryTournamentSelect.disabled = true;
  }
  if (tournamentEnrollmentTournamentSelect) {
    tournamentEnrollmentTournamentSelect.innerHTML = '';
    tournamentEnrollmentTournamentSelect.disabled = true;
  }
  if (tournamentEnrollmentCategorySelect) {
    tournamentEnrollmentCategorySelect.innerHTML = '';
    tournamentEnrollmentCategorySelect.disabled = true;
  }
  if (tournamentEnrollmentCount) {
    tournamentEnrollmentCount.textContent = '0';
  }
  if (tournamentEnrollmentSearch) {
    tournamentEnrollmentSearch.value = '';
    tournamentEnrollmentSearch.disabled = true;
  }
  if (tournamentEnrollmentGender) {
    tournamentEnrollmentGender.value = '';
    tournamentEnrollmentGender.disabled = true;
  }
  if (tournamentEnrollmentList) {
    tournamentEnrollmentList.innerHTML = '';
  }
  if (tournamentEnrollmentEmpty) {
    tournamentEnrollmentEmpty.hidden = false;
    tournamentEnrollmentEmpty.textContent = 'Selecciona un torneo para consultar los jugadores inscritos.';
  }
  if (tournamentDoublesTournamentSelect) {
    tournamentDoublesTournamentSelect.innerHTML = '';
    tournamentDoublesTournamentSelect.disabled = true;
  }
  if (tournamentDoublesContainer) {
    tournamentDoublesContainer.innerHTML = '';
  }
  if (tournamentDoublesEmpty) {
    tournamentDoublesEmpty.hidden = false;
    tournamentDoublesEmpty.textContent = 'Selecciona un torneo para ver las inscripciones de dobles.';
  }
  if (tournamentMatchTournamentSelect) {
    tournamentMatchTournamentSelect.innerHTML = '';
    tournamentMatchTournamentSelect.disabled = true;
  }
  if (tournamentMatchCategorySelect) {
    tournamentMatchCategorySelect.innerHTML = '';
    tournamentMatchCategorySelect.disabled = true;
  }
  if (tournamentMatchesList) {
    tournamentMatchesList.innerHTML = '';
  }
  if (tournamentMatchesEmpty) {
    tournamentMatchesEmpty.hidden = false;
    tournamentMatchesEmpty.textContent = 'Selecciona un torneo para revisar sus partidos.';
  }
  if (tournamentPaymentsTournamentSelect) {
    tournamentPaymentsTournamentSelect.innerHTML =
      '<option value="">Selecciona un torneo con cuotas</option>';
    tournamentPaymentsTournamentSelect.disabled = true;
  }
  if (tournamentPaymentsSearchInput) {
    tournamentPaymentsSearchInput.value = '';
    tournamentPaymentsSearchInput.disabled = true;
  }
  resetTournamentPaymentGroups();
  if (tournamentPaymentsCount) {
    tournamentPaymentsCount.textContent = '0';
  }
    if (tournamentPaymentsEmpty) {
      tournamentPaymentsEmpty.hidden = false;
      tournamentPaymentsEmpty.textContent =
        'Inicia sesión para gestionar los pagos de inscripción de los torneos.';
    }
    updateTournamentPaymentFeeIndicator(null);
    setStatusMessage(tournamentPaymentsStatusMessage, '', '');
    notificationsList.innerHTML = '<li class="empty-state">Inicia sesión para ver tus notificaciones.</li>';
  upcomingList.innerHTML = '<li class="empty-state">Inicia sesión para consultar el calendario.</li>';
  myMatchesList.innerHTML = '<li class="empty-state">Inicia sesión para consultar tus partidos.</li>';
  updateMatchesMenuBadge(0);
  updateNoticesMenuBadge(0);
  if (pendingApprovalsList) {
    pendingApprovalsList.innerHTML =
      '<li class="empty-state">Inicia sesión para consultar los resultados pendientes.</li>';
  }
  if (courtReservationList) {
    courtReservationList.innerHTML =
      '<li class="empty-state">Inicia sesión para gestionar tus reservas.</li>';
  }
  if (courtAvailabilityList) {
    courtAvailabilityList.innerHTML =
      '<li class="empty-state">Inicia sesión para consultar la disponibilidad de pistas.</li>';
  }
  if (courtAvailabilityEmpty) {
    courtAvailabilityEmpty.hidden = false;
  }
  if (courtAdminSchedule) {
    courtAdminSchedule.innerHTML =
      '<p class="meta">Inicia sesión con una cuenta administradora para ver el detalle de reservas.</p>';
  }
  if (courtAdminEmpty) {
    courtAdminEmpty.hidden = false;
  }
  if (courtCalendarContainer) {
    courtCalendarContainer.innerHTML =
      '<p class="meta">Inicia sesión con una cuenta autorizada para revisar el calendario de pistas.</p>';
  }
  if (courtCalendarLabel) {
    courtCalendarLabel.textContent = '';
  }
  if (courtCalendarStatus) {
    setStatusMessage(courtCalendarStatus, '', '');
  }
  if (courtBlockForm) {
    courtBlockForm.reset();
    setCourtBlockDefaultRange();
  }
  if (courtBlockStatus) {
    setStatusMessage(courtBlockStatus, '', '');
  }
  if (courtBlocksList) {
    courtBlocksList.innerHTML =
      '<li class="empty-state">Inicia sesión con una cuenta autorizada para gestionar bloqueos.</li>';
  }
  if (courtBlocksEmpty) {
    courtBlocksEmpty.hidden = true;
  }
  if (courtReservationParticipantsContainer) {
    courtReservationParticipantsContainer.innerHTML = '';
    courtReservationParticipantsContainer.hidden = true;
  }
  if (courtReservationParticipantsHint) {
    courtReservationParticipantsHint.hidden = true;
    courtReservationParticipantsHint.textContent = defaultCourtReservationParticipantsHint;
  }
  if (completedMatchesList) {
    completedMatchesList.innerHTML =
      '<li class="empty-state">Inicia sesión para revisar los partidos disputados.</li>';
  }
  state.club = null;
  populateAdminMatchCourtOptions('');
  renderRules();
  if (clubNameDisplay) {
    clubNameDisplay.textContent = APP_BRAND_NAME;
  }
  if (clubSloganDisplay) {
    clubSloganDisplay.textContent = APP_BRAND_SLOGAN;
  }
  if (clubDescription) {
    clubDescription.textContent = '';
  }
  if (clubAddress) {
    clubAddress.textContent = '—';
  }
  if (clubContact) {
    clubContact.textContent = '—';
  }
  if (clubWebsite) {
    clubWebsite.textContent = '—';
  }
  if (clubScheduleList) {
    clubScheduleList.innerHTML = '';
  }
  if (clubScheduleEmpty) {
    clubScheduleEmpty.hidden = false;
  }
  if (clubCourtsList) {
    clubCourtsList.innerHTML = '';
  }
  if (clubCourtsEmpty) {
    clubCourtsEmpty.hidden = false;
  }
  if (clubFacilitiesList) {
    clubFacilitiesList.innerHTML = '';
  }
  if (clubFacilitiesEmpty) {
    clubFacilitiesEmpty.hidden = false;
  }
  if (clubStatus) {
    setStatusMessage(clubStatus, '', '');
  }
  if (topbarLogo) {
    topbarLogo.src = 'assets/club-logo.png';
  }
  if (clubNameHeading) {
    clubNameHeading.textContent = APP_BRAND_NAME;
  }
  if (clubSloganHeading) {
    clubSloganHeading.textContent = APP_BRAND_SLOGAN;
  }
  if (mobileTopbarTitle) {
    mobileTopbarTitle.textContent = APP_BRAND_NAME;
  }
  if (clubLogoDisplay) {
    clubLogoDisplay.style.backgroundImage = '';
  }
  if (mobileTopbarLogo) {
    mobileTopbarLogo.src = 'assets/club-logo.svg';
  }
  state.rankingsByCategory.clear();
  state.rankingsLoading = false;
  state.selectedCategoryId = null;
  if (rankingCategoryList) {
    rankingCategoryList.innerHTML = '';
  }
  if (rankingEmpty) {
    rankingEmpty.hidden = false;
    rankingEmpty.textContent = 'Inicia sesión para consultar los rankings disponibles.';
  }
  setRankingStatusMessage('', '');
  if (globalLeaguesList) {
    globalLeaguesList.innerHTML = '<li class="empty-state">Inicia sesión para ver las ligas activas.</li>';
  }
  if (globalTournamentsList) {
    globalTournamentsList.innerHTML = '<li class="empty-state">Inicia sesión para conocer los torneos disponibles.</li>';
  }
  if (globalUpcomingMatchesList) {
    globalUpcomingMatchesList.innerHTML = '<li class="empty-state">Inicia sesión para ver los próximos partidos.</li>';
  }
  if (leagueRankingCards) {
    leagueRankingCards.innerHTML = '<p class="empty-state">Inicia sesión para consultar los rankings de liga.</p>';
  }
  if (leagueUpcomingMatchesList) {
    leagueUpcomingMatchesList.innerHTML = '<li class="empty-state">Inicia sesión para ver los partidos de liga.</li>';
  }
  if (tournamentDrawCards) {
    tournamentDrawCards.innerHTML = '<p class="empty-state">Inicia sesión para revisar los cuadros de torneo.</p>';
  }
  if (tournamentUpcomingMatchesList) {
    tournamentUpcomingMatchesList.innerHTML = '<li class="empty-state">Inicia sesión para ver los partidos de torneo.</li>';
  }
  if (generalChatMessagesList) {
    generalChatMessagesList.innerHTML =
      '<li class="empty-state">Inicia sesión para revisar los avisos del club.</li>';
  }
  if (generalChatInput) {
    generalChatInput.value = '';
  }
  if (globalLeaguesCount) {
    globalLeaguesCount.textContent = '0';
  }
  if (globalTournamentsCount) {
    globalTournamentsCount.textContent = '0';
  }
  if (globalCategoriesCount) {
    globalCategoriesCount.textContent = '0';
  }
  if (globalCourtsCount) {
    globalCourtsCount.textContent = '0';
  }
  if (leagueMetricPlayers) {
    leagueMetricPlayers.textContent = '0';
  }
  if (leagueMetricCategories) {
    leagueMetricCategories.textContent = '0';
  }
  if (leagueMetricUpcoming) {
    leagueMetricUpcoming.textContent = '0';
  }
  if (tournamentMetricActive) {
    tournamentMetricActive.textContent = '0';
  }
  if (tournamentMetricCategories) {
    tournamentMetricCategories.textContent = '0';
  }
  if (tournamentMetricUpcoming) {
    tournamentMetricUpcoming.textContent = '0';
  }
  updateNotificationCounts(0);
  if (calendarContainer) {
    calendarContainer.innerHTML = '<div class="calendar-empty">Inicia sesión para ver el calendario.</div>';
  }
  if (calendarLabel) {
    calendarLabel.textContent = '';
  }
  if (globalCalendarContainer) {
    globalCalendarContainer.innerHTML =
      '<div class="calendar-empty">Inicia sesión para ver el calendario general.</div>';
  }
  if (globalCalendarLabel) {
    globalCalendarLabel.textContent = '';
  }
  if (leaguePlayersList) {
    leaguePlayersList.innerHTML = '';
  }
  if (leaguePlayersEmpty) {
    leaguePlayersEmpty.hidden = false;
    leaguePlayersEmpty.textContent = 'Inicia sesión para consultar los jugadores inscritos.';
  }
  if (leaguePlayersCount) {
    leaguePlayersCount.textContent = '0';
  }
  if (leaguePlayersLeagueSelect) {
    leaguePlayersLeagueSelect.innerHTML = '<option value="">Selecciona una liga</option>';
    leaguePlayersLeagueSelect.disabled = true;
  }
  if (leaguePlayersCategorySelect) {
    leaguePlayersCategorySelect.innerHTML = '<option value="">Todas las categorías</option>';
    leaguePlayersCategorySelect.disabled = true;
  }
  if (leaguePlayersSearch) {
    leaguePlayersSearch.value = '';
    leaguePlayersSearch.disabled = true;
  }
  if (leaguePlayersGender) {
    leaguePlayersGender.value = '';
    leaguePlayersGender.disabled = true;
  }
  state.leaguePlayersFilters = {
    league: '',
    category: '',
    search: '',
    gender: '',
  };
  leaguePlayersRequestToken = 0;
  state.leaguePlayersLoading = false;
  updateLeaguePaymentControls({ resetSelection: true });
  resetLeaguePaymentGroups();
  if (leaguePaymentsCount) {
    leaguePaymentsCount.textContent = '0';
  }
  if (leaguePaymentsEmpty) {
    leaguePaymentsEmpty.hidden = false;
    leaguePaymentsEmpty.textContent = 'Inicia sesión para gestionar los pagos de inscripción.';
  }
  setStatusMessage(leaguePaymentsStatusMessage, '', '');
  if (playerDirectoryList) {
    playerDirectoryList.innerHTML = '';
  }
  if (playerDirectoryEmpty) {
    playerDirectoryEmpty.hidden = false;
    playerDirectoryEmpty.textContent = 'Inicia sesión para ver el directorio de usuarios.';
  }
  if (playerDirectoryCount) {
    playerDirectoryCount.textContent = '0';
  }
  if (playerDirectorySearch) {
    playerDirectorySearch.value = '';
  }
  if (playerDirectoryGender) {
    playerDirectoryGender.value = '';
  }
  if (playerDirectoryRole) {
    playerDirectoryRole.value = '';
  }
  if (playerDirectoryCategory) {
    playerDirectoryCategory.value = '';
  }
  state.players = [];
  state.playerDirectoryFilters = {
    search: '',
    gender: '',
    role: '',
    category: '',
  };
  resetAdminCategoryForm();
  resetAdminPlayerForm();
  resetAdminMatchForm();
  if (adminCategoryList) {
    adminCategoryList.innerHTML =
      '<li class="empty-state">Inicia sesión para gestionar las categorías.</li>';
  }
  if (adminPlayerList) {
    adminPlayerList.innerHTML =
      '<li class="empty-state">Inicia sesión para gestionar los usuarios.</li>';
  }
  if (adminMatchList) {
    adminMatchList.innerHTML =
      '<li class="empty-state">Inicia sesión para gestionar los partidos.</li>';
  }
  if (accountFullName) {
    accountFullName.textContent = '—';
  }
  if (accountEmail) {
    accountEmail.textContent = '—';
  }
  if (accountPhone) {
    accountPhone.textContent = '—';
  }
  if (accountMembershipStatus) {
    accountMembershipStatus.textContent = 'No es socio';
  }
  if (accountMembershipNumber) {
    accountMembershipNumber.textContent = '—';
  }
  if (accountMembershipNumberRow) {
    accountMembershipNumberRow.hidden = true;
  }
  if (accountBirthDate) {
    accountBirthDate.textContent = '—';
  }
  if (accountSchedule) {
    accountSchedule.textContent = '—';
  }
  if (accountNotes) {
    accountNotes.textContent = 'Sin notas registradas.';
  }
  if (profileAvatar) {
    profileAvatar.style.backgroundImage = '';
  }
  if (accountPhoto) {
    accountPhoto.style.backgroundImage = '';
  }
  setStatusMessage(adminStatus, '', '');
  setStatusMessage(adminMatchStatusMessage, '', '');
  if (adminEnrollmentForm) {
    adminEnrollmentForm.reset();
  }
  if (adminEnrollmentList) {
    adminEnrollmentList.innerHTML =
      '<li class="empty-state">Inicia sesión para gestionar las inscripciones.</li>';
  }
  setStatusMessage(adminEnrollmentStatus, '', '');
  setStatusMessage(demoModeStatus, '', '');
  resetDemoModeResults();
  state.push.enabled = false;
  state.push.subscriptionEndpoint = null;
  state.push.publicKey = null;
  state.push.serverEnabled = false;
  state.push.configLoaded = false;
  state.push.permission = state.push.supported && typeof Notification !== 'undefined' ? Notification.permission : 'default';
  updatePushSettingsUI();
  updateTournamentActionAvailability();
}

function applySetupState() {
  const roleInputs = registerForm
    ? Array.from(registerForm.querySelectorAll('input[name="roles"]'))
    : [];
  if (!roleInputs.length) return;

  if (state.needsSetup) {
    authDescription.textContent =
      'No hay administradores configurados todavía. Crea el usuario inicial para activar la aplicación.';
    roleInputs.forEach((input) => {
      const isAdminOption = input.value === 'admin';
      const wrapper = input.closest('.checkbox-option');
      input.checked = isAdminOption;
      input.disabled = true;
      if (wrapper) {
        wrapper.hidden = false;
      }
    });
    registerRoleWrapper.dataset.locked = 'true';
    switchTab('register');
    return;
  }

  authDescription.textContent = 'Inicia sesión con tu cuenta o regístrate.';
  roleInputs.forEach((input) => {
    const isPlayerOption = input.value === 'player';
    const isAdminOption = input.value === 'admin';
    const isCourtManagerOption = input.value === 'court_manager';
    const isRestrictedOption = isAdminOption || isCourtManagerOption;
    input.disabled = isRestrictedOption;
    input.checked = isPlayerOption;
    const wrapper = input.closest('.checkbox-option');
    if (wrapper) {
      wrapper.hidden = isRestrictedOption;
    }
  });
  registerRoleWrapper.dataset.locked = 'false';
}

function isAdmin() {
  return entityHasRole(state.user, 'admin');
}

function isCourtManager() {
  return entityHasRole(state.user, 'court_manager');
}

function hasCourtManagementAccess() {
  return isAdmin() || isCourtManager();
}

function updateAuthUI() {
  const loggedIn = Boolean(state.token && state.user);
  authView.hidden = loggedIn;
  authView?.classList.toggle('is-hidden', loggedIn);
  appView.hidden = !loggedIn;
  if (appMenu) {
    appMenu.hidden = !loggedIn;
  }
  if (appSidebar) {
    appSidebar.hidden = !loggedIn;
  }

  if (!loggedIn) {
    closeMobileMenu();
    resetData();
    showGlobalMessage('Inicia sesión para acceder al panel de la liga.');
    if (appSections.length) {
      appSections.forEach((section) => {
        section.hidden = true;
      });
    }
    state.activeSection = 'section-dashboard';
    setActiveMenu(null);
  } else {
    showGlobalMessage('');
    updateProfileCard();
    state.activeSection = state.activeSection || 'section-dashboard';
    showSection(state.activeSection);
  }

  updateAdminMenuVisibility();
  updateCourtManagerMenuVisibility();
  applyCourtManagerMenuRestrictions();
  updatePushSettingsUI();
}

function formatDate(value) {
  if (!value) return 'Por confirmar';
  try {
    return new Intl.DateTimeFormat('es-ES', {
      dateStyle: 'medium',
      timeStyle: 'short',
    }).format(new Date(value));
  } catch (error) {
    return value;
  }
}

function formatShortDate(value) {
  if (!value) return '—';
  try {
    return new Intl.DateTimeFormat('es-ES', {
      day: '2-digit',
      month: '2-digit',
      year: 'numeric',
    }).format(new Date(value));
  } catch (error) {
    return '—';
  }
}

function formatCurrencyValue(amount, currency = 'EUR') {
  const numericAmount = Number(amount);
  if (!Number.isFinite(numericAmount)) {
    return '';
  }

  let resolvedCurrency = typeof currency === 'string' ? currency.trim().toUpperCase() : 'EUR';
  if (!resolvedCurrency) {
    resolvedCurrency = 'EUR';
  }

  try {
    return new Intl.NumberFormat('es-ES', {
      style: 'currency',
      currency: resolvedCurrency,
      maximumFractionDigits: 2,
    }).format(numericAmount);
  } catch (error) {
    return `${numericAmount.toFixed(2)} ${resolvedCurrency}`.trim();
  }
}

function formatCurrencyDisplay(amount) {
  const formatted = formatCurrencyValue(amount, DEFAULT_LEAGUE_CURRENCY);
  if (formatted) {
    return formatted;
  }

  const numeric = Number(amount) || 0;
  return `${numeric.toFixed(2)} ${DEFAULT_LEAGUE_CURRENCY}`;
}

function toggleMembershipField(checkbox, wrapper, input, { clearWhenDisabled = false } = {}) {
  if (!wrapper || !checkbox) {
    return;
  }

  const isMember = checkbox.checked;
  wrapper.hidden = !isMember;

  if (input) {
    input.disabled = !isMember;
    if (!isMember && clearWhenDisabled) {
      input.value = '';
    }
  }
}

function populateAccountList(listElement, emptyElement, items, renderItem) {
  if (!listElement) {
    return;
  }

  listElement.innerHTML = '';
  const entries = Array.isArray(items)
    ? items
        .map((item) => (typeof renderItem === 'function' ? renderItem(item) : null))
        .filter(Boolean)
    : [];

  if (!entries.length) {
    listElement.hidden = true;
    if (emptyElement) {
      emptyElement.hidden = false;
    }
    return;
  }

  const fragment = document.createDocumentFragment();
  entries.forEach((entry) => {
    fragment.appendChild(entry);
  });

  listElement.hidden = false;
  listElement.appendChild(fragment);
  if (emptyElement) {
    emptyElement.hidden = true;
  }
}

function createAccountEnrollmentItem(enrollment) {
  if (!enrollment) {
    return null;
  }

  const item = document.createElement('li');
  const content = document.createElement('div');
  content.className = 'list-item__content';

  const leagueName = enrollment.league?.name || 'Liga';
  const leagueYear = enrollment.league?.year;
  const title = document.createElement('strong');
  title.textContent = leagueYear ? `${leagueName} · ${leagueYear}` : leagueName;
  content.appendChild(title);

  if (enrollment.category?.name) {
    const categorySpan = document.createElement('span');
    categorySpan.textContent = `Categoría: ${enrollment.category.name}`;
    content.appendChild(categorySpan);
  }

  item.appendChild(content);

  const meta = document.createElement('div');
  meta.className = 'meta';
  if (enrollment.joinedAt) {
    meta.appendChild(document.createElement('span')).textContent = `Inscripción: ${formatShortDate(
      enrollment.joinedAt
    )}`;
  }

  item.appendChild(meta);
  return item;
}

function createAccountMatchItem(match, { variant = 'upcoming' } = {}) {
  if (!match) {
    return null;
  }

  const item = document.createElement('li');
  const content = document.createElement('div');
  content.className = 'list-item__content';

  const container = match.scope === 'league' ? match.league : match.tournament;
  const titleParts = [];
  if (container?.name) {
    titleParts.push(container.name);
  }
  if (match.category?.name) {
    titleParts.push(match.category.name);
  }

  const title = document.createElement('strong');
  title.textContent = titleParts.length ? titleParts.join(' · ') : 'Partido';
  content.appendChild(title);

  const participants = Array.isArray(match.players)
    ? match.players
        .map((player) => getPlayerDisplayName(player))
        .filter(Boolean)
    : [];
  if (participants.length) {
    const participantsSpan = document.createElement('span');
    participantsSpan.textContent = participants.join(' vs ');
    content.appendChild(participantsSpan);
  }

  item.appendChild(content);

  const meta = document.createElement('div');
  meta.className = 'meta';

  if (match.scheduledAt) {
    meta.appendChild(document.createElement('span')).textContent = formatDate(match.scheduledAt);
  }

  if (match.court) {
    meta.appendChild(document.createElement('span')).textContent = `Pista: ${match.court}`;
  }

  if (match.status) {
    const statusLabel = STATUS_LABELS[match.status] || match.status;
    if (statusLabel) {
      const statusTag = document.createElement('span');
      statusTag.className = 'tag';
      statusTag.textContent = statusLabel;
      meta.appendChild(statusTag);
    }
  }

  if (variant === 'recent') {
    const winnerId = normalizeId(match.result?.winner);
    if (winnerId) {
      let winnerName = '';
      if (Array.isArray(match.players)) {
        const winner = match.players.find((player) => normalizeId(player) === winnerId);
        if (winner) {
          winnerName = getPlayerDisplayName(winner);
        }
      }
      if (winnerName) {
        meta.appendChild(document.createElement('span')).textContent = `Ganador: ${winnerName}`;
      }
    } else if (match.result?.status) {
      const resultLabel = STATUS_LABELS[match.result.status] || match.result.status;
      meta.appendChild(document.createElement('span')).textContent = `Resultado: ${resultLabel}`;
    } else {
      meta.appendChild(document.createElement('span')).textContent = 'Resultado: pendiente';
    }

    const scoreboard = createResultScoreboard(match);
    let scoreSummary = formatMatchScore(match);

    if (!scoreSummary && match.scope === 'tournament' && match.result?.score) {
      const rawScore = match.result.score.trim();
      if (rawScore) {
        scoreSummary = /^marcador:/i.test(rawScore) ? rawScore : `Marcador: ${rawScore}`;
      }
    }

    if (scoreboard) {
      item.appendChild(scoreboard);
    } else if (scoreSummary) {
      const summaryRow = document.createElement('div');
      summaryRow.className = 'meta';
      summaryRow.textContent = scoreSummary;
      item.appendChild(summaryRow);
    }

    if (match.updatedAt) {
      meta.appendChild(document.createElement('span')).textContent = `Actualizado: ${formatShortDate(
        match.updatedAt
      )}`;
    }
  }

  item.appendChild(meta);
  return item;
}

function createAccountPaymentItem(record) {
  if (!record) {
    return null;
  }

  const item = document.createElement('li');
  const content = document.createElement('div');
  content.className = 'list-item__content';

  const titleParts = [];
  if (record.container?.name) {
    titleParts.push(record.container.name);
  }
  if (record.scope === 'league') {
    titleParts.push('Liga');
  } else if (record.scope === 'tournament') {
    titleParts.push('Torneo');
  }

  const title = document.createElement('strong');
  title.textContent = titleParts.length ? titleParts.join(' · ') : 'Pago';
  content.appendChild(title);

  if (record.reference) {
    const referenceSpan = document.createElement('span');
    referenceSpan.textContent = `Referencia: ${record.reference}`;
    content.appendChild(referenceSpan);
  }

  if (record.notes) {
    const notesSpan = document.createElement('span');
    notesSpan.textContent = record.notes;
    content.appendChild(notesSpan);
  }

  item.appendChild(content);

  const meta = document.createElement('div');
  meta.className = 'meta';

  if (record.status) {
    const statusBadge = document.createElement('span');
    statusBadge.className = `tag payment-status payment-status--${record.status}`;
    statusBadge.textContent = PAYMENT_STATUS_LABELS[record.status] || record.status;
    meta.appendChild(statusBadge);
  }

  if (typeof record.amount === 'number' && Number.isFinite(record.amount)) {
    meta.appendChild(document.createElement('span')).textContent = formatCurrencyDisplay(record.amount);
  }

  if (record.paidAt) {
    meta.appendChild(document.createElement('span')).textContent = `Pago: ${formatShortDate(record.paidAt)}`;
  } else if (record.recordedAt) {
    meta.appendChild(document.createElement('span')).textContent = `Registrado: ${formatShortDate(
      record.recordedAt
    )}`;
  }

  if (record.method) {
    meta.appendChild(document.createElement('span')).textContent = `Método: ${record.method}`;
  }

  item.appendChild(meta);
  return item;
}

function renderAccountSummary(summary) {
  state.accountSummary = summary || null;

  if (!accountDashboardCard) {
    return;
  }

  if (accountDashboardRefresh) {
    accountDashboardRefresh.hidden = !state.token;
  }

  if (summary?.user && state.user) {
    const summaryUser = summary.user;
    let updated = false;
    const nextUser = { ...state.user };
    if (typeof summaryUser.fullName === 'string' && summaryUser.fullName && summaryUser.fullName !== nextUser.fullName) {
      nextUser.fullName = summaryUser.fullName;
      updated = true;
    }
    if (typeof summaryUser.email === 'string' && summaryUser.email && summaryUser.email !== nextUser.email) {
      nextUser.email = summaryUser.email;
      updated = true;
    }
    if (typeof summaryUser.phone === 'string' && summaryUser.phone && summaryUser.phone !== nextUser.phone) {
      nextUser.phone = summaryUser.phone;
      updated = true;
    }
    if (typeof summaryUser.isMember === 'boolean' && summaryUser.isMember !== nextUser.isMember) {
      nextUser.isMember = summaryUser.isMember;
      updated = true;
    }
    if (
      summaryUser.membershipNumber !== undefined &&
      summaryUser.membershipNumber !== nextUser.membershipNumber
    ) {
      nextUser.membershipNumber = summaryUser.membershipNumber;
      updated = true;
    }
    if (
      typeof summaryUser.membershipNumberVerified === 'boolean' &&
      summaryUser.membershipNumberVerified !== nextUser.membershipNumberVerified
    ) {
      nextUser.membershipNumberVerified = summaryUser.membershipNumberVerified;
      updated = true;
    }

    if (updated) {
      state.user = nextUser;
      persistSession();
      updateProfileCard();
    }
  }

  if (!summary) {
    if (accountDashboard) {
      accountDashboard.hidden = true;
    }
    if (accountDashboardEmpty) {
      accountDashboardEmpty.hidden = false;
      accountDashboardEmpty.textContent = state.token
        ? 'Tus inscripciones, partidos y pagos aparecerán aquí en cuanto participes en la liga.'
        : 'Inicia sesión para consultar tu actividad personal.';
    }

    if (accountEnrollmentsCount) accountEnrollmentsCount.textContent = '0';
    if (accountUpcomingCount) accountUpcomingCount.textContent = '0';
    if (accountRecentCount) accountRecentCount.textContent = '0';
    if (accountPaymentsCount) accountPaymentsCount.textContent = '0';
    if (accountPaymentsPaid) accountPaymentsPaid.textContent = formatCurrencyDisplay(0);
    if (accountPaymentsPending) accountPaymentsPending.textContent = formatCurrencyDisplay(0);
    if (accountPaymentsTotal) accountPaymentsTotal.textContent = formatCurrencyDisplay(0);

    populateAccountList(accountEnrollmentsList, accountEnrollmentsEmpty, [], () => null);
    populateAccountList(accountUpcomingList, accountUpcomingEmpty, [], () => null);
    populateAccountList(accountRecentList, accountRecentEmpty, [], () => null);
    populateAccountList(accountPaymentsList, accountPaymentsEmpty, [], () => null);
    return;
  }

  if (accountDashboard) {
    accountDashboard.hidden = false;
  }
  if (accountDashboardEmpty) {
    accountDashboardEmpty.hidden = true;
  }

  const enrollments = Array.isArray(summary.enrollments) ? summary.enrollments : [];
  const upcomingMatches = Array.isArray(summary.matches?.upcoming) ? summary.matches.upcoming : [];
  const recentMatches = Array.isArray(summary.matches?.recent) ? summary.matches.recent : [];
  const paymentRecords = Array.isArray(summary.payments?.records) ? summary.payments.records : [];
  const totals = summary.payments?.totals || { paid: 0, pending: 0, total: 0 };

  if (accountEnrollmentsCount) accountEnrollmentsCount.textContent = enrollments.length.toString();
  if (accountUpcomingCount) accountUpcomingCount.textContent = upcomingMatches.length.toString();
  if (accountRecentCount) accountRecentCount.textContent = recentMatches.length.toString();
  if (accountPaymentsCount) accountPaymentsCount.textContent = paymentRecords.length.toString();
  if (accountPaymentsPaid) accountPaymentsPaid.textContent = formatCurrencyDisplay(totals.paid);
  if (accountPaymentsPending) accountPaymentsPending.textContent = formatCurrencyDisplay(totals.pending);
  if (accountPaymentsTotal) accountPaymentsTotal.textContent = formatCurrencyDisplay(totals.total);

  populateAccountList(accountEnrollmentsList, accountEnrollmentsEmpty, enrollments, createAccountEnrollmentItem);
  populateAccountList(accountUpcomingList, accountUpcomingEmpty, upcomingMatches, (match) =>
    createAccountMatchItem(match, { variant: 'upcoming' })
  );
  populateAccountList(accountRecentList, accountRecentEmpty, recentMatches, (match) =>
    createAccountMatchItem(match, { variant: 'recent' })
  );
  populateAccountList(accountPaymentsList, accountPaymentsEmpty, paymentRecords, createAccountPaymentItem);
}

async function loadAccountSummary({ force = true } = {}) {
  if (!state.token) {
    renderAccountSummary(null);
    return null;
  }

  if (!force && state.accountSummary) {
    renderAccountSummary(state.accountSummary);
    return state.accountSummary;
  }

  if (state.accountSummaryLoading) {
    return state.accountSummary;
  }

  state.accountSummaryLoading = true;
  if (accountDashboardStatus) {
    setStatusMessage(accountDashboardStatus, 'info', 'Cargando resumen personal...');
  }
  if (accountDashboardRefresh) {
    accountDashboardRefresh.disabled = true;
  }

  try {
    const summary = await request('/account/summary');
    renderAccountSummary(summary);
    if (accountDashboardStatus) {
      setStatusMessage(accountDashboardStatus, '', '');
    }
    return summary;
  } catch (error) {
    console.warn('No se pudo cargar el resumen de cuenta', error);
    if (accountDashboardStatus) {
      setStatusMessage(accountDashboardStatus, 'error', error.message);
    }
    if (!state.accountSummary) {
      renderAccountSummary(null);
    }
    return null;
  } finally {
    state.accountSummaryLoading = false;
    if (accountDashboardRefresh) {
      accountDashboardRefresh.disabled = false;
    }
  }
}

function formatTournamentStatusLabel(status) {
  return TOURNAMENT_STATUS_LABELS[status] || 'Sin estado';
}

function formatTournamentCategoryStatusLabel(status) {
  return TOURNAMENT_CATEGORY_STATUS_LABELS[status] || 'Sin estado';
}

function formatTournamentEnrollmentStatusLabel(status) {
  return TOURNAMENT_ENROLLMENT_STATUS_LABELS[status] || 'Sin estado';
}

function formatTournamentMatchStatusLabel(status) {
  return TOURNAMENT_MATCH_STATUS_LABELS[status] || 'Sin estado';
}

function formatTournamentResultStatusLabel(status) {
  return TOURNAMENT_RESULT_STATUS_LABELS[status] || 'Sin estado';
}

function formatTournamentDateRange(tournament) {
  if (!tournament) {
    return 'Fechas por confirmar';
  }

  const { startDate, endDate } = tournament;
  const start = startDate ? formatShortDate(startDate) : '';
  const end = endDate ? formatShortDate(endDate) : '';

  if (start && end) {
    return `${start} – ${end}`;
  }
  if (start) {
    return `Inicio: ${start}`;
  }
  if (end) {
    return `Fin: ${end}`;
  }
  return 'Fechas por confirmar';
}

function getMatchExpirationDate(match) {
  if (!match) return null;

  if (match.expiresAt) {
    const expirationDate = new Date(match.expiresAt);
    if (!Number.isNaN(expirationDate.getTime())) {
      return expirationDate;
    }
  }

  if (match.createdAt) {
    const createdAt = new Date(match.createdAt);
    if (!Number.isNaN(createdAt.getTime())) {
      return new Date(createdAt.getTime() + MATCH_EXPIRATION_DAYS * DAY_IN_MS);
    }
  }

  return null;
}

function formatExpirationDeadline(date) {
  if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
    return null;
  }

  try {
    return new Intl.DateTimeFormat('es-ES', {
      day: '2-digit',
      month: 'long',
      year: 'numeric',
    }).format(date);
  } catch (error) {
    return null;
  }
}

function getExpirationWarningMessage(match) {
  const deadlineDate = getMatchExpirationDate(match);
  if (!deadlineDate) {
    return null;
  }

  const deadlineLabel = formatExpirationDeadline(deadlineDate);
  if (!deadlineLabel) {
    return null;
  }

  return `Aviso: disponen de ${MATCH_EXPIRATION_DAYS} días desde la generación del partido. Fecha límite: ${deadlineLabel}. Si nadie confirma ni juega antes de esa fecha, el partido no sumará puntos. Si solo un jugador confirma la fecha y la otra parte no responde, se asignará 6-0 6-0 a quien confirmó.`;
}

function formatTime(value) {
  if (!value) return '—';
  try {
    return new Intl.DateTimeFormat('es-ES', {
      hour: '2-digit',
      minute: '2-digit',
    }).format(new Date(value));
  } catch (error) {
    return '—';
  }
}

function formatTimeRangeLabel(start, end) {
  const startLabel = formatTime(start);
  const endLabel = formatTime(end);
  return `${startLabel} – ${endLabel}`;
}

function capitalizeFirstLetter(text) {
  if (!text) {
    return text;
  }
  return `${text.charAt(0).toUpperCase()}${text.slice(1)}`;
}

function formatDateOnly(value, options = {}) {
  try {
    const formatted = new Intl.DateTimeFormat('es-ES', {
      weekday: options.weekday ?? 'long',
      day: 'numeric',
      month: 'long',
    }).format(new Date(value));
    return capitalizeFirstLetter(formatted);
  } catch (error) {
    return value;
  }
}

function formatMonthLabel(date) {
  try {
    return new Intl.DateTimeFormat('es-ES', {
      month: 'long',
      year: 'numeric',
    }).format(date);
  } catch (error) {
    return '';
  }
}

function formatDayLabel(date) {
  try {
    const formatted = new Intl.DateTimeFormat('es-ES', {
      weekday: 'long',
      day: 'numeric',
      month: 'long',
      year: 'numeric',
    }).format(date);
    return capitalizeFirstLetter(formatted);
  } catch (error) {
    return formatDateOnly(date);
  }
}

function startOfDay(date) {
  const copy = new Date(date);
  copy.setHours(0, 0, 0, 0);
  return copy;
}

function startOfWeek(date) {
  const copy = startOfDay(date);
  const day = copy.getDay();
  const diff = (day === 0 ? -6 : 1) - day;
  copy.setDate(copy.getDate() + diff);
  return copy;
}

function addMinutes(date, minutes) {
  const copy = new Date(date);
  copy.setMinutes(copy.getMinutes() + minutes);
  return copy;
}

function addDays(date, days) {
  const copy = new Date(date);
  copy.setDate(copy.getDate() + days);
  return copy;
}

function startOfMonth(date) {
  const copy = new Date(date);
  copy.setDate(1);
  copy.setHours(0, 0, 0, 0);
  return copy;
}

function endOfMonth(date) {
  const end = startOfMonth(date);
  end.setMonth(end.getMonth() + 1);
  return end;
}

function addMonths(date, months) {
  const copy = new Date(date);
  copy.setDate(1);
  copy.setMonth(copy.getMonth() + months);
  return copy;
}

function formatDateInput(value) {
  if (!value) return '';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return '';
  }
  const year = date.getFullYear();
  const month = `${date.getMonth() + 1}`.padStart(2, '0');
  const day = `${date.getDate()}`.padStart(2, '0');
  return `${year}-${month}-${day}`;
}

function roundDateToInterval(date, minutes = CALENDAR_TIME_SLOT_MINUTES, mode = 'ceil') {
  const base = new Date(date);
  if (Number.isNaN(base.getTime())) {
    return new Date(NaN);
  }

  base.setSeconds(0, 0);
  const dayStart = startOfDay(base);
  const minutesFromStart = Math.floor((base.getTime() - dayStart.getTime()) / 60000);
  const firstSlot = COURT_RESERVATION_FIRST_SLOT_MINUTE;
  const lastSlotStart = COURT_RESERVATION_LAST_SLOT_END_MINUTE - minutes;

  if (minutesFromStart <= firstSlot) {
    return new Date(dayStart.getTime() + firstSlot * 60 * 1000);
  }

  const offset = Math.max(0, minutesFromStart - firstSlot);
  const stepCount = mode === 'floor' ? Math.floor(offset / minutes) : Math.ceil(offset / minutes);
  let slotMinutes = firstSlot + stepCount * minutes;

  if (mode === 'ceil' && slotMinutes > lastSlotStart) {
    const nextDay = addDays(dayStart, 1);
    return new Date(nextDay.getTime() + firstSlot * 60 * 1000);
  }

  if (slotMinutes > lastSlotStart) {
    slotMinutes = lastSlotStart;
  }

  if (slotMinutes < firstSlot) {
    slotMinutes = firstSlot;
  }

  return new Date(dayStart.getTime() + slotMinutes * 60 * 1000);
}

function roundDateUpToInterval(date, minutes = CALENDAR_TIME_SLOT_MINUTES) {
  return roundDateToInterval(date, minutes, 'ceil');
}

function formatDateTimeLocal(value) {
  if (!value) return '';
  const date = new Date(value);
  if (Number.isNaN(date.getTime())) {
    return '';
  }
  const datePart = formatDateInput(date);
  const hours = `${date.getHours()}`.padStart(2, '0');
  const minutes = `${date.getMinutes()}`.padStart(2, '0');
  return `${datePart}T${hours}:${minutes}`;
}

function formatTimeInputValue(value) {
  if (!value) return '';
  const date = value instanceof Date ? value : new Date(value);
  if (Number.isNaN(date.getTime())) {
    return '';
  }
  const hours = `${date.getHours()}`.padStart(2, '0');
  const minutes = `${date.getMinutes()}`.padStart(2, '0');
  return `${hours}:${minutes}`;
}

function combineDateAndTime(dateValue, timeValue) {
  if (!dateValue || !timeValue) {
    return null;
  }
  const isoString = `${dateValue}T${timeValue}`;
  const date = new Date(isoString);
  if (Number.isNaN(date.getTime())) {
    return null;
  }
  return date;
}

function getReservationSlotStartsForDate(baseDate = new Date()) {
  const reference = new Date(baseDate);
  if (Number.isNaN(reference.getTime())) {
    return [];
  }

  const dayStart = startOfDay(reference);
  const slots = [];
  const lastSlotStart = COURT_RESERVATION_LAST_SLOT_END_MINUTE - COURT_RESERVATION_DEFAULT_DURATION;
  for (
    let minute = COURT_RESERVATION_FIRST_SLOT_MINUTE;
    minute <= lastSlotStart;
    minute += COURT_RESERVATION_DEFAULT_DURATION
  ) {
    slots.push(addMinutes(dayStart, minute));
  }

  const now = new Date();
  const isToday = startOfDay(now).getTime() === dayStart.getTime();

  if (!isToday) {
    return slots;
  }

  return slots.filter((slot) => slot.getTime() >= now.getTime());
}

function getReservationSlotEnd(start) {
  return addMinutes(start, COURT_RESERVATION_DEFAULT_DURATION);
}

function formatReservationSlotLabel(start) {
  return formatTime(start);
}

function isValidReservationSlotStart(date) {
  if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
    return false;
  }
  const startMinutes = date.getHours() * 60 + date.getMinutes();
  const earliest = COURT_RESERVATION_FIRST_SLOT_MINUTE;
  const latestStart = COURT_RESERVATION_LAST_SLOT_END_MINUTE - COURT_RESERVATION_DEFAULT_DURATION;
  if (startMinutes < earliest || startMinutes > latestStart) {
    return false;
  }
  return (startMinutes - earliest) % COURT_RESERVATION_DEFAULT_DURATION === 0;
}

function populateCourtReservationTimeOptions(reference, selectedValue, options = {}) {
  if (!courtReservationTimeInput) {
    return [];
  }

  let baseDate;
  if (reference instanceof Date) {
    baseDate = new Date(reference);
  } else if (typeof reference === 'string' && reference) {
    baseDate = new Date(`${reference}T00:00:00`);
  } else if (courtReservationDateInput?.value) {
    baseDate = new Date(`${courtReservationDateInput.value}T00:00:00`);
  } else {
    baseDate = new Date();
  }

  if (Number.isNaN(baseDate.getTime())) {
    baseDate = new Date();
  }

  const slots = getReservationSlotStartsForDate(baseDate);
  const resolvedSelected = selectedValue || courtReservationTimeInput.value || '';
  const fragment = document.createDocumentFragment();
  let matchedSelected = false;

  slots.forEach((slot) => {
    const value = formatTimeInputValue(slot);
    const option = new Option(formatReservationSlotLabel(slot), value, false, value === resolvedSelected);
    if (value === resolvedSelected) {
      matchedSelected = true;
    }
    fragment.appendChild(option);
  });

  courtReservationTimeInput.innerHTML = '';

  if (!slots.length) {
    const emptyOption = new Option('Sin horarios disponibles', '', true, true);
    emptyOption.disabled = true;
    fragment.appendChild(emptyOption);
    courtReservationTimeInput.appendChild(fragment);
    courtReservationTimeInput.disabled = true;
    return slots;
  }

  courtReservationTimeInput.disabled = false;
  courtReservationTimeInput.appendChild(fragment);

  if (!matchedSelected && resolvedSelected) {
    const fallbackDate = combineDateAndTime(formatDateInput(baseDate), resolvedSelected);
    if (fallbackDate && !Number.isNaN(fallbackDate.getTime())) {
      const fallbackEnd =
        options.endsAt instanceof Date && !Number.isNaN(options.endsAt.getTime())
          ? options.endsAt
          : getReservationSlotEnd(fallbackDate);
      const fallbackOption = new Option(
        formatTimeRangeLabel(fallbackDate, fallbackEnd),
        resolvedSelected,
        true,
        true
      );
      courtReservationTimeInput.appendChild(fallbackOption);
      matchedSelected = true;
    }
  }

  if (!matchedSelected) {
    courtReservationTimeInput.value = formatTimeInputValue(slots[0]);
  }

  return slots;
}

function hasActiveLeagues() {
  return Array.isArray(state.leagues)
    ? state.leagues.some((league) => league?.status !== 'cerrada')
    : false;
}

function resolveLeague(reference) {
  if (!reference) return null;
  const leagueId = normalizeId(reference);
  if (leagueId) {
    const fromState = state.leagues.find((league) => normalizeId(league) === leagueId);
    if (fromState) {
      return fromState;
    }
  }
  if (typeof reference === 'object') {
    return reference;
  }
  return null;
}

function updateCategoryControlsAvailability() {
  if (!categoryCreateButton) return;
  const enabled = hasActiveLeagues();
  categoryCreateButton.disabled = !enabled;
  categoryCreateButton.title = enabled
    ? ''
    : 'Crea una liga activa para registrar nuevas categorías.';
}

function updateCategoryFilterControls({ renderOnChange = true } = {}) {
  if (!categoryLeagueFilter) return;

  const filters = ensureCategoryFilters();
  const previousValue = filters.league || '';

  categoryLeagueFilter.innerHTML = '';

  const leagues = Array.isArray(state.leagues) ? state.leagues.slice() : [];

  const toChronoTimestamp = (value) => {
    if (!value) {
      return Number.POSITIVE_INFINITY;
    }
    const date = value instanceof Date ? value : new Date(value);
    const time = date.getTime();
    return Number.isFinite(time) ? time : Number.POSITIVE_INFINITY;
  };

  const getLeagueChronoValue = (league) => {
    if (!league || typeof league !== 'object') {
      return Number.POSITIVE_INFINITY;
    }

    const startTimestamp = toChronoTimestamp(league.startDate);
    if (Number.isFinite(startTimestamp)) {
      return startTimestamp;
    }

    const numericYear = Number(league.year);
    if (Number.isFinite(numericYear)) {
      const normalizedYear = Math.trunc(numericYear);
      const yearDate = new Date(normalizedYear, 0, 1);
      const yearTimestamp = yearDate.getTime();
      if (Number.isFinite(yearTimestamp)) {
        return yearTimestamp;
      }
    }

    const createdTimestamp = toChronoTimestamp(league.createdAt);
    if (Number.isFinite(createdTimestamp)) {
      return createdTimestamp;
    }

    return Number.POSITIVE_INFINITY;
  };

  leagues.sort((a, b) => {
    const chronoDiff = getLeagueChronoValue(a) - getLeagueChronoValue(b);
    if (chronoDiff !== 0) {
      return chronoDiff;
    }
    return formatLeagueOptionLabel(a).localeCompare(formatLeagueOptionLabel(b), 'es', {
      sensitivity: 'base',
    });
  });

  const availableIds = new Set();
  let defaultLeagueId = '';
  leagues.forEach((league) => {
    const leagueId = normalizeId(league);
    if (!leagueId || availableIds.has(leagueId)) {
      return;
    }
    availableIds.add(leagueId);
    if (!defaultLeagueId) {
      defaultLeagueId = leagueId;
    }
    const option = document.createElement('option');
    option.value = leagueId;
    option.textContent = formatLeagueOptionLabel(league);
    categoryLeagueFilter.appendChild(option);
  });

  const nextValue =
    previousValue && availableIds.has(previousValue) ? previousValue : defaultLeagueId;
  const selectionChanged = nextValue !== previousValue;

  filters.league = nextValue;
  categoryLeagueFilter.value = nextValue;
  categoryLeagueFilter.disabled = !availableIds.size;

  if (selectionChanged && renderOnChange) {
    renderCategories(state.categories);
  }
}

function updateRankingFilterControls({ renderOnChange = true } = {}) {
  if (!rankingLeagueFilter) return;

  const filters = ensureRankingFilters();
  const previousValue = filters.league || '';

  rankingLeagueFilter.innerHTML = '';

  const categories = Array.isArray(state.categories) ? state.categories : [];
  const leagueOptions = new Map();

  const toChronoTimestamp = (value) => {
    if (!value) {
      return Number.POSITIVE_INFINITY;
    }

    const date = value instanceof Date ? value : new Date(value);
    const time = date.getTime();
    return Number.isFinite(time) ? time : Number.POSITIVE_INFINITY;
  };

  const compareChronologically = (a, b) => {
    if (!a && !b) {
      return 0;
    }
    if (!a) {
      return 1;
    }
    if (!b) {
      return -1;
    }

    const startDiff = toChronoTimestamp(a.startDate) - toChronoTimestamp(b.startDate);
    if (startDiff !== 0) {
      return startDiff;
    }

    const endDiff = toChronoTimestamp(a.endDate) - toChronoTimestamp(b.endDate);
    if (endDiff !== 0) {
      return endDiff;
    }

    const nameA = typeof a.name === 'string' ? a.name : '';
    const nameB = typeof b.name === 'string' ? b.name : '';
    return nameA.localeCompare(nameB, 'es', { sensitivity: 'base' });
  };

  categories.forEach((category) => {
    const league = resolveLeague(category.league);
    const leagueId = league ? normalizeId(league) : normalizeId(category.league);
    if (!leagueId || leagueOptions.has(leagueId)) {
      return;
    }
    const label = league ? formatLeagueOptionLabel(league) : 'Liga';
    leagueOptions.set(leagueId, { label, league });
  });

  const sortedOptions = Array.from(leagueOptions.entries()).sort((a, b) => {
    const leagueA = a[1].league;
    const leagueB = b[1].league;
    const diff = compareChronologically(leagueA, leagueB);
    if (diff !== 0) {
      return diff;
    }
    return a[1].label.localeCompare(b[1].label, 'es');
  });

  sortedOptions.forEach(([leagueId, data]) => {
    const option = document.createElement('option');
    option.value = leagueId;
    option.textContent = data.label;
    rankingLeagueFilter.appendChild(option);
  });

  const availableIds = new Set(sortedOptions.map(([leagueId]) => leagueId));
  let nextValue = '';
  if (availableIds.has(previousValue)) {
    nextValue = previousValue;
  } else if (sortedOptions.length) {
    nextValue = sortedOptions[0][0];
  }
  const selectionChanged = nextValue !== previousValue;

  filters.league = nextValue;
  rankingLeagueFilter.value = nextValue;
  rankingLeagueFilter.disabled = !availableIds.size;

  if (selectionChanged && renderOnChange) {
    renderRankingSections();
  }
}

function getLeagueCategoryAccessSnapshot(leagueId) {
  if (!leagueId) {
    return {
      categories: [],
      available: [],
      enrolled: [],
      pending: [],
      hasAnyCategory: false,
    };
  }

  const categories = Array.isArray(state.categories) ? state.categories : [];
  const matchingCategories = categories.filter(
    (category) => normalizeId(category.league) === leagueId
  );

  const normalized = matchingCategories.map((category) => ({
    id: normalizeId(category),
    name: category.name || 'Categoría',
    gender: category.gender || '',
    skillLevel: category.skillLevel || '',
    canRequest: Boolean(category.canRequestEnrollment),
    isEnrolled: Boolean(category.isEnrolled),
    hasPendingRequest: Boolean(category.pendingRequestId),
  }));

  return {
    categories: normalized,
    available: normalized.filter((entry) => entry.canRequest),
    enrolled: normalized.filter((entry) => entry.isEnrolled),
    pending: normalized.filter((entry) => entry.hasPendingRequest),
    hasAnyCategory: normalized.length > 0,
  };
}

function renderLeagues(leagues = []) {
  if (!leaguesList) return;
  const { filtersReset } = pruneLeagueCaches();
  updateLeaguePaymentControls({ resetSelection: filtersReset });
  leaguesList.innerHTML = '';

  const list = Array.isArray(leagues) ? leagues.slice() : [];
  if (!list.length) {
    leaguesList.innerHTML =
      '<li class="empty-state">Crea una liga para iniciar una nueva temporada.</li>';
    state.selectedLeagueId = '';
    renderLeagueDetail();
    updateLeagueActionAvailability();
    updateCategoryFilterControls();
    updateRankingFilterControls();
    return;
  }

  const sorted = list.sort((a, b) => {
    if (a.status !== b.status) {
      return a.status === 'activa' ? -1 : 1;
    }
    const yearA = Number(a.year) || 0;
    const yearB = Number(b.year) || 0;
    if (yearA !== yearB) {
      return yearB - yearA;
    }
    const dateA = a.startDate ? new Date(a.startDate).getTime() : 0;
    const dateB = b.startDate ? new Date(b.startDate).getTime() : 0;
    return dateB - dateA;
  });

  const availableIds = sorted
    .map((league) => normalizeId(league))
    .filter((value) => Boolean(value));

  if (!availableIds.includes(state.selectedLeagueId)) {
    state.selectedLeagueId = availableIds[0] || '';
  }

  const activeId = state.selectedLeagueId;
  const admin = isAdmin();

  sorted.forEach((league) => {
    const leagueId = normalizeId(league);
    if (!leagueId) {
      return;
    }

    const item = document.createElement('li');
    if (leagueId === activeId) {
      item.classList.add('is-active');
    }
    item.dataset.leagueId = leagueId;

    const content = document.createElement('div');
    content.className = 'list-item__content';
    item.appendChild(content);

    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'list-item-button';
    button.dataset.leagueId = leagueId;
    content.appendChild(button);

    const title = document.createElement('strong');
    title.textContent = league.name || 'Liga';
    button.appendChild(title);

    const statusMeta = document.createElement('div');
    statusMeta.className = 'meta meta-league';
    if (league.year) {
      statusMeta.appendChild(document.createElement('span')).textContent = `Temporada ${league.year}`;
    }
    const statusValue = league.status || 'activa';
    const statusBadge = document.createElement('span');
    statusBadge.className = `tag league-status league-status--${statusValue}`;
    statusBadge.textContent = LEAGUE_STATUS_LABELS[statusValue] || LEAGUE_STATUS_LABELS.activa;
    statusMeta.appendChild(statusBadge);
    button.appendChild(statusMeta);

    const dateParts = [];
    if (league.startDate) {
      dateParts.push(`Inicio: ${formatDate(league.startDate)}`);
    }
    if (league.endDate) {
      dateParts.push(`Fin: ${formatDate(league.endDate)}`);
    }
    if (league.status === 'cerrada' && league.closedAt) {
      dateParts.push(`Cierre: ${formatDate(league.closedAt)}`);
    }
    if (dateParts.length) {
      const datesMeta = document.createElement('div');
      datesMeta.className = 'meta meta-league-dates';
      datesMeta.textContent = dateParts.join(' · ');
      button.appendChild(datesMeta);
    }



    const categories = Array.isArray(league.categories) ? league.categories : [];
    if (categories.length) {
      const categoryList = document.createElement('ul');
      categoryList.className = 'inline-list league-category-list';
      categories.forEach((category) => {
        const chip = document.createElement('li');
        chip.textContent = category.name || 'Categoría';
        categoryList.appendChild(chip);
      });
      button.appendChild(categoryList);
    } else {
      const emptyMeta = document.createElement('div');
      emptyMeta.className = 'meta note';
      emptyMeta.textContent = 'Sin categorías asociadas por el momento.';
      button.appendChild(emptyMeta);
    }

    const actions = document.createElement('div');
    actions.className = 'actions league-actions';
    let hasActions = false;

    if (admin) {
      const editButton = document.createElement('button');
      editButton.type = 'button';
      editButton.className = 'secondary';
      editButton.textContent = 'Editar';
      editButton.dataset.action = 'edit';
      editButton.dataset.leagueId = leagueId;
      actions.appendChild(editButton);

      const deleteButton = document.createElement('button');
      deleteButton.type = 'button';
      deleteButton.className = 'danger';
      deleteButton.textContent = 'Eliminar';
      deleteButton.dataset.action = 'delete';
      deleteButton.dataset.leagueId = leagueId;
      actions.appendChild(deleteButton);

      hasActions = true;
    } else {
      const access = getLeagueCategoryAccessSnapshot(leagueId);
      const isUserEnrolled = access.enrolled.length > 0;
      const hasPending = access.pending.length > 0;
      const hasAvailable = access.available.length > 0;

      if (isUserEnrolled) {
        const enrolledBadge = document.createElement('span');
        enrolledBadge.className = 'tag tag--success';
        enrolledBadge.textContent = 'Inscrito';
        actions.appendChild(enrolledBadge);
        hasActions = true;
      } else {
        if (hasPending) {
          const pendingBadge = document.createElement('span');
          pendingBadge.className = 'tag';
          pendingBadge.textContent =
            access.pending.length === 1 ? 'Solicitud enviada' : 'Solicitudes enviadas';
          actions.appendChild(pendingBadge);
          hasActions = true;
        }

        if (hasAvailable) {
          const requestButton = document.createElement('button');
          requestButton.type = 'button';
          requestButton.className = 'primary';
          requestButton.dataset.action = 'request-league-enrollment';
          requestButton.textContent = 'Solicitar inscripción';
          requestButton.dataset.leagueId = leagueId;
          actions.appendChild(requestButton);
          hasActions = true;
        } else if (state.categoriesLoaded && access.hasAnyCategory && !hasPending) {
          const note = document.createElement('span');
          note.className = 'note';
          note.textContent = 'No hay categorías disponibles para tu perfil.';
          actions.appendChild(note);
          hasActions = true;
        }
      }
    }

    if (hasActions) {
      content.appendChild(actions);
    }

    leaguesList.appendChild(item);
  });

  updateCategoryFilterControls();
  updateRankingFilterControls({ renderOnChange: false });
  renderLeagueDetail();
  updateLeagueActionAvailability();

  if (
    state.selectedLeagueId &&
    !(state.leagueDetails instanceof Map && state.leagueDetails.has(state.selectedLeagueId))
  ) {
    refreshLeagueDetail(state.selectedLeagueId).catch((error) => {
      console.warn('No se pudo cargar el detalle de la liga', error);
    });
  }
}

function renderLeagueDetail() {
  if (!leagueDetailBody) return;

  const leagueId = state.selectedLeagueId || '';
  updateLeagueActionAvailability();

  if (!leagueId) {
    if (leagueDetailTitle) {
      leagueDetailTitle.textContent = 'Detalle de la liga';
    }
    if (leagueDetailSubtitle) {
      leagueDetailSubtitle.textContent = 'Selecciona una liga para ver la información ampliada.';
    }
    leagueDetailBody.innerHTML =
      '<p class="empty-state">Selecciona una liga de la lista para ver sus detalles.</p>';
    return;
  }

  const baseLeague = getLeagueById(leagueId);
  const detail = state.leagueDetails instanceof Map ? state.leagueDetails.get(leagueId) : null;
  const info = detail || baseLeague;

  if (!info) {
    if (leagueDetailTitle) {
      leagueDetailTitle.textContent = 'Detalle de la liga';
    }
    if (leagueDetailSubtitle) {
      leagueDetailSubtitle.textContent = 'Selecciona una liga para ver la información ampliada.';
    }
    leagueDetailBody.innerHTML =
      '<p class="empty-state">No se encontró información de la liga seleccionada.</p>';
    return;
  }

  if (leagueDetailTitle) {
    leagueDetailTitle.textContent = info.name || 'Liga';
  }

  const subtitleParts = [];
  const seasonValue = detail?.year ?? baseLeague?.year;
  if (seasonValue) {
    subtitleParts.push(`Temporada ${seasonValue}`);
  }
  const rangeLabel = formatDateRangeLabel(
    detail?.startDate ?? baseLeague?.startDate,
    detail?.endDate ?? baseLeague?.endDate
  );
  if (rangeLabel) {
    subtitleParts.push(rangeLabel);
  }
  if (leagueDetailSubtitle) {
    leagueDetailSubtitle.textContent = subtitleParts.length
      ? subtitleParts.join(' · ')
      : 'Liga del club';
  }

  leagueDetailBody.innerHTML = '';
  const fragment = document.createDocumentFragment();
  const layout = document.createElement('div');
  layout.className = 'league-detail__layout';
  const content = document.createElement('div');
  content.className = 'league-detail__content';
  layout.appendChild(content);

  const posterSource =
    typeof detail?.poster === 'string' && detail.poster.trim()
      ? detail.poster.trim()
      : typeof baseLeague?.poster === 'string' && baseLeague.poster.trim()
      ? baseLeague.poster.trim()
      : '';
  if (posterSource) {
    const poster = document.createElement('img');
    poster.className = 'league-detail__poster';
    poster.src = posterSource;
    poster.alt = info.name ? `Cartel de la liga ${info.name}` : 'Cartel de la liga';
    layout.appendChild(poster);
  }

  const header = document.createElement('div');
  header.className = 'league-detail__header';

  const meta = document.createElement('div');
  meta.className = 'meta';

  const statusValue = detail?.status || baseLeague?.status || 'activa';
  const statusTag = document.createElement('span');
  statusTag.className = `tag league-status league-status--${statusValue}`;
  statusTag.textContent = LEAGUE_STATUS_LABELS[statusValue] || LEAGUE_STATUS_LABELS.activa;
  meta.appendChild(statusTag);



  const registrationClose = detail?.registrationCloseDate || baseLeague?.registrationCloseDate;


  header.appendChild(meta);

  const descriptionText = detail?.description || baseLeague?.description;


  content.appendChild(header);

  const metaItems = [];
  const startValue = detail?.startDate || baseLeague?.startDate;
  const endValue = detail?.endDate || baseLeague?.endDate;
  if (startValue) {
    metaItems.push(['Inicio', formatShortDate(startValue)]);
  }
  if (endValue) {
    metaItems.push(['Finalización', formatShortDate(endValue)]);
  }
  if (registrationClose) {
    metaItems.push(['Cierre de inscripciones', formatShortDate(registrationClose)]);
  }
  const closedAtValue = detail?.closedAt || baseLeague?.closedAt;
  if (closedAtValue) {
    metaItems.push(['Cierre administrativo', formatShortDate(closedAtValue)]);
  }
  const enrollmentFeeValue = detail?.enrollmentFee ?? baseLeague?.enrollmentFee;
  if (enrollmentFeeValue !== undefined && enrollmentFeeValue !== null) {
    const formattedFee = formatCurrencyValue(enrollmentFeeValue);
    metaItems.push([
      'Cuota de inscripción',
      formattedFee || `${Number(enrollmentFeeValue) || 0}`,
    ]);
  }
  const createdAtValue = detail?.createdAt || baseLeague?.createdAt;
  if (createdAtValue) {
    metaItems.push(['Creada', formatDate(createdAtValue)]);
  }

  if (metaItems.length) {
    const metaContainer = document.createElement('div');
    metaContainer.className = 'league-detail__meta';
    metaItems.forEach(([label, value]) => {
      const row = document.createElement('div');
      row.className = 'league-detail__meta-item';
      const labelSpan = document.createElement('span');
      labelSpan.className = 'league-detail__meta-label';
      labelSpan.textContent = label;
      const valueSpan = document.createElement('span');
      valueSpan.textContent = value;
      row.appendChild(labelSpan);
      row.appendChild(valueSpan);
      metaContainer.appendChild(row);
    });
    content.appendChild(metaContainer);
  }

  fragment.appendChild(layout);

  const categories = getLeagueCategories(leagueId);
  if (categories.length) {
    const categoryWrapper = document.createElement('div');
    const heading = document.createElement('h4');
    heading.className = 'league-section-title';
    heading.textContent = `Categorías (${categories.length})`;
    categoryWrapper.appendChild(heading);

    const categoryList = document.createElement('div');
    categoryList.className = 'league-detail__categories';

    categories
      .slice()
      .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
      .forEach((category) => {
        const categoryCard = document.createElement('div');
        categoryCard.className = 'league-detail__category';

        const name = document.createElement('strong');
        name.textContent = category.name || 'Categoría';
        categoryCard.appendChild(name);

        const metaLine = document.createElement('div');
        metaLine.className = 'meta';

        if (category.gender) {
          const genderSpan = document.createElement('span');
          genderSpan.textContent = translateGender(category.gender);
          metaLine.appendChild(genderSpan);
        }

        if (category.matchType) {
          const typeSpan = document.createElement('span');
          typeSpan.textContent = formatTournamentMatchType(category.matchType);
          metaLine.appendChild(typeSpan);
        }

        if (category.matchFormat) {
          const formatSpan = document.createElement('span');
          formatSpan.textContent = formatTournamentMatchFormat(category.matchFormat);
          metaLine.appendChild(formatSpan);
        }

        const enrollmentCount = Number.isFinite(Number(category.enrollmentCount))
          ? Number(category.enrollmentCount)
          : Number.isFinite(Number(category.playerCount))
          ? Number(category.playerCount)
          : null;

        if (enrollmentCount !== null) {
          const enrollmentSpan = document.createElement('span');
          enrollmentSpan.textContent =
            enrollmentCount === 1
              ? '1 jugador inscrito'
              : `${enrollmentCount} jugadores inscritos`;
          metaLine.appendChild(enrollmentSpan);
        }

        if (metaLine.childNodes.length) {
          categoryCard.appendChild(metaLine);
        }

        categoryList.appendChild(categoryCard);
      });

    categoryWrapper.appendChild(categoryList);
    fragment.appendChild(categoryWrapper);
  } else {
    const note = document.createElement('p');
    note.className = 'league-section-note';
    note.textContent = state.categoriesLoaded
      ? 'Esta liga aún no tiene categorías asociadas.'
      : 'Cargando categorías de la liga...';
    fragment.appendChild(note);
  }

  leagueDetailBody.appendChild(fragment);
}

async function refreshLeagueDetail(leagueId = state.selectedLeagueId, { force = false } = {}) {
  const normalized = typeof leagueId === 'string' ? leagueId : normalizeId(leagueId);
  if (!normalized) {
    return;
  }

  pendingLeagueDetailId = normalized;
  try {
    renderLeagueDetail();
    const detail = await fetchLeagueDetail(normalized, { force });
    if (pendingLeagueDetailId !== normalized) {
      return;
    }
    renderLeagueDetail();
  } catch (error) {
    if (pendingLeagueDetailId === normalized && leagueDetailBody) {
      leagueDetailBody.innerHTML = `<p class="empty-state">${escapeHtml(
        error.message || 'No fue posible cargar el detalle de la liga.'
      )}</p>`;
    }
  } finally {
    if (pendingLeagueDetailId === normalized) {
      pendingLeagueDetailId = null;
    }
  }
}

function openLeagueEnrollmentModal(leagueId = '') {
  const normalizedId = leagueId || '';
  if (!normalizedId) {
    return;
  }

  if (!state.categoriesLoaded) {
    showGlobalMessage(
      'La información de las categorías aún se está cargando. Inténtalo en unos instantes.',
      'info'
    );
    return;
  }

  const league = state.leagues.find((item) => normalizeId(item) === normalizedId);
  if (!league) {
    showGlobalMessage('No fue posible encontrar la liga seleccionada.', 'error');
    return;
  }

  const access = getLeagueCategoryAccessSnapshot(normalizedId);
  const availableCategories = access.available
    .slice()
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es', { sensitivity: 'base' }));

  if (!availableCategories.length) {
    const message = access.pending.length
      ? 'Ya tienes solicitudes pendientes para esta liga.'
      : 'No hay categorías disponibles para solicitar en esta liga.';
    showGlobalMessage(message, 'info');
    return;
  }

  const form = document.createElement('form');
  form.className = 'form league-enrollment-form';
  form.noValidate = true;

  const intro = document.createElement('p');
  intro.className = 'meta';
  intro.textContent =
    'Selecciona las categorías en las que deseas participar. Tu solicitud será revisada por un administrador.';
  form.appendChild(intro);

  if (typeof league.enrollmentFee === 'number') {
    const feeInfo = document.createElement('p');
    feeInfo.className = 'note';
    feeInfo.textContent = `Cuota de inscripción: ${formatCurrencyValue(league.enrollmentFee)}.`;
    form.appendChild(feeInfo);
  }

  if (access.pending.length) {
    const pendingInfo = document.createElement('p');
    pendingInfo.className = 'note';
    const pendingNames = access.pending.map((category) => category.name).filter(Boolean);
    pendingInfo.textContent =
      pendingNames.length === 1
        ? `Tienes una solicitud pendiente para ${pendingNames[0]}.`
        : `Tienes solicitudes pendientes para ${pendingNames.join(', ')}.`;
    form.appendChild(pendingInfo);
  }

  const checkboxGroup = document.createElement('div');
  checkboxGroup.className = 'checkbox-group';

  availableCategories.forEach((category) => {
    const option = document.createElement('label');
    option.className = 'checkbox-option';

    const input = document.createElement('input');
    input.type = 'checkbox';
    input.name = 'categoryIds';
    input.value = category.id;
    option.appendChild(input);

    const labelText = document.createElement('span');
    const metaParts = [];
    if (category.gender) {
      metaParts.push(translateGender(category.gender));
    }
    if (category.matchType) {
      metaParts.push(formatTournamentMatchType(category.matchType));
    }
    if (category.matchFormat) {
      metaParts.push(formatTournamentMatchFormat(category.matchFormat));
    }
    const metaText = metaParts.join(' · ');
    labelText.textContent = metaText
      ? `${category.name} · ${metaText}`
      : category.name;
    option.appendChild(labelText);

    checkboxGroup.appendChild(option);
  });

  form.appendChild(checkboxGroup);

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const actions = document.createElement('div');
  actions.className = 'form-actions';

  const submitButton = document.createElement('button');
  submitButton.type = 'submit';
  submitButton.className = 'primary';
  submitButton.textContent =
    availableCategories.length === 1
      ? 'Solicitar inscripción'
      : 'Solicitar inscripciones';
  actions.appendChild(submitButton);

  form.appendChild(actions);
  form.appendChild(status);

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const selectedIds = Array.from(
      form.querySelectorAll('input[name="categoryIds"]:checked')
    )
      .map((input) => input.value)
      .filter(Boolean);

    if (!selectedIds.length) {
      setStatusMessage(status, 'error', 'Selecciona al menos una categoría.');
      return;
    }

    const controls = Array.from(form.querySelectorAll('input, button'));
    controls.forEach((control) => {
      control.disabled = true;
    });

    const sendingLabel =
      selectedIds.length === 1 ? 'Enviando solicitud...' : 'Enviando solicitudes...';
    setStatusMessage(status, 'info', sendingLabel);

    const processedIds = [];
    let shouldCloseModal = false;

    try {
      for (const categoryId of selectedIds) {
        await request(`/categories/${categoryId}/enrollment-requests`, { method: 'POST' });
        state.enrollmentRequests.delete(categoryId);
        processedIds.push(categoryId);
      }

      await reloadCategories();

      const successMessage =
        selectedIds.length === 1
          ? 'Solicitud enviada. Un administrador la revisará en breve.'
          : 'Solicitudes enviadas. Un administrador las revisará en breve.';
      showGlobalMessage(successMessage, 'success');
      shouldCloseModal = true;
    } catch (error) {
      if (processedIds.length) {
        try {
          await reloadCategories();
        } catch (reloadError) {
          console.warn(
            'No se pudo actualizar las categorías tras enviar la solicitud de liga',
            reloadError
          );
        }
      }

      setStatusMessage(status, 'error', error.message);
    } finally {
      if (shouldCloseModal) {
        setStatusMessage(status, '', '');
        closeModal();
      } else if (document.body.contains(form)) {
        controls.forEach((control) => {
          control.disabled = false;
        });
      }
    }
  });

  openModal({
    title: league.name ? `Solicitar inscripción · ${league.name}` : 'Solicitar inscripción',
    content: (body) => {
      body.appendChild(form);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

function renderCategories(categories = []) {
  if (!categoriesList) return;
  updateCategoryControlsAvailability();

  const filters = ensureCategoryFilters();
  const leagueFilter = filters.league || '';
  const sourceCategories = Array.isArray(categories)
    ? categories
    : Array.isArray(state.categories)
    ? state.categories
    : [];

  const admin = isAdmin();
  const currentGender = state.user?.gender || '';
  const totalPendingRequests = admin
    ? sourceCategories.reduce((sum, category) => {
        const pendingCount = Number(category?.pendingRequestCount || 0);
        if (Number.isFinite(pendingCount) && pendingCount > 0) {
          return sum + pendingCount;
        }
        return sum;
      }, 0)
    : 0;

  const filteredCategories = leagueFilter
    ? sourceCategories.filter((category) => normalizeId(category?.league) === leagueFilter)
    : sourceCategories;

  categoriesList.innerHTML = '';

  if (!filteredCategories.length) {
    if (!sourceCategories.length) {
      categoriesList.innerHTML = state.leagues.length
        ? '<li class="empty-state">No hay categorías registradas.</li>'
        : admin
        ? '<li class="empty-state">Crea una liga para comenzar a registrar categorías.</li>'
        : '<li class="empty-state">Aún no hay ligas disponibles.</li>';
    } else if (leagueFilter) {
      categoriesList.innerHTML =
        '<li class="empty-state">No hay categorías registradas para la liga seleccionada.</li>';
    } else {
      categoriesList.innerHTML = '<li class="empty-state">No hay categorías registradas.</li>';
    }

    if (admin) {
      state.pendingEnrollmentRequestCount = totalPendingRequests;
      if (state.notificationBase !== null) {
        renderNotifications(state.notificationBase);
      }
    } else {
      state.pendingEnrollmentRequestCount = 0;
    }

    return;
  }

  const resolveCategorySortValue = (category) => {
    if (!category) {
      return Number.POSITIVE_INFINITY;
    }
    const start = category.startDate ? new Date(category.startDate).getTime() : NaN;
    if (Number.isFinite(start)) {
      return start;
    }
    const created = category.createdAt ? new Date(category.createdAt).getTime() : NaN;
    if (Number.isFinite(created)) {
      return created;
    }
    return Number.POSITIVE_INFINITY;
  };

  const sortedCategories = filteredCategories
    .slice()
    .sort((a, b) => {
      const valueA = resolveCategorySortValue(a);
      const valueB = resolveCategorySortValue(b);
      if (valueA !== valueB) {
        return valueA - valueB;
      }
      return (a?.name || '').localeCompare(b?.name || '', 'es');
    });

  sortedCategories.forEach((category) => {
    const item = document.createElement('li');
    const content = document.createElement('div');
    content.className = 'list-item__content';
    item.appendChild(content);

    const categoryId = normalizeId(category);
    if (categoryId) {
      item.dataset.categoryId = categoryId;
    }
    const categoryColor = getCategoryColor(category);
    if (categoryColor) {
      applyCategoryColorStyles(item, categoryColor, { backgroundAlpha: 0.14, borderAlpha: 0.3 });
    }

    const title = document.createElement('strong');
    title.textContent = category.name;
    if (categoryColor) {
      const indicator = createCategoryColorIndicator(categoryColor, category.name);
      if (indicator) {
        title.classList.add('with-category-color');
        title.prepend(indicator);
      }
    }
    content.appendChild(title);

    const statusValue = category.status || 'inscripcion';
    const meta = document.createElement('div');
    meta.className = 'meta meta-category';
    meta.appendChild(document.createElement('span')).textContent = translateGender(category.gender);

    const statusBadge = document.createElement('span');
    statusBadge.className = `tag category-status category-status--${statusValue}`;
    statusBadge.textContent = CATEGORY_STATUS_LABELS[statusValue] || 'Estado por definir';
    meta.appendChild(statusBadge);

    if (category.skillLevel) {
      const level = document.createElement('span');
      level.className = 'tag category-level';
      level.textContent = category.skillLevel;
      meta.appendChild(level);
    }
    content.appendChild(meta);

    const minimumAgeValue = Number(category.minimumAge);
    if (Number.isFinite(minimumAgeValue) && minimumAgeValue > 0) {
      const minimumAgeMeta = document.createElement('div');
      minimumAgeMeta.className = 'meta meta-minimum-age';
      const parts = [`Edad mínima: ${minimumAgeValue} años`];
      if (category.minimumAgeReferenceYear) {
        parts.push(`Año de referencia: ${category.minimumAgeReferenceYear}`);
      }
      minimumAgeMeta.textContent = parts.join(' · ');
      content.appendChild(minimumAgeMeta);
    }

    if (category.startDate || category.endDate) {
      const dates = document.createElement('div');
      dates.className = 'meta';
      const formatted = [category.startDate, category.endDate]
        .map((value) => (value ? formatDate(value) : null))
        .filter(Boolean)
        .join(' · ');
      dates.textContent = formatted || 'Fechas por confirmar';
      content.appendChild(dates);
    }

    if (category.description) {
      const description = document.createElement('p');
      description.textContent = category.description;
      content.appendChild(description);
    }

    const linkedLeague = resolveLeague(category.league);
    if (linkedLeague) {
      const leagueMeta = document.createElement('div');
      leagueMeta.className = 'meta meta-league-link';
      leagueMeta.appendChild(document.createElement('span')).textContent = 'Liga';

      const leagueTag = document.createElement('span');
      leagueTag.className = 'tag league-tag';
      const leagueNameParts = [linkedLeague.name || 'Liga'];
      if (linkedLeague.year) {
        leagueNameParts.push(linkedLeague.year);
      }
      leagueTag.textContent = leagueNameParts.join(' · ');
      if (linkedLeague.status === 'cerrada') {
        leagueTag.classList.add('league-tag--closed');
      }
      leagueMeta.appendChild(leagueTag);

      const statusLabel = linkedLeague.status
        ? LEAGUE_STATUS_LABELS[linkedLeague.status]
        : null;
      if (statusLabel) {
        const statusBadge = document.createElement('span');
        statusBadge.className = `tag league-status league-status--${linkedLeague.status}`;
        statusBadge.textContent = statusLabel;
        leagueMeta.appendChild(statusBadge);
      }

      content.appendChild(leagueMeta);
    } else if (admin) {
      const leagueNote = document.createElement('div');
      leagueNote.className = 'meta note';
      leagueNote.textContent = 'Liga pendiente de asignar.';
      content.appendChild(leagueNote);
    }

    const registrationMetaParts = [];
    if (category.registrationWindowOpen === true) {
      registrationMetaParts.push('Inscripciones abiertas');
    } else if (category.registrationWindowOpen === false) {
      registrationMetaParts.push('Inscripciones cerradas');
    }
    if (category.leagueRegistrationCloseDate) {
      registrationMetaParts.push(
        `Cierre de inscripción: ${formatDate(category.leagueRegistrationCloseDate)}`
      );
    }
    if (typeof category.leagueEnrollmentFee === 'number') {
      registrationMetaParts.push(`Cuota: ${formatCurrencyValue(category.leagueEnrollmentFee)}`);
    }
    if (registrationMetaParts.length) {
      const registrationMeta = document.createElement('div');
      registrationMeta.className = 'meta meta-registration';
      registrationMeta.textContent = registrationMetaParts.join(' · ');
      content.appendChild(registrationMeta);
    }

    const storedEnrollments = state.enrollments.get(categoryId);
    const enrollmentCount = Array.isArray(storedEnrollments)
      ? storedEnrollments.length
      : Number(category.enrollmentCount || 0);
    const pendingRequestCount = Number(category.pendingRequestCount || 0);

    const enrollmentSummary = document.createElement('div');
    enrollmentSummary.className = 'meta meta-enrollment';
    enrollmentSummary.textContent = `Jugadores inscritos: ${enrollmentCount}`;
    content.appendChild(enrollmentSummary);

    if (admin && pendingRequestCount > 0) {
      const requestSummary = document.createElement('div');
      requestSummary.className = 'meta meta-enrollment';
      requestSummary.textContent = `Solicitudes pendientes: ${pendingRequestCount}`;
      content.appendChild(requestSummary);
    }

    if (Array.isArray(storedEnrollments) && storedEnrollments.length) {
      const roster = document.createElement('ul');
      roster.className = 'inline-list';
      storedEnrollments.forEach((enrollment) => {
        const player = enrollment.user || {};
        const listItem = document.createElement('li');
        listItem.textContent = player.fullName || player.email || 'Jugador';
        roster.appendChild(listItem);
      });
      content.appendChild(roster);
    }

    const actions = document.createElement('div');
    actions.className = 'actions category-actions';
    let hasActions = false;

    if (admin) {
      const editButton = document.createElement('button');
      editButton.type = 'button';
      editButton.className = 'secondary';
      editButton.textContent = 'Editar';
      if (categoryId) {
        editButton.dataset.categoryId = categoryId;
        editButton.dataset.action = 'edit';
      }
      actions.appendChild(editButton);

      if (pendingRequestCount > 0) {
        const reviewButton = document.createElement('button');
        reviewButton.type = 'button';
        reviewButton.className = 'primary';
        reviewButton.textContent =
          pendingRequestCount === 1
            ? 'Revisar solicitud'
            : `Revisar ${pendingRequestCount} solicitudes`;
        if (categoryId) {
          reviewButton.dataset.categoryId = categoryId;
          reviewButton.dataset.action = 'review-requests';
        }
        actions.appendChild(reviewButton);
      }

      const manageButton = document.createElement('button');
      manageButton.type = 'button';
      manageButton.className = 'ghost';
      manageButton.textContent = 'Gestionar inscripciones';
      if (categoryId) {
        manageButton.dataset.categoryId = categoryId;
        manageButton.dataset.action = 'enrollments';
      }
      actions.appendChild(manageButton);
      hasActions = true;
    }

    const hasPendingRequest = Boolean(category.pendingRequestId);
    const canRequestEnrollment = Boolean(
      !admin &&
        categoryId &&
        category.canRequestEnrollment &&
        !category.isEnrolled &&
        !hasPendingRequest
    );

    if (category.isEnrolled) {
      const enrolledBadge = document.createElement('span');
      enrolledBadge.className = 'tag tag--success';
      enrolledBadge.textContent = 'Inscrito';
      actions.appendChild(enrolledBadge);
      hasActions = true;
    } else if (hasPendingRequest) {
      const pendingBadge = document.createElement('span');
      pendingBadge.className = 'tag';
      pendingBadge.textContent = 'Solicitud enviada';
      actions.appendChild(pendingBadge);
      hasActions = true;
    } else if (canRequestEnrollment) {
      const requestButton = document.createElement('button');
      requestButton.type = 'button';
      requestButton.className = 'primary';
      requestButton.dataset.categoryId = categoryId;
      requestButton.dataset.action = 'request-enrollment';
      requestButton.textContent = 'Solicitar inscripción';
      actions.appendChild(requestButton);
      hasActions = true;
    } else if (!admin && statusValue === 'en_curso') {
      const note = document.createElement('span');
      note.className = 'note';
      note.textContent = 'Inscripciones cerradas';
      actions.appendChild(note);
      hasActions = true;
    } else if (!admin && currentGender && category.gender !== currentGender) {
      const note = document.createElement('span');
      note.className = 'note';
      note.textContent = 'No disponible para tu perfil';
      actions.appendChild(note);
      hasActions = true;
    }

    if (hasActions) {
      content.appendChild(actions);
    }

    const rawCategoryPoster = typeof category.poster === 'string' ? category.poster.trim() : '';
    const rawLeaguePoster =
      typeof linkedLeague?.poster === 'string' ? linkedLeague.poster.trim() : '';
    const posterUrl = rawCategoryPoster || rawLeaguePoster;
    if (posterUrl) {
      item.classList.add('list-item--with-poster');
      const posterWrapper = document.createElement('div');
      posterWrapper.className = 'list-item__poster';
      const poster = document.createElement('img');
      poster.className = 'list-item__poster-image';
      poster.src = posterUrl;
      if (rawCategoryPoster && category.name) {
        poster.alt = `Cartel de la categoría ${category.name}`;
      } else if (linkedLeague?.name) {
        poster.alt = `Cartel de la liga ${linkedLeague.name}`;
      } else {
        poster.alt = 'Cartel de la liga';
      }
      poster.loading = 'lazy';
      posterWrapper.appendChild(poster);
      item.appendChild(posterWrapper);
    }

    categoriesList.appendChild(item);
  });

  if (admin) {
    state.pendingEnrollmentRequestCount = totalPendingRequests;
    if (state.notificationBase !== null) {
      renderNotifications(state.notificationBase);
    }
  } else {
    state.pendingEnrollmentRequestCount = 0;
  }
}

function getPodiumEmoji(positionIndex) {
  switch (positionIndex) {
    case 0:
      return '🥇';
    case 1:
      return '🥈';
    case 2:
      return '🥉';
    default:
      return '';
  }
}

function formatDateRangeLabel(startDate, endDate) {
  const start = formatDateOnly(startDate);
  const end = formatDateOnly(endDate);
  if (start && end) {
    if (start === end) {
      return start;
    }
    return `${start} – ${end}`;
  }
  return start || end || '';
}

function normalizeMatchPlayer(player) {
  if (!player) return null;
  if (typeof player === 'object') return player;
  if (typeof player === 'string') {
    return { fullName: player };
  }
  return null;
}

function buildMatchTeams(players = []) {
  if (!Array.isArray(players)) return [];

  return players
    .map((entry) => {
      if (!entry) {
        return [];
      }

      if (Array.isArray(entry.players) && entry.players.length) {
        const members = entry.players
          .map((member) => normalizeMatchPlayer(member))
          .filter(Boolean);
        if (members.length) {
          return members;
        }
      }

      const normalized = normalizeMatchPlayer(entry);
      return normalized ? [normalized] : [];
    })
    .filter((team) => team.length);
}

function renderDashboardMatchList(
  matches = [],
  container,
  emptyMessage,
  { includeScope = false } = {}
) {
  if (!container) return;

  container.innerHTML = '';

  const scheduledMatches = Array.isArray(matches)
    ? matches.filter((match) => {
        const status = (match?.status || '').toLowerCase();
        const hasSchedule = Boolean(match?.scheduledAt);
        return hasSchedule && (status === 'programado' || status === 'scheduled');
      })
    : [];

  if (!scheduledMatches.length) {
    container.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
    return;
  }

  scheduledMatches.forEach((match) => {
    const item = document.createElement('li');
    item.classList.add('match-list-item');

    const playerLabel = Array.isArray(match.players) && match.players.length
      ? match.players.map((player) => getPlayerDisplayName(player)).join(' vs ')
      : 'Jugadores por definir';

    const accessibleTitle = document.createElement('strong');
    accessibleTitle.className = 'sr-only';
    accessibleTitle.textContent = playerLabel;
    item.appendChild(accessibleTitle);

    const teams = buildMatchTeams(match.players);

    if (teams.length) {
      const participants = document.createElement('div');
      participants.className = 'match-list-item__participants';

      teams.forEach((team, index) => {
        if (index > 0) {
          const separator = document.createElement('span');
          separator.className = 'match-list-item__vs';
          separator.textContent = 'vs';
          participants.appendChild(separator);
        }

        const teamElement = document.createElement('div');
        teamElement.className = 'match-list-item__team';

        team.forEach((player) => {
          const normalized = normalizeMatchPlayer(player);
          if (!normalized) return;

          const playerElement = document.createElement('div');
          playerElement.className = 'match-list-item__player';
          playerElement.title = getPlayerDisplayName(normalized);

          playerElement.appendChild(createAvatarElement(normalized, { size: 'sm' }));

          const name = document.createElement('span');
          name.className = 'match-list-item__player-name';
          name.textContent = getPlayerDisplayName(normalized);
          playerElement.appendChild(name);

          teamElement.appendChild(playerElement);
        });

        participants.appendChild(teamElement);
      });

      item.appendChild(participants);
    } else {
      const fallbackTitle = document.createElement('strong');
      fallbackTitle.textContent = playerLabel;
      item.appendChild(fallbackTitle);
    }

    const meta = document.createElement('div');
    meta.className = 'meta match-list-item__meta';

    const dateLabel = formatDate(match.scheduledAt);
    if (dateLabel) {
      meta.appendChild(document.createElement('span')).textContent = dateLabel;
    }

    if (match.court) {
      meta.appendChild(document.createElement('span')).textContent = `Pista ${match.court}`;
    }

    if (match.category?.name) {
      const categoryTag = document.createElement('span');
      categoryTag.className = 'tag match-category-tag';
      categoryTag.textContent = match.category.name;
      applyCategoryTagColor(categoryTag, match.category.color);
      meta.appendChild(categoryTag);
    }

    if (includeScope) {
      if (match.scope === 'tournament' && match.tournament?.name) {
        const scopeTag = document.createElement('span');
        scopeTag.className = 'tag';
        scopeTag.textContent = match.tournament.name;
        meta.appendChild(scopeTag);
      } else if (match.scope === 'league' && match.league?.name) {
        const scopeTag = document.createElement('span');
        scopeTag.className = 'tag';
        scopeTag.textContent = match.league.name;
        meta.appendChild(scopeTag);
      }
    }

    item.appendChild(meta);
    container.appendChild(item);
  });
}

function renderGlobalOverview(overview) {
  state.globalOverview = overview || null;
  const metrics = overview?.metrics || {};

  if (globalLeaguesCount) {
    globalLeaguesCount.textContent = String(metrics.leagues ?? 0);
  }
  if (globalTournamentsCount) {
    globalTournamentsCount.textContent = String(metrics.tournaments ?? 0);
  }
  if (globalCategoriesCount) {
    globalCategoriesCount.textContent = String(metrics.categories ?? 0);
  }
  if (globalCourtsCount) {
    globalCourtsCount.textContent = String(metrics.courts ?? 0);
  }

  renderGlobalLeagues(overview?.leagues || []);
  renderGlobalTournaments(overview?.tournaments || []);
  renderGlobalUpcomingMatches(overview?.upcomingMatches || []);
}

function renderGlobalLeagues(leagues = []) {
  if (!globalLeaguesList) return;
  globalLeaguesList.innerHTML = '';

  const list = Array.isArray(leagues) ? leagues : [];

  if (!list.length) {
    globalLeaguesList.innerHTML = '<li class="empty-state">No hay ligas registradas actualmente.</li>';
    return;
  }

  list.forEach((league) => {
    const leagueId = normalizeId(league);
    const item = document.createElement('li');
    item.classList.add('global-overview-item');

    const content = document.createElement('div');
    content.className = 'list-item__content';
    item.appendChild(content);

    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'list-item-button';
    if (leagueId) {
      button.dataset.globalLeagueId = leagueId;
      button.setAttribute(
        'aria-label',
        `Solicitar inscripción en la liga ${league.name || 'sin nombre'}`
      );
    } else {
      button.disabled = true;
    }
    content.appendChild(button);

    const title = document.createElement('strong');
    title.textContent = league.name || 'Liga sin nombre';
    button.appendChild(title);

    const meta = document.createElement('div');
    meta.className = 'meta';

    if (league.status) {
      const statusLabel = LEAGUE_STATUS_LABELS[league.status] || league.status;
      meta.appendChild(document.createElement('span')).textContent = statusLabel;
    }

    if (league.year) {
      meta.appendChild(document.createElement('span')).textContent = `Temporada ${league.year}`;
    }

    const rangeLabel = formatDateRangeLabel(league.startDate, league.endDate);
    if (rangeLabel) {
      meta.appendChild(document.createElement('span')).textContent = rangeLabel;
    }

    const categoriesCount = Number(league.categoryCount ?? 0);
    const activeCategories = Number(league.activeCategories ?? 0);
    if (categoriesCount) {
      const categoriesLabel =
        activeCategories && activeCategories !== categoriesCount
          ? `${categoriesCount} categorías (${activeCategories} activas)`
          : `${categoriesCount} categorías`;
      meta.appendChild(document.createElement('span')).textContent = categoriesLabel;
    }

    if (meta.childElementCount) {
      button.appendChild(meta);
    }

    if (leagueId) {
      const hint = document.createElement('span');
      hint.className = 'note';
      hint.textContent = 'Haz clic para inscribirte';
      button.appendChild(hint);
    }

    const posterUrl = typeof league.poster === 'string' ? league.poster.trim() : '';
    if (posterUrl) {
      item.classList.add('list-item--with-poster');
      const posterWrapper = document.createElement('div');
      posterWrapper.className = 'list-item__poster';
      const poster = document.createElement('img');
      poster.className = 'list-item__poster-image';
      poster.src = posterUrl;
      poster.alt = league.name ? `Cartel de la liga ${league.name}` : 'Cartel de la liga';
      poster.loading = 'lazy';
      posterWrapper.appendChild(poster);
      item.appendChild(posterWrapper);
    }

    globalLeaguesList.appendChild(item);
  });
}

function renderGlobalTournaments(tournaments = []) {
  if (!globalTournamentsList) return;
  globalTournamentsList.innerHTML = '';

  const list = Array.isArray(tournaments) ? tournaments : [];

  if (!list.length) {
    globalTournamentsList.innerHTML = '<li class="empty-state">No hay torneos programados.</li>';
    return;
  }

  list.forEach((tournament) => {
    const tournamentId = normalizeId(tournament);
    const item = document.createElement('li');
    item.classList.add('global-overview-item');

    const content = document.createElement('div');
    content.className = 'list-item__content';
    item.appendChild(content);

    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'list-item-button';
    if (tournamentId) {
      button.dataset.globalTournamentId = tournamentId;
      button.setAttribute(
        'aria-label',
        `Inscribirse en el torneo ${tournament.name || 'sin nombre'}`
      );
    } else {
      button.disabled = true;
    }
    content.appendChild(button);

    const title = document.createElement('strong');
    title.textContent = tournament.name || 'Torneo sin nombre';
    button.appendChild(title);

    const meta = document.createElement('div');
    meta.className = 'meta';

    if (tournament.status) {
      const statusLabel = TOURNAMENT_STATUS_LABELS[tournament.status] || tournament.status;
      meta.appendChild(document.createElement('span')).textContent = statusLabel;
    }

    const rangeLabel = formatDateRangeLabel(tournament.startDate, tournament.endDate);
    if (rangeLabel) {
      meta.appendChild(document.createElement('span')).textContent = rangeLabel;
    }

    const categoriesCount = Number(tournament.categoryCount ?? 0);
    if (categoriesCount) {
      meta.appendChild(document.createElement('span')).textContent =
        categoriesCount === 1 ? '1 categoría' : `${categoriesCount} categorías`;
    }

    if (tournament.registrationCloseDate) {
      meta.appendChild(document.createElement('span')).textContent = `Inscripciones hasta ${formatDateOnly(tournament.registrationCloseDate)}`;
    }

    if (meta.childElementCount) {
      button.appendChild(meta);
    }

    if (tournamentId) {
      const hint = document.createElement('span');
      hint.className = 'note';
      hint.textContent = 'Haz clic para inscribirte';
      button.appendChild(hint);
    }

    const posterUrl = typeof tournament.poster === 'string' ? tournament.poster.trim() : '';
    if (posterUrl) {
      item.classList.add('list-item--with-poster');
      const posterWrapper = document.createElement('div');
      posterWrapper.className = 'list-item__poster';
      const poster = document.createElement('img');
      poster.className = 'list-item__poster-image';
      poster.src = posterUrl;
      poster.alt = tournament.name
        ? `Cartel del torneo ${tournament.name}`
        : 'Cartel del torneo';
      poster.loading = 'lazy';
      posterWrapper.appendChild(poster);
      item.appendChild(posterWrapper);
    }

    globalTournamentsList.appendChild(item);
  });
}

function renderGlobalUpcomingMatches(matches = []) {
  renderDashboardMatchList(matches, globalUpcomingMatchesList, 'No hay partidos programados.', {
    includeScope: true,
  });
}

function renderLeagueDashboard(summary) {
  const previousSummary = state.leagueDashboard;
  const nextSummary = summary || null;
  const isSameReference = previousSummary && nextSummary && previousSummary === nextSummary;

  state.leagueDashboard = nextSummary;
  if (!isSameReference) {
    state.leagueDashboardPlayersPage = 1;
  }
  const metrics = summary?.metrics || {};

  if (leagueMetricPlayers) {
    leagueMetricPlayers.textContent = String(metrics.players ?? 0);
  }
  if (leagueMetricCategories) {
    leagueMetricCategories.textContent = String(metrics.categories ?? 0);
  }
  if (leagueMetricUpcoming) {
    leagueMetricUpcoming.textContent = String(metrics.upcomingMatches ?? 0);
  }

  const leagueGroups = Array.isArray(summary?.leagueRankings) ? summary.leagueRankings : [];
  const activeLeaguesValue = Number(metrics.activeLeagues);
  const activeLeaguesCount = Number.isFinite(activeLeaguesValue)
    ? activeLeaguesValue
    : leagueGroups.length;

  renderLeagueActiveSummary(leagueGroups, activeLeaguesCount);
  renderLeagueRankingCards(leagueGroups);
  renderLeagueEnrolledPlayers(nextSummary?.enrolledPlayers || []);
  renderDashboardMatchList(
    summary?.upcomingMatches || [],
    leagueUpcomingMatchesList,
    'Todavía no hay partidos programados.'
  );
}

function renderLeagueActiveSummary(leagueGroups = [], activeLeagues = 0) {
  if (!leagueActiveSummary) return;

  const parsedActive = Number(activeLeagues);
  const activeCount = Number.isFinite(parsedActive) ? parsedActive : 0;
  if (leagueActiveCount) {
    leagueActiveCount.textContent = String(activeCount);
  }

  if (leagueActiveList) {
    leagueActiveList.innerHTML = '';

    const seen = new Set();
    const leagues = [];

    leagueGroups.forEach((group) => {
      const categories = Array.isArray(group?.categories) ? group.categories : [];
      if (!categories.length) {
        return;
      }
      const leagueId = normalizeId(group?.league);
      if (!leagueId || seen.has(leagueId)) {
        return;
      }
      seen.add(leagueId);
      leagues.push(group.league);
    });

    if (!leagues.length) {
      const empty = document.createElement('span');
      empty.className = 'empty-state';
      empty.textContent = 'No hay ligas activas registradas.';
      leagueActiveList.appendChild(empty);
    } else {
      leagues
        .sort((a, b) => a?.name?.localeCompare?.(b?.name || '') || 0)
        .forEach((league) => {
          const leagueId = normalizeId(league);
          if (!leagueId) {
            const tag = document.createElement('span');
            tag.className = 'tag';
            tag.textContent = league?.name || 'Liga';
            leagueActiveList.appendChild(tag);
            return;
          }

          const button = document.createElement('button');
          button.type = 'button';
          button.className = 'tag tag--link';
          button.textContent = league?.name || 'Liga';
          button.dataset.leagueId = leagueId;
          button.title = `Ver ${league?.name || 'liga'}`;
          leagueActiveList.appendChild(button);
        });
    }
  }

  leagueActiveSummary.hidden = false;
}

function createLeagueRankingCategoryCard(categorySummary) {
  const card = document.createElement('div');
  card.className = 'collection-card';

  const header = document.createElement('div');
  header.className = 'collection-card__header';

  const title = document.createElement('div');
  title.className = 'collection-card__title';
  if (categorySummary.category?.color) {
    const indicator = createCategoryColorIndicator(
      categorySummary.category.color,
      categorySummary.category?.name
    );
    if (indicator) {
      title.appendChild(indicator);
    }
  }
  title.appendChild(document.createTextNode(categorySummary.category?.name || 'Categoría'));
  header.appendChild(title);

  if (categorySummary.league?.name) {
    const subtitle = document.createElement('span');
    subtitle.className = 'collection-card__subtitle';
    subtitle.textContent = categorySummary.league.name;
    header.appendChild(subtitle);
  }

  card.appendChild(header);

  const meta = document.createElement('div');
  meta.className = 'collection-card__meta';
  const playerCount = Number(categorySummary.playerCount ?? 0);
  const upcomingCount = Number(categorySummary.upcomingMatches ?? 0);
  meta.textContent = `${playerCount} jugadores · ${upcomingCount} partidos próximos`;
  card.appendChild(meta);

  const ranking = Array.isArray(categorySummary.ranking)
    ? categorySummary.ranking.slice(0, 3)
    : [];

  if (!ranking.length) {
    const empty = document.createElement('p');
    empty.className = 'empty-state';
    empty.textContent = 'Sin resultados registrados.';
    card.appendChild(empty);
  } else {
    const list = document.createElement('ul');
    list.className = 'collection-card__list';

    ranking.forEach((entry, index) => {
      const listItem = document.createElement('li');
      listItem.className = 'collection-card__list-item';

      const position = document.createElement('span');
      position.className = 'collection-card__position';
      const podiumEmoji = getPodiumEmoji(index);
      position.textContent = podiumEmoji ? `${index + 1}. ${podiumEmoji}` : `${index + 1}.`;
      listItem.appendChild(position);

      const playerInfo = document.createElement('div');
      playerInfo.className = 'collection-card__player';
      const name = document.createElement('strong');
      name.textContent = entry.player?.fullName || 'Jugador';
      playerInfo.appendChild(name);
      const stats = document.createElement('span');
      stats.textContent = `${entry.points ?? 0} pts · ${entry.wins ?? 0} victorias`;
      playerInfo.appendChild(stats);
      listItem.appendChild(playerInfo);

      const matchesPlayed = document.createElement('span');
      matchesPlayed.className = 'collection-card__points';
      matchesPlayed.textContent = `${entry.matchesPlayed ?? 0} jugados`;
      listItem.appendChild(matchesPlayed);

      list.appendChild(listItem);
    });

    card.appendChild(list);
  }

  return card;
}

function renderLeagueRankingCards(groups = []) {
  if (!leagueRankingCards) return;
  leagueRankingCards.innerHTML = '';

  if (!Array.isArray(groups) || !groups.length) {
    leagueRankingCards.innerHTML = '<p class="empty-state">Aún no hay categorías disponibles.</p>';
    return;
  }

  let hasContent = false;

  groups.forEach((group) => {
    const categories = Array.isArray(group?.categories) ? group.categories : [];
    if (!categories.length) {
      return;
    }

    const wrapper = document.createElement('section');
    wrapper.className = 'league-ranking-group';

    const header = document.createElement('div');
    header.className = 'league-ranking-group__header';

    const title = document.createElement('h4');
    title.className = 'league-ranking-group__title';
    title.textContent = group?.league?.name || 'Liga';
    header.appendChild(title);

    const meta = document.createElement('span');
    meta.className = 'league-ranking-group__meta';
    const totalCategories = categories.length;
    meta.textContent = `${totalCategories} ${
      totalCategories === 1 ? 'categoría' : 'categorías'
    }`;
    header.appendChild(meta);

    wrapper.appendChild(header);

    const categoryContainer = document.createElement('div');
    categoryContainer.className = 'league-ranking-group__categories';

    categories.forEach((categorySummary) => {
      const card = createLeagueRankingCategoryCard({
        ...categorySummary,
        league: categorySummary.league || group.league,
      });
      categoryContainer.appendChild(card);
    });

    wrapper.appendChild(categoryContainer);
    leagueRankingCards.appendChild(wrapper);
    hasContent = true;
  });

  if (!hasContent) {
    leagueRankingCards.innerHTML = '<p class="empty-state">Aún no hay categorías disponibles.</p>';
  }
}

function renderLeagueEnrolledPagination(totalPages, currentPage) {
  if (!leagueEnrolledPagination) return;

  if (!Number.isFinite(totalPages) || totalPages <= 1) {
    leagueEnrolledPagination.innerHTML = '';
    leagueEnrolledPagination.hidden = true;
    return;
  }

  leagueEnrolledPagination.hidden = false;
  leagueEnrolledPagination.innerHTML = '';

  for (let page = 1; page <= totalPages; page += 1) {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'league-enrolled-pagination__button';
    button.dataset.page = String(page);
    button.textContent = String(page);
    if (page === currentPage) {
      button.classList.add('is-active');
      button.setAttribute('aria-current', 'page');
    }
    leagueEnrolledPagination.appendChild(button);
  }
}

function renderLeagueEnrolledPlayers(entries = []) {
  if (!leagueEnrolledPlayersList) return;

  const players = Array.isArray(entries) ? entries : [];
  const pageSize = LEAGUE_ENROLLED_PAGE_SIZE;
  const totalPages = Math.max(1, Math.ceil(players.length / pageSize));

  const desiredPage = Number(state.leagueDashboardPlayersPage) || 1;
  const currentPage = Math.min(Math.max(desiredPage, 1), totalPages);
  state.leagueDashboardPlayersPage = currentPage;

  leagueEnrolledPlayersList.innerHTML = '';

  if (!players.length) {
    leagueEnrolledPlayersList.innerHTML =
      '<li class="empty-state">Aún no hay jugadores inscritos.</li>';
    if (leagueEnrolledPagination) {
      leagueEnrolledPagination.hidden = true;
      leagueEnrolledPagination.innerHTML = '';
    }
    return;
  }

  const startIndex = (currentPage - 1) * pageSize;
  const pagePlayers = players.slice(startIndex, startIndex + pageSize);

  pagePlayers.forEach((entry) => {
    const item = document.createElement('li');
    item.className = 'league-enrolled-item';

    const playerInfo = document.createElement('div');
    playerInfo.className = 'league-enrolled-player';
    const player = entry?.player || {};
    playerInfo.appendChild(createAvatarElement(player, { size: 'sm' }));

    const name = document.createElement('strong');
    name.textContent = getPlayerDisplayName(player);
    playerInfo.appendChild(name);

    item.appendChild(playerInfo);

    if (entry?.category?.name) {
      const categoryTag = document.createElement('span');
      categoryTag.className = 'tag league-enrolled-category';
      categoryTag.textContent = entry.category.name;
      applyCategoryTagColor(categoryTag, entry.category.color, { backgroundAlpha: 0.22 });
      item.appendChild(categoryTag);
    }

    leagueEnrolledPlayersList.appendChild(item);
  });

  renderLeagueEnrolledPagination(totalPages, currentPage);
}

function renderTournamentDashboard(summary) {
  state.tournamentDashboard = summary || null;
  const metrics = summary?.metrics || {};

  if (tournamentMetricActive) {
    tournamentMetricActive.textContent = String(metrics.tournaments ?? 0);
  }
  if (tournamentMetricCategories) {
    tournamentMetricCategories.textContent = String(metrics.categories ?? 0);
  }
  if (tournamentMetricUpcoming) {
    tournamentMetricUpcoming.textContent = String(metrics.upcomingMatches ?? 0);
  }

  renderTournamentDrawCards(summary?.categories || []);
  renderDashboardMatchList(
    summary?.upcomingMatches || [],
    tournamentUpcomingMatchesList,
    'No hay partidos de torneo programados.',
    { includeScope: true }
  );
}

function renderTournamentDrawCards(categories = []) {
  if (!tournamentDrawCards) return;
  tournamentDrawCards.innerHTML = '';

  if (!Array.isArray(categories) || !categories.length) {
    tournamentDrawCards.innerHTML = '<p class="empty-state">No hay cuadros publicados por ahora.</p>';
    return;
  }

  categories.forEach((category) => {
    const card = document.createElement('div');
    card.className = 'collection-card';

    const header = document.createElement('div');
    header.className = 'collection-card__header';

    const title = document.createElement('div');
    title.className = 'collection-card__title';
    if (category.color) {
      const indicator = createCategoryColorIndicator(category.color, category.name);
      if (indicator) {
        title.appendChild(indicator);
      }
    }
    title.appendChild(document.createTextNode(category.name || 'Categoría'));
    header.appendChild(title);

    if (category.tournament?.name) {
      const subtitle = document.createElement('span');
      subtitle.className = 'collection-card__subtitle';
      subtitle.textContent = category.tournament.name;
      header.appendChild(subtitle);
    }

    card.appendChild(header);

    const meta = document.createElement('div');
    meta.className = 'collection-card__meta';
    const statusLabel = TOURNAMENT_CATEGORY_STATUS_LABELS[category.status] || category.status;
    meta.textContent = `${statusLabel} · ${category.drawMatches ?? 0} partidos en cuadro`;
    card.appendChild(meta);

    const summary = Array.isArray(category.drawSummary) ? category.drawSummary : [];
    if (!summary.length) {
      const empty = document.createElement('p');
      empty.className = 'empty-state';
      empty.textContent = 'Aún no se ha definido el cuadro.';
      card.appendChild(empty);
    } else {
      const list = document.createElement('ul');
      list.className = 'collection-card__list';

      summary.forEach((round) => {
        const listItem = document.createElement('li');
        listItem.className = 'collection-card__list-item';
        const label = document.createElement('span');
        label.className = 'collection-card__player';
        const name = document.createElement('strong');
        name.textContent = round.name || 'Ronda';
        label.appendChild(name);
        const stats = document.createElement('span');
        stats.textContent = `${round.completed ?? 0} / ${round.matches ?? 0} partidos completados`;
        label.appendChild(stats);
        listItem.appendChild(label);

        list.appendChild(listItem);
      });

      card.appendChild(list);
    }

    tournamentDrawCards.appendChild(card);
  });
}

async function loadGlobalOverview({ force = true } = {}) {
  if (!state.token) return;

  if (!force && state.globalOverview) {
    renderGlobalOverview(state.globalOverview);
    return;
  }

  try {
    const overview = await request('/dashboard/overview');
    renderGlobalOverview(overview);
  } catch (error) {
    renderGlobalOverview(null);
    showGlobalMessage(error.message, 'error');
  }
}

async function loadLeagueDashboard({ force = true } = {}) {
  if (!state.token) return;

  if (!force && state.leagueDashboard) {
    renderLeagueDashboard(state.leagueDashboard);
    return;
  }

  try {
    const summary = await request('/dashboard/leagues');
    renderLeagueDashboard(summary);
  } catch (error) {
    renderLeagueDashboard(null);
    showGlobalMessage(error.message, 'error');
  }
}

async function loadTournamentDashboard({ force = true } = {}) {
  if (!state.token) return;

  if (!force && state.tournamentDashboard) {
    renderTournamentDashboard(state.tournamentDashboard);
    return;
  }

  try {
    const summary = await request('/dashboard/tournaments');
    renderTournamentDashboard(summary);
  } catch (error) {
    renderTournamentDashboard(null);
    showGlobalMessage(error.message, 'error');
  }
}

function getTournamentById(tournamentId) {
  if (!tournamentId) return null;
  const normalized = typeof tournamentId === 'string' ? tournamentId : normalizeId(tournamentId);
  if (!normalized) return null;
  return state.tournaments.find((tournament) => normalizeId(tournament) === normalized) || null;
}

function getTournamentCategories(tournamentId) {
  const normalized = typeof tournamentId === 'string' ? tournamentId : normalizeId(tournamentId);
  if (!normalized) return [];

  const detail = state.tournamentDetails.get(normalized);
  if (Array.isArray(detail?.categories) && detail.categories.length) {
    return detail.categories;
  }

  const tournament = getTournamentById(normalized);
  if (Array.isArray(tournament?.categories)) {
    return tournament.categories;
  }

  return [];
}

function getTournamentCategoryById(tournamentId, categoryId) {
  const normalizedCategoryId = normalizeId(categoryId);
  if (!normalizedCategoryId) {
    return null;
  }

  const categories = getTournamentCategories(tournamentId);
  return (
    categories.find((category) => normalizeId(category) === normalizedCategoryId) || null
  );
}

function buildSeedLookup(category) {
  const seeds = Array.isArray(category?.seeds) ? category.seeds : [];
  const bySeed = new Map();
  const byPlayer = new Map();

  seeds.forEach((entry) => {
    const playerId = normalizeId(entry?.player);
    const seedNumber = Number(entry?.seedNumber);
    if (playerId && Number.isFinite(seedNumber) && seedNumber > 0) {
      if (!bySeed.has(seedNumber)) {
        bySeed.set(seedNumber, playerId);
      }
      if (!byPlayer.has(playerId)) {
        byPlayer.set(playerId, seedNumber);
      }
    }
  });

  return { bySeed, byPlayer };
}

function scheduleOnNextAnimationFrame(callback) {
  if (typeof callback !== 'function') {
    return;
  }

  if (typeof requestAnimationFrame === 'function') {
    requestAnimationFrame(callback);
  } else {
    setTimeout(callback, 16);
  }
}

function runTournamentBracketAlignmentCallbacks() {
  if (!(state.tournamentBracketAlignmentCallbacks instanceof Set)) {
    return;
  }

  state.tournamentBracketAlignmentCallbacks.forEach((callback) => {
    if (typeof callback === 'function') {
      callback();
    }
  });
}

function ensureTournamentBracketResizeHandler() {
  if (typeof window === 'undefined') {
    return;
  }

  if (typeof state.tournamentBracketResizeHandler === 'function') {
    return;
  }

  let pendingFrame = null;
  const handler = () => {
    if (pendingFrame !== null && typeof cancelAnimationFrame === 'function') {
      cancelAnimationFrame(pendingFrame);
      pendingFrame = null;
    }

    const runCallbacks = () => {
      pendingFrame = null;
      runTournamentBracketAlignmentCallbacks();
    };

    if (typeof requestAnimationFrame === 'function') {
      pendingFrame = requestAnimationFrame(runCallbacks);
    } else {
      setTimeout(runCallbacks, 16);
    }
  };

  state.tournamentBracketResizeHandler = handler;
  window.addEventListener('resize', handler);
}

function applyTournamentBracketRoundOffsets(grid) {
  if (!(grid instanceof HTMLElement)) {
    return;
  }

  const roundLists = Array.from(grid.querySelectorAll('.bracket-round__matches')).filter(
    (roundList) => {
      const roundSection = roundList.closest('.bracket-round');
      return !(
        roundSection instanceof HTMLElement && roundSection.classList.contains('bracket-round--hidden')
      );
    }
  );

  if (!roundLists.length) {
    grid.style.removeProperty('--bracket-match-height');
    return;
  }

  const baseRound = roundLists[0];
  const baseMatches = Array.from(baseRound.querySelectorAll('.bracket-match')).filter(
    (match) => match instanceof HTMLElement
  );

  const baseMatch = baseMatches[0];
  if (!(baseMatch instanceof HTMLElement)) {
    return;
  }

  const baseRect = baseMatch.getBoundingClientRect();
  const baseHeight = baseRect?.height;

  if (!Number.isFinite(baseHeight) || baseHeight <= 0) {
    return;
  }

  let baseGap = null;
  for (let index = 1; index < baseMatches.length; index += 1) {
    const previousRect = baseMatches[index - 1].getBoundingClientRect();
    const currentRect = baseMatches[index].getBoundingClientRect();
    const spacing = currentRect.top - previousRect.bottom;

    if (Number.isFinite(spacing) && spacing >= 0) {
      baseGap = spacing;
      break;
    }
  }

  if (!Number.isFinite(baseGap) || baseGap < 0) {
    let computedGap = null;

    if (typeof window !== 'undefined' && typeof window.getComputedStyle === 'function') {
      const computedStyle = window.getComputedStyle(baseRound);

      if (computedStyle) {
        const gapCandidates = [computedStyle.rowGap, computedStyle.gap];
        for (let index = 0; index < gapCandidates.length; index += 1) {
          const value = Number.parseFloat(gapCandidates[index]);
          if (Number.isFinite(value) && value >= 0) {
            computedGap = value;
            break;
          }
        }
      }
    }

    if (Number.isFinite(computedGap) && computedGap >= 0) {
      baseGap = computedGap;
    } else {
      baseGap = 16;
    }
  }

  const matchStride = baseHeight + baseGap;
  grid.style.setProperty('--bracket-match-height', `${baseHeight}px`);

  const computeOffset = (roundIndex) => {
    if (roundIndex <= 0) {
      return 0;
    }
    const offset = ((Math.pow(2, roundIndex) - 1) * matchStride) / 2;
    return Math.max(0, offset);
  };

  const computeGap = (roundIndex) => {
    if (roundIndex <= 0) {
      return baseGap;
    }
    const desiredGap = Math.pow(2, roundIndex) * matchStride - baseHeight;
    return Math.max(0, desiredGap);
  };

  roundLists.forEach((roundList, roundIndex) => {
    if (!(roundList instanceof HTMLElement)) {
      return;
    }

    const offset = computeOffset(roundIndex);
    const gap = computeGap(roundIndex);

    if (roundIndex === 0 && offset === 0) {
      roundList.style.removeProperty('--bracket-round-offset');
    } else {
      roundList.style.setProperty('--bracket-round-offset', `${offset}px`);
    }

    roundList.style.setProperty('--bracket-match-gap', `${gap}px`);
  });
}

function scheduleTournamentBracketAlignment(section) {
  if (!(section instanceof HTMLElement)) {
    return;
  }

  const grid = section.querySelector('.tournament-bracket-grid');
  if (!(grid instanceof HTMLElement)) {
    return;
  }

  ensureTournamentBracketResizeHandler();

  const alignmentCallback = () => {
    if (!grid.isConnected) {
      if (state.tournamentBracketAlignmentCallbacks instanceof Set) {
        state.tournamentBracketAlignmentCallbacks.delete(alignmentCallback);
      }
      return;
    }

    applyTournamentBracketRoundOffsets(grid);
  };

  if (state.tournamentBracketAlignmentCallbacks instanceof Set) {
    state.tournamentBracketAlignmentCallbacks.add(alignmentCallback);
  }

  scheduleOnNextAnimationFrame(alignmentCallback);
}

function updateTournamentCategoryCache(tournamentId, updatedCategory) {
  const normalizedTournamentId = normalizeId(tournamentId);
  const normalizedCategoryId = normalizeId(updatedCategory);

  if (!normalizedTournamentId || !normalizedCategoryId) {
    return;
  }

  const normalizedCategory = {
    ...updatedCategory,
    _id: normalizedCategoryId,
  };

  const mergeCategories = (categories) => {
    if (!Array.isArray(categories)) {
      return [normalizedCategory];
    }

    let found = false;
    const next = categories.map((category) => {
      if (normalizeId(category) === normalizedCategoryId) {
        found = true;
        return { ...category, ...normalizedCategory };
      }
      return category;
    });

    if (!found) {
      next.push(normalizedCategory);
    }

    return next;
  };

  if (state.tournamentDetails instanceof Map && state.tournamentDetails.has(normalizedTournamentId)) {
    const detail = state.tournamentDetails.get(normalizedTournamentId);
    const categories = mergeCategories(detail?.categories);
    state.tournamentDetails.set(normalizedTournamentId, {
      ...detail,
      categories,
    });
  }

  if (Array.isArray(state.tournaments) && state.tournaments.length) {
    state.tournaments = state.tournaments.map((tournament) => {
      if (normalizeId(tournament) !== normalizedTournamentId) {
        return tournament;
      }
      const categories = mergeCategories(tournament?.categories);
      return { ...tournament, categories };
    });
  }
}

function renderTournaments(tournaments = state.tournaments) {
  if (!tournamentsList) return;
  tournamentsList.innerHTML = '';

  if (!Array.isArray(tournaments) || !tournaments.length) {
    tournamentsList.innerHTML =
      '<li class="empty-state">Registra un torneo para comenzar a organizar nuevos eventos.</li>';
    if (tournamentDetailTitle) {
      tournamentDetailTitle.textContent = 'Detalle del torneo';
    }
    if (tournamentDetailSubtitle) {
      tournamentDetailSubtitle.textContent = 'Selecciona un torneo para ver la información ampliada.';
    }
    if (tournamentDetailBody) {
      tournamentDetailBody.innerHTML =
        '<p class="empty-state">No hay torneos registrados en este momento.</p>';
    }
    return;
  }

  const activeId = state.selectedTournamentId;

  tournaments.forEach((tournament) => {
    const tournamentId = normalizeId(tournament);
    if (!tournamentId) {
      return;
    }

    const item = document.createElement('li');
    if (tournamentId === activeId) {
      item.classList.add('is-active');
    }

    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'list-item-button';
    button.dataset.tournamentId = tournamentId;

    const title = document.createElement('strong');
    title.textContent = tournament.name || 'Torneo';
    button.appendChild(title);

    const meta = document.createElement('div');
    meta.className = 'meta';

    const statusValue = tournament.status || 'inscripcion';
    const statusTag = document.createElement('span');
    statusTag.className = `tag status-${statusValue}`;
    statusTag.textContent = formatTournamentStatusLabel(statusValue);
    meta.appendChild(statusTag);

    const dateSpan = document.createElement('span');
    dateSpan.textContent = formatTournamentDateRange(tournament);
    meta.appendChild(dateSpan);

    if (tournament.registrationCloseDate) {
      const closeSpan = document.createElement('span');
      closeSpan.textContent = `Inscripciones: ${formatShortDate(tournament.registrationCloseDate)}`;
      meta.appendChild(closeSpan);
    }

    const categoryCount = Array.isArray(tournament.categories) ? tournament.categories.length : 0;
    const categorySpan = document.createElement('span');
    categorySpan.textContent = `${categoryCount} ${categoryCount === 1 ? 'categoría' : 'categorías'}`;
    meta.appendChild(categorySpan);

    const pendingTotal = Array.isArray(tournament.categories)
      ? tournament.categories.reduce((acc, category) => {
          const pending = Number(
            category?.pendingEnrollmentCount || category?.enrollmentStats?.pending || 0
          );
          return Number.isFinite(pending) ? acc + pending : acc;
        }, 0)
      : 0;
    if (isAdmin() && pendingTotal > 0) {
      const pendingSpan = document.createElement('span');
      pendingSpan.className = 'tag';
      pendingSpan.textContent =
        pendingTotal === 1
          ? '1 solicitud pendiente'
          : `${pendingTotal} solicitudes pendientes`;
      meta.appendChild(pendingSpan);
    }

    button.appendChild(meta);
    item.appendChild(button);
    tournamentsList.appendChild(item);
  });
}

function renderTournamentDetail() {
  if (!tournamentDetailBody) return;

  if (tournamentAdminEnrollButton) {
    tournamentAdminEnrollButton.hidden = true;
    tournamentAdminEnrollButton.disabled = true;
    delete tournamentAdminEnrollButton.dataset.tournamentId;
  }

  const tournamentId = state.selectedTournamentId;
  updateTournamentActionAvailability();
  if (!tournamentId) {
    if (tournamentDetailTitle) {
      tournamentDetailTitle.textContent = 'Detalle del torneo';
    }
    if (tournamentDetailSubtitle) {
      tournamentDetailSubtitle.textContent = 'Selecciona un torneo para ver la información ampliada.';
    }
    tournamentDetailBody.innerHTML =
      '<p class="empty-state">Selecciona un torneo de la lista para ver sus detalles.</p>';
    return;
  }

  const tournament = getTournamentById(tournamentId);
  const detail = state.tournamentDetails.get(tournamentId) || tournament;
  if (!detail) {
    if (tournamentDetailSubtitle) {
      tournamentDetailSubtitle.textContent = 'Selecciona un torneo para ver la información ampliada.';
    }
    tournamentDetailBody.innerHTML =
      '<p class="empty-state">No se encontró información del torneo seleccionado.</p>';
    return;
  }

  if (tournamentDetailTitle) {
    tournamentDetailTitle.textContent = detail.name || tournament?.name || 'Torneo';
  }
  if (tournamentDetailSubtitle) {
    tournamentDetailSubtitle.textContent = formatTournamentDateRange(detail);
  }

  if (tournamentAdminEnrollButton) {
    const options = detail?.adminEnrollmentOptions;
    const canShow =
      isAdmin() &&
      Boolean(options?.canEnrollPlayers) &&
      Array.isArray(options?.categories) &&
      options.categories.length > 0;
    tournamentAdminEnrollButton.hidden = !canShow;
    tournamentAdminEnrollButton.disabled = !canShow;
    if (canShow) {
      tournamentAdminEnrollButton.dataset.tournamentId = tournamentId;
    } else {
      delete tournamentAdminEnrollButton.dataset.tournamentId;
    }
  }

  tournamentDetailBody.innerHTML = '';
  const fragment = document.createDocumentFragment();
  const layout = document.createElement('div');
  layout.className = 'tournament-detail__layout';

  const content = document.createElement('div');
  content.className = 'tournament-detail__content';
  layout.appendChild(content);

  const posterUrl = typeof detail.poster === 'string' ? detail.poster.trim() : '';
  if (posterUrl) {
    const poster = document.createElement('img');
    poster.className = 'tournament-detail__poster';
    poster.src = posterUrl;
    poster.alt = detail.name ? `Afiche del torneo ${detail.name}` : 'Afiche del torneo';
    layout.appendChild(poster);
  }

  const header = document.createElement('div');
  header.className = 'tournament-detail__header';

  const meta = document.createElement('div');
  meta.className = 'meta';
  const statusValue = detail.status || tournament?.status || 'inscripcion';
  const statusTag = document.createElement('span');
  statusTag.className = `tag status-${statusValue}`;
  statusTag.textContent = formatTournamentStatusLabel(statusValue);
  meta.appendChild(statusTag);

  const dateSpan = document.createElement('span');
  dateSpan.textContent = formatTournamentDateRange(detail);
  meta.appendChild(dateSpan);
  header.appendChild(meta);

  if (detail.description) {
    const description = document.createElement('p');
    description.className = 'tournament-detail__description';
    description.textContent = detail.description;
    header.appendChild(description);
  }

  const availableEnrollmentCategories = getTournamentCategories(tournamentId).filter((category) => {
    const id = normalizeId(category);
    if (!id) return false;
    return Boolean(category?.canRequestEnrollment);
  });

  if (!isAdmin() && state.token && availableEnrollmentCategories.length) {
    const actions = document.createElement('div');
    actions.className = 'tournament-detail__actions';

    const enrollButton = document.createElement('button');
    enrollButton.type = 'button';
    enrollButton.className = 'primary';
    enrollButton.dataset.tournamentAction = 'open-enrollment';
    enrollButton.dataset.tournamentId = tournamentId;
    enrollButton.textContent = 'Inscribirse';
    actions.appendChild(enrollButton);

    header.appendChild(actions);
  }

  content.appendChild(header);

  const metaItems = [];
  if (detail.startDate) {
    metaItems.push(['Inicio', formatDate(detail.startDate)]);
  }
  if (detail.endDate) {
    metaItems.push(['Finalización', formatDate(detail.endDate)]);
  }
  if (detail.registrationCloseDate) {
    metaItems.push(['Cierre de inscripciones', formatDate(detail.registrationCloseDate)]);
  }
  if (detail.createdAt) {
    metaItems.push(['Creado', formatDate(detail.createdAt)]);
  }

  if (typeof detail.hasShirt === 'boolean') {
    metaItems.push(['Camiseta', detail.hasShirt ? 'Sí' : 'No']);
  }

  if (typeof detail.hasGiftBag === 'boolean') {
    metaItems.push(['Bolsa de regalo', detail.hasGiftBag ? 'Sí' : 'No']);
  }

  if (metaItems.length) {
    const metaContainer = document.createElement('div');
    metaContainer.className = 'tournament-detail__meta';
    metaItems.forEach(([label, value]) => {
      const row = document.createElement('div');
      row.className = 'tournament-detail__meta-item';
      const labelSpan = document.createElement('span');
      labelSpan.className = 'tournament-detail__meta-label';
      labelSpan.textContent = label;
      const valueSpan = document.createElement('span');
      valueSpan.textContent = value;
      row.appendChild(labelSpan);
      row.appendChild(valueSpan);
      metaContainer.appendChild(row);
    });
    content.appendChild(metaContainer);
  }

  const fees = Array.isArray(detail.fees)
    ? detail.fees.filter((fee) => {
        const memberAmount = Number(fee.memberAmount);
        const nonMemberAmount = Number(fee.nonMemberAmount);
        const legacyAmount = Number(fee.amount);
        const hasMemberAmount = Number.isFinite(memberAmount) && memberAmount >= 0;
        const hasNonMemberAmount = Number.isFinite(nonMemberAmount) && nonMemberAmount >= 0;
        const hasLegacyAmount = Number.isFinite(legacyAmount) && legacyAmount >= 0;
        return hasMemberAmount || hasNonMemberAmount || hasLegacyAmount;
      })
    : [];
  if (fees.length) {
    const feesWrapper = document.createElement('div');
    const heading = document.createElement('h4');
    heading.className = 'tournament-section-title';
    heading.textContent = 'Cuotas de inscripción';
    feesWrapper.appendChild(heading);

    const feesList = document.createElement('div');
    feesList.className = 'tournament-detail__fees';
    fees.forEach((fee) => {
      const feeRow = document.createElement('div');
      feeRow.className = 'tournament-fee';

      const labelSpan = document.createElement('span');
      labelSpan.className = 'tournament-fee__label';
      labelSpan.textContent = fee.label || 'Cuota';

      const amountSpan = document.createElement('span');
      amountSpan.className = 'tournament-fee__amounts';

      const parts = [];
      const currency = fee.currency;
      const formatAmount = (value) =>
        formatCurrencyValue(value, currency) || `${Number(value) || 0}`;

      const memberAmount = Number(fee.memberAmount);
      if (Number.isFinite(memberAmount) && memberAmount >= 0) {
        parts.push(`Socios: ${formatAmount(memberAmount)}`);
      }

      const nonMemberAmount = Number(fee.nonMemberAmount);
      if (Number.isFinite(nonMemberAmount) && nonMemberAmount >= 0) {
        parts.push(`No socios: ${formatAmount(nonMemberAmount)}`);
      }

      const legacyAmount = Number(fee.amount);
      if (!parts.length && Number.isFinite(legacyAmount) && legacyAmount >= 0) {
        parts.push(formatAmount(legacyAmount));
      }

      amountSpan.textContent = parts.join(' · ');

      feeRow.appendChild(labelSpan);
      feeRow.appendChild(amountSpan);
      feesList.appendChild(feeRow);
    });

    feesWrapper.appendChild(feesList);
    content.appendChild(feesWrapper);
  }

  const categories = getTournamentCategories(tournamentId);
  if (categories.length) {
    const categoryWrapper = document.createElement('div');
    const heading = document.createElement('h4');
    heading.className = 'tournament-section-title';
    heading.textContent = `Categorías (${categories.length})`;
    categoryWrapper.appendChild(heading);

    const categoryList = document.createElement('div');
    categoryList.className = 'tournament-detail__categories';

    categories
      .slice()
      .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
      .forEach((category) => {
        const categoryCard = document.createElement('div');
        categoryCard.className = 'tournament-detail__category';

        const name = document.createElement('strong');
        name.textContent = category.name || 'Categoría';
        categoryCard.appendChild(name);

        const metaLine = document.createElement('div');
        metaLine.className = 'meta';

        const statusValue = category.status || 'inscripcion';
        const categoryStatus = document.createElement('span');
        categoryStatus.className = `tag status-${statusValue}`;
        categoryStatus.textContent = formatTournamentCategoryStatusLabel(statusValue);
        metaLine.appendChild(categoryStatus);

        if (category.gender) {
          const genderSpan = document.createElement('span');
          genderSpan.textContent = translateGender(category.gender);
          metaLine.appendChild(genderSpan);
        }

        if (category.matchType) {
          const typeSpan = document.createElement('span');
          typeSpan.textContent = formatTournamentMatchType(category.matchType);
          metaLine.appendChild(typeSpan);
        }

        if (category.matchFormat) {
          const formatSpan = document.createElement('span');
          formatSpan.textContent = formatTournamentMatchFormat(category.matchFormat);
          metaLine.appendChild(formatSpan);
        }

        const enrollmentStats = category.enrollmentStats || {};
        const totalEnrollments = Number.isFinite(Number(enrollmentStats.total))
          ? Number(enrollmentStats.total)
          : Number.isFinite(Number(category.enrollmentCount))
          ? Number(category.enrollmentCount)
          : 0;
        const confirmedEnrollments = Number.isFinite(Number(enrollmentStats.confirmed))
          ? Number(enrollmentStats.confirmed)
          : 0;
        const enrollmentSpan = document.createElement('span');
        enrollmentSpan.textContent = `${confirmedEnrollments}/${totalEnrollments} confirmadas`;
        metaLine.appendChild(enrollmentSpan);

        const matches = Number.isFinite(Number(category.matches)) ? Number(category.matches) : 0;
        const matchesSpan = document.createElement('span');
        matchesSpan.textContent = `${matches} ${matches === 1 ? 'partido' : 'partidos'}`;
        metaLine.appendChild(matchesSpan);

        const pendingCount = Number.isFinite(Number(enrollmentStats.pending))
          ? Number(enrollmentStats.pending)
          : Number(category.pendingEnrollmentCount || 0);
        if (isAdmin() && pendingCount > 0) {
          const pendingSpan = document.createElement('span');
          pendingSpan.textContent =
            pendingCount === 1
              ? '1 solicitud pendiente'
              : `${pendingCount} solicitudes pendientes`;
          metaLine.appendChild(pendingSpan);
        }

        categoryCard.appendChild(metaLine);

        const actions = document.createElement('div');
        actions.className = 'actions category-actions';
        let hasActions = false;

        const detailId = normalizeId(detail) || tournamentId;
        const categoryId = normalizeId(category);
        const userEnrollment = category.userEnrollment || null;

        if (userEnrollment?.status) {
          const enrollmentStatus = userEnrollment.status;
          const statusTag = document.createElement('span');
          statusTag.className =
            enrollmentStatus === 'confirmada' ? 'tag tag--success' : 'tag';
          statusTag.textContent = formatTournamentEnrollmentStatusLabel(enrollmentStatus);
          actions.appendChild(statusTag);
          hasActions = true;
        }

        if (!category.canRequestEnrollment && !userEnrollment && !isAdmin()) {
          const note = document.createElement('span');
          note.className = 'note';
          note.textContent = 'Inscripciones cerradas';
          actions.appendChild(note);
          hasActions = true;
        }

        if (hasActions) {
          categoryCard.appendChild(actions);
        }

        categoryList.appendChild(categoryCard);
      });

    categoryWrapper.appendChild(categoryList);
    content.appendChild(categoryWrapper);
  } else {
    const emptyNote = document.createElement('p');
    emptyNote.className = 'tournament-section-note';
    emptyNote.textContent = 'Este torneo aún no tiene categorías registradas.';
    content.appendChild(emptyNote);
  }

  fragment.appendChild(layout);
  tournamentDetailBody.appendChild(fragment);
}

async function openTournamentSelfEnrollmentModal({
  tournamentId = state.selectedTournamentId,
  categoryId = '',
  allowMultiple = false,
} = {}) {
  const normalizedTournamentId = tournamentId ? normalizeId(tournamentId) : '';
  const targetTournamentId = normalizedTournamentId || normalizeId(state.selectedTournamentId);

  if (!targetTournamentId) {
    showGlobalMessage('Selecciona un torneo para solicitar inscripción.', 'info');
    return;
  }

  if (!state.tournamentDetails.has(targetTournamentId)) {
    await refreshTournamentDetail(targetTournamentId);
  }

  const detail = state.tournamentDetails.get(targetTournamentId) || getTournamentById(targetTournamentId);
  if (!detail) {
    showGlobalMessage('No fue posible cargar la información del torneo.', 'error');
    return;
  }

  const categories = getTournamentCategories(targetTournamentId).filter((category) => {
    const id = normalizeId(category);
    if (!id) return false;
    if (category.canRequestEnrollment) return true;
    return categoryId && id === categoryId;
  });

  if (!categories.length) {
    showGlobalMessage('No hay categorías disponibles para solicitar inscripción.', 'info');
    return;
  }

  const requiresShirtSize = Boolean(detail.hasShirt);
  const availableSizes = Array.isArray(detail.shirtSizes)
    ? detail.shirtSizes.filter((size) => typeof size === 'string' && size.trim().length)
    : [];

  const form = document.createElement('form');
  form.className = 'form';

  let categorySelect = null;
  let categoryCountSelect = null;
  let categoryCheckboxes = [];
  let selectionHint = null;

  const sortedCategories = categories
    .slice()
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'));

  if (allowMultiple) {
    const countLabel = document.createElement('label');
    countLabel.textContent = 'Número de categorías';
    const countSelect = document.createElement('select');
    countSelect.name = 'categoryCount';
    countSelect.required = true;

    sortedCategories.forEach((_, index) => {
      const option = document.createElement('option');
      const count = index + 1;
      option.value = String(count);
      option.textContent = count === 1 ? '1 categoría' : `${count} categorías`;
      countSelect.appendChild(option);
    });

    countLabel.appendChild(countSelect);
    form.appendChild(countLabel);

    const categoryFieldset = document.createElement('fieldset');
    categoryFieldset.className = 'checkbox-group';
    const legend = document.createElement('legend');
    legend.textContent = 'Categorías disponibles';
    categoryFieldset.appendChild(legend);

    selectionHint = document.createElement('p');
    selectionHint.className = 'form-hint';
    categoryFieldset.appendChild(selectionHint);

    categoryCheckboxes = sortedCategories.map((category) => {
      const id = normalizeId(category);
      if (!id) return null;
      const optionLabel = document.createElement('label');
      optionLabel.className = 'checkbox-option';
      const checkbox = document.createElement('input');
      checkbox.type = 'checkbox';
      checkbox.name = 'categoryIds';
      checkbox.value = id;
      optionLabel.appendChild(checkbox);
      const text = document.createElement('span');
      text.textContent = category.name || 'Categoría';
      optionLabel.appendChild(text);
      categoryFieldset.appendChild(optionLabel);
      return checkbox;
    }).filter(Boolean);

    form.appendChild(categoryFieldset);

    const updateSelectionHint = () => {
      const desired = Number(countSelect.value || '0');
      const selected = categoryCheckboxes.filter((checkbox) => checkbox.checked).length;
      if (desired > 0) {
        selectionHint.textContent =
          desired === 1
            ? `Selecciona 1 categoría (actualmente ${selected}).`
            : `Selecciona ${desired} categorías (actualmente ${selected}).`;
      } else {
        selectionHint.textContent = 'Selecciona las categorías en las que deseas inscribirte.';
      }
    };

    countSelect.addEventListener('change', () => {
      updateSelectionHint();
    });

    categoryCheckboxes.forEach((checkbox) => {
      checkbox.addEventListener('change', () => {
        updateSelectionHint();
      });
    });

    updateSelectionHint();
    categoryCountSelect = countSelect;
  } else {
    const categoryLabel = document.createElement('label');
    categoryLabel.textContent = 'Categoría';
    const singleSelect = document.createElement('select');
    singleSelect.name = 'categoryId';
    singleSelect.required = true;

    sortedCategories.forEach((category) => {
      const id = normalizeId(category);
      if (!id) return;
      const option = document.createElement('option');
      option.value = id;
      option.textContent = category.name || 'Categoría';
      singleSelect.appendChild(option);
    });

    if (categoryId) {
      singleSelect.value = categoryId;
    }

    categoryLabel.appendChild(singleSelect);
    form.appendChild(categoryLabel);
    categorySelect = singleSelect;
  }

  let shirtField = null;

  if (requiresShirtSize) {
    const shirtLabel = document.createElement('label');
    shirtLabel.textContent = 'Talla de camiseta';
    if (availableSizes.length) {
      const shirtSelect = document.createElement('select');
      shirtSelect.name = 'shirtSize';
      shirtSelect.required = true;
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Selecciona una talla';
      shirtSelect.appendChild(placeholder);
      availableSizes.forEach((size) => {
        const option = document.createElement('option');
        option.value = size;
        option.textContent = size;
        shirtSelect.appendChild(option);
      });
      shirtLabel.appendChild(shirtSelect);
      shirtField = shirtSelect;
    } else {
      const shirtInput = document.createElement('input');
      shirtInput.type = 'text';
      shirtInput.name = 'shirtSize';
      shirtInput.required = true;
      shirtInput.placeholder = 'Indica tu talla';
      shirtInput.maxLength = 20;
      shirtLabel.appendChild(shirtInput);
      shirtField = shirtInput;
    }
    form.appendChild(shirtLabel);
  }

  const actions = document.createElement('div');
  actions.className = 'form-actions';

  const submitButton = document.createElement('button');
  submitButton.type = 'submit';
  submitButton.className = 'primary';
  submitButton.textContent = allowMultiple ? 'Enviar solicitudes' : 'Enviar solicitud';
  actions.appendChild(submitButton);

  const cancelButton = document.createElement('button');
  cancelButton.type = 'button';
  cancelButton.className = 'ghost';
  cancelButton.dataset.action = 'cancel';
  cancelButton.textContent = 'Cancelar';
  actions.appendChild(cancelButton);

  form.appendChild(actions);

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    let selectedCategories = [];

    if (allowMultiple) {
      const desiredCount = Number(categoryCountSelect?.value || '0');
      const checked = categoryCheckboxes.filter((checkbox) => checkbox.checked).map((checkbox) => checkbox.value);
      if (!desiredCount || !Number.isFinite(desiredCount)) {
        setStatusMessage(status, 'error', 'Selecciona cuántas categorías deseas.');
        return;
      }
      if (checked.length !== desiredCount) {
        setStatusMessage(
          status,
          'error',
          desiredCount === 1
            ? 'Debes seleccionar exactamente 1 categoría.'
            : `Debes seleccionar exactamente ${desiredCount} categorías.`,
        );
        return;
      }
      selectedCategories = checked;
    } else if (categorySelect) {
      const selectedCategory = categorySelect.value;
      if (!selectedCategory) {
        setStatusMessage(status, 'error', 'Selecciona una categoría.');
        return;
      }
      selectedCategories = [selectedCategory];
    }

    const payload = {};
    if (requiresShirtSize && shirtField) {
      const value = (shirtField.value || '').trim();
      if (!value) {
        setStatusMessage(status, 'error', 'Indica tu talla de camiseta.');
        return;
      }
      payload.shirtSize = value;
    }

    submitButton.disabled = true;
    setStatusMessage(status, 'info', allowMultiple ? 'Enviando solicitudes...' : 'Enviando solicitud...');

    const processedCategories = [];
    const refreshContext = async () => {
      state.tournamentDetails.delete(targetTournamentId);
      await Promise.all([
        reloadTournaments({ selectTournamentId: targetTournamentId }),
        refreshTournamentDetail(targetTournamentId),
      ]);
      if (state.notificationBase !== null) {
        renderNotifications(state.notificationBase || []);
      }
    };

    try {
      for (const id of selectedCategories) {
        await request(`/tournaments/${targetTournamentId}/categories/${id}/enrollments`, {
          method: 'POST',
          body: payload,
        });
        processedCategories.push(id);
      }

      const successStatusMessage =
        selectedCategories.length > 1
          ? 'Solicitudes enviadas correctamente.'
          : 'Solicitud enviada correctamente.';
      setStatusMessage(status, 'success', successStatusMessage);
      closeModal();
      const successMessage =
        selectedCategories.length > 1
          ? 'Solicitudes enviadas. Un administrador las revisará en breve.'
          : 'Solicitud enviada. Un administrador la revisará en breve.';
      showGlobalMessage(successMessage);
      await refreshContext();
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
      submitButton.disabled = false;
      if (processedCategories.length) {
        await refreshContext();
      }
    }
  });

  cancelButton.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  openModal({
    title: allowMultiple ? 'Inscribirse en el torneo' : 'Solicitar inscripción',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

async function openTournamentAdminEnrollmentModal({
  tournamentId = state.selectedTournamentId,
} = {}) {
  if (!isAdmin()) {
    return;
  }

  const normalizedTournamentId = tournamentId
    ? normalizeId(tournamentId)
    : normalizeId(state.selectedTournamentId);

  if (!normalizedTournamentId) {
    showGlobalMessage('Selecciona un torneo para inscribir jugadores.', 'info');
    return;
  }

  if (!state.tournamentDetails.has(normalizedTournamentId)) {
    try {
      await refreshTournamentDetail(normalizedTournamentId);
    } catch (error) {
      showGlobalMessage(
        error.message || 'No fue posible cargar el detalle del torneo.',
        'error'
      );
      return;
    }
  }

  const detail =
    state.tournamentDetails.get(normalizedTournamentId) ||
    getTournamentById(normalizedTournamentId);
  const options = detail?.adminEnrollmentOptions;

  if (
    !options?.canEnrollPlayers ||
    !Array.isArray(options.categories) ||
    options.categories.length === 0
  ) {
    showGlobalMessage('No hay categorías disponibles para inscribir jugadores.', 'info');
    return;
  }

  try {
    await ensurePlayersLoaded();
  } catch (error) {
    return;
  }

  const players = Array.isArray(state.players) ? state.players : [];
  const eligiblePlayers = players
    .filter((player) => entityHasRole(player, 'player'))
    .sort((a, b) => (a.fullName || '').localeCompare(b.fullName || '', 'es'));

  if (!eligiblePlayers.length) {
    showGlobalMessage('No hay jugadores disponibles para inscribir.', 'info');
    return;
  }

  const categories = options.categories
    .map((category) => {
      const id = normalizeId(category);
      if (!id) {
        return null;
      }
      const label = category.menuTitle || category.name || 'Categoría';
      return {
        id,
        label,
        gender: category.gender || '',
        matchType: category.matchType || '',
      };
    })
    .filter(Boolean)
    .sort((a, b) => a.label.localeCompare(b.label, 'es'));

  if (!categories.length) {
    showGlobalMessage('No hay categorías disponibles para inscribir jugadores.', 'info');
    return;
  }

  const rawMaxSelectable = Number(options.maxSelectableCategories);
  const maxSelectable = Number.isFinite(rawMaxSelectable) && rawMaxSelectable > 0
    ? Math.min(rawMaxSelectable, categories.length)
    : categories.length;

  const requiresShirtSize = Boolean(options.requiresShirtSize);
  const hasShirtOption = Boolean(options.hasShirt || requiresShirtSize);
  const allowedShirtSizes = Array.isArray(options.shirtSizes)
    ? options.shirtSizes
        .map((size) => (typeof size === 'string' ? size.trim().toUpperCase() : ''))
        .filter((size, index, array) => size && array.indexOf(size) === index)
    : [];

  const form = document.createElement('form');
  form.className = 'form';

  const playerLabel = document.createElement('label');
  playerLabel.textContent = 'Jugador';
  const playerSelect = document.createElement('select');
  playerSelect.name = 'userId';
  playerSelect.required = true;
  playerSelect.innerHTML = '<option value="">Selecciona un jugador</option>';
  eligiblePlayers.forEach((player) => {
    const option = document.createElement('option');
    option.value = player._id || player.id || '';
    option.textContent = player.fullName || player.email || 'Jugador';
    playerSelect.appendChild(option);
  });
  playerLabel.appendChild(playerSelect);
  form.appendChild(playerLabel);

  let categoryCountSelect = null;
  if (maxSelectable > 1) {
    const countLabel = document.createElement('label');
    countLabel.textContent = 'Número de categorías';
    categoryCountSelect = document.createElement('select');
    categoryCountSelect.name = 'categoryCount';
    categoryCountSelect.required = true;
    for (let count = 1; count <= maxSelectable; count += 1) {
      const option = document.createElement('option');
      option.value = String(count);
      option.textContent = count === 1 ? '1 categoría' : `${count} categorías`;
      categoryCountSelect.appendChild(option);
    }
    countLabel.appendChild(categoryCountSelect);
    form.appendChild(countLabel);
  }

  const categoryFieldset = document.createElement('fieldset');
  categoryFieldset.className = 'checkbox-group';
  const legend = document.createElement('legend');
  legend.textContent = 'Categorías disponibles';
  categoryFieldset.appendChild(legend);

  const selectionHint = document.createElement('p');
  selectionHint.className = 'form-hint';
  categoryFieldset.appendChild(selectionHint);

  const categoryCheckboxes = categories.map((category) => {
    const optionLabel = document.createElement('label');
    optionLabel.className = 'checkbox-option';
    const checkbox = document.createElement('input');
    checkbox.type = 'checkbox';
    checkbox.name = 'categoryIds';
    checkbox.value = category.id;
    optionLabel.appendChild(checkbox);
    const text = document.createElement('span');
    const details = [];
    if (category.gender) {
      details.push(translateGender(category.gender));
    }
    if (category.matchType) {
      details.push(formatTournamentMatchType(category.matchType));
    }
    text.textContent = details.length
      ? `${category.label} · ${details.join(' · ')}`
      : category.label;
    optionLabel.appendChild(text);
    categoryFieldset.appendChild(optionLabel);
    return checkbox;
  });

  form.appendChild(categoryFieldset);

  let shirtField = null;
  if (hasShirtOption) {
    const shirtLabel = document.createElement('label');
    shirtLabel.textContent = 'Talla de camiseta';
    const hint = document.createElement('span');
    hint.className = 'form-hint';
    hint.textContent = requiresShirtSize
      ? 'Obligatoria para completar la inscripción.'
      : 'Opcional; si no se indica se mantendrá la registrada en el perfil.';
    shirtLabel.appendChild(hint);

    if (allowedShirtSizes.length) {
      const select = document.createElement('select');
      select.name = 'shirtSize';
      select.innerHTML = '<option value="">Selecciona una talla</option>';
      allowedShirtSizes.forEach((size) => {
        const option = document.createElement('option');
        option.value = size;
        option.textContent = size;
        select.appendChild(option);
      });
      if (requiresShirtSize) {
        select.required = true;
      }
      shirtField = select;
      shirtLabel.appendChild(select);
    } else {
      const input = document.createElement('input');
      input.type = 'text';
      input.name = 'shirtSize';
      input.placeholder = 'Ej. S, M, L, XL';
      if (requiresShirtSize) {
        input.required = true;
      }
      shirtField = input;
      shirtLabel.appendChild(input);
    }

    form.appendChild(shirtLabel);
  }

  const actions = document.createElement('div');
  actions.className = 'form-actions';

  const submitButton = document.createElement('button');
  submitButton.type = 'submit';
  submitButton.className = 'primary';
  submitButton.textContent = 'Inscribir jugador';
  submitButton.disabled = true;
  actions.appendChild(submitButton);

  const cancelButton = document.createElement('button');
  cancelButton.type = 'button';
  cancelButton.className = 'ghost';
  cancelButton.textContent = 'Cancelar';
  actions.appendChild(cancelButton);

  form.appendChild(actions);

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const parseDesiredCount = () => {
    if (!categoryCountSelect) {
      return null;
    }
    const value = Number(categoryCountSelect.value || '0');
    return Number.isFinite(value) && value > 0 ? Math.min(value, maxSelectable) : null;
  };

  const countSelectedCategories = () =>
    categoryCheckboxes.filter((checkbox) => checkbox.checked).length;

  const updateSelectionHint = () => {
    if (!selectionHint) {
      return;
    }
    const desired = parseDesiredCount();
    const selected = countSelectedCategories();
    if (desired) {
      selectionHint.textContent =
        desired === 1
          ? `Selecciona 1 categoría (actualmente ${selected}).`
          : `Selecciona ${desired} categorías (actualmente ${selected}).`;
      return;
    }
    if (maxSelectable && maxSelectable < categories.length) {
      selectionHint.textContent =
        maxSelectable === 1
          ? 'Selecciona una única categoría disponible.'
          : `Selecciona hasta ${maxSelectable} categorías (actualmente ${selected}).`;
      return;
    }
    selectionHint.textContent = 'Selecciona las categorías en las que participará el jugador.';
  };

  const getSelectionLimit = () => {
    const desired = parseDesiredCount();
    if (desired) {
      return Math.min(desired, maxSelectable);
    }
    return maxSelectable;
  };

  const enforceCategoryLimit = () => {
    const limit = Math.max(1, getSelectionLimit());
    const selected = countSelectedCategories();
    categoryCheckboxes.forEach((checkbox) => {
      if (!checkbox.checked) {
        checkbox.disabled = selected >= limit;
      } else {
        checkbox.disabled = false;
      }
    });
    updateSelectionHint();
  };

  const getShirtValue = () => {
    if (!shirtField) {
      return '';
    }
    return (shirtField.value || '').trim();
  };

  const updateSubmitState = () => {
    const playerSelected = Boolean(playerSelect.value);
    const selectedCount = countSelectedCategories();
    const desired = parseDesiredCount();
    const limit = getSelectionLimit();
    const categoriesValid =
      selectedCount > 0 && (desired ? selectedCount === desired : selectedCount <= limit);
    const shirtValid = requiresShirtSize ? Boolean(getShirtValue()) : true;
    submitButton.disabled = !(playerSelected && categoriesValid && shirtValid);
  };

  function applyDefaultShirtSize() {
    if (!shirtField) {
      return;
    }
    const playerId = playerSelect.value || '';
    const player = eligiblePlayers.find((entry) => normalizeId(entry) === playerId);
    const defaultSize = player?.shirtSize
      ? String(player.shirtSize).trim().toUpperCase()
      : '';
    if (!defaultSize) {
      updateSubmitState();
      return;
    }
    if (shirtField.tagName === 'SELECT') {
      const optionsList = Array.from(shirtField.options);
      const matching = optionsList.find(
        (option) => (option.value || '').toUpperCase() === defaultSize
      );
      if (matching) {
        shirtField.value = matching.value;
      }
    } else if (!shirtField.value) {
      shirtField.value = defaultSize;
    }
    updateSubmitState();
  }

  categoryCheckboxes.forEach((checkbox) => {
    checkbox.addEventListener('change', () => {
      enforceCategoryLimit();
      updateSubmitState();
      setStatusMessage(status, '', '');
    });
  });

  if (categoryCountSelect) {
    categoryCountSelect.addEventListener('change', () => {
      enforceCategoryLimit();
      updateSubmitState();
      setStatusMessage(status, '', '');
    });
  }

  playerSelect.addEventListener('change', () => {
    applyDefaultShirtSize();
    updateSubmitState();
    setStatusMessage(status, '', '');
  });

  if (shirtField) {
    const eventName = shirtField.tagName === 'SELECT' ? 'change' : 'input';
    shirtField.addEventListener(eventName, () => {
      updateSubmitState();
      setStatusMessage(status, '', '');
    });
  }

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const playerId = playerSelect.value || '';
    if (!playerId) {
      setStatusMessage(status, 'error', 'Selecciona un jugador.');
      return;
    }

    const selectedCategories = categoryCheckboxes
      .filter((checkbox) => checkbox.checked)
      .map((checkbox) => checkbox.value);

    if (!selectedCategories.length) {
      setStatusMessage(status, 'error', 'Selecciona al menos una categoría.');
      return;
    }

    const desired = parseDesiredCount();
    const limit = getSelectionLimit();
    if (desired && selectedCategories.length !== desired) {
      setStatusMessage(
        status,
        'error',
        desired === 1
          ? 'Debes seleccionar exactamente 1 categoría.'
          : `Debes seleccionar exactamente ${desired} categorías.`,
      );
      return;
    }

    if (selectedCategories.length > limit) {
      setStatusMessage(
        status,
        'error',
        limit === 1
          ? 'Solo puedes seleccionar una categoría para este jugador.'
          : `Solo puedes seleccionar hasta ${limit} categorías para este jugador.`,
      );
      return;
    }

    let shirtSizeValue = getShirtValue();
    if (requiresShirtSize && !shirtSizeValue) {
      setStatusMessage(status, 'error', 'Indica la talla de camiseta del jugador.');
      return;
    }

    if (shirtSizeValue) {
      shirtSizeValue = shirtSizeValue.toUpperCase();
    }

    submitButton.disabled = true;
    setStatusMessage(status, 'info', 'Inscribiendo jugador...');

    const payload = {
      userId: playerId,
      categories: selectedCategories,
    };

    if (desired) {
      payload.categoryCount = desired;
    }

    if (shirtSizeValue) {
      payload.shirtSize = shirtSizeValue;
    }

    try {
      const response = await request(`/tournaments/${normalizedTournamentId}/enrollments`, {
        method: 'POST',
        body: payload,
      });
      const created = Array.isArray(response?.enrollments)
        ? response.enrollments
        : [];
      const processedCount = created.length || selectedCategories.length;
      const successMessage =
        processedCount > 1
          ? 'Jugador inscrito en las categorías seleccionadas.'
          : 'Jugador inscrito correctamente.';
      setStatusMessage(status, 'success', successMessage);
      closeModal();
      showGlobalMessage(successMessage);
      state.tournamentDetails.delete(normalizedTournamentId);
      await Promise.all([
        reloadTournaments({ selectTournamentId: normalizedTournamentId }),
        refreshTournamentDetail(normalizedTournamentId),
      ]);
    } catch (error) {
      submitButton.disabled = false;
      setStatusMessage(status, 'error', error.message);
    }
  });

  cancelButton.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  enforceCategoryLimit();
  updateSubmitState();
  applyDefaultShirtSize();
  setStatusMessage(status, '', '');

  openModal({
    title: 'Inscribir jugador en el torneo',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

async function loadTournamentDetail(tournamentId, { force = false } = {}) {
  const normalized = typeof tournamentId === 'string' ? tournamentId : normalizeId(tournamentId);
  if (!normalized) {
    return null;
  }

  if (!force && state.tournamentDetails.has(normalized)) {
    return state.tournamentDetails.get(normalized);
  }

  if (force && state.tournamentDetails instanceof Map) {
    state.tournamentDetails.delete(normalized);
  }

  const detail = await request(`/tournaments/${normalized}`);
  if (detail) {
    state.tournamentDetails.set(normalized, detail);
  }
  return detail;
}

async function refreshTournamentDetail(tournamentId = state.selectedTournamentId) {
  const normalized = typeof tournamentId === 'string' ? tournamentId : normalizeId(tournamentId);
  if (!normalized) {
    return;
  }

  pendingTournamentDetailId = normalized;
  try {
    renderTournamentDetail();
    const detail = await loadTournamentDetail(normalized, { force: true });
    if (!detail || pendingTournamentDetailId !== normalized) {
      return;
    }

    renderTournamentDetail();

    if (state.selectedTournamentCategoriesId === normalized) {
      renderTournamentCategories();
    }

    if (state.selectedEnrollmentTournamentId === normalized) {
      updateEnrollmentCategoryOptions();
    }

    if (state.selectedMatchTournamentId === normalized) {
      updateMatchCategoryOptions();
    }

    if (state.selectedBracketTournamentId === normalized) {
      updateBracketCategoryOptions();
    }
  } catch (error) {
    if (pendingTournamentDetailId === normalized && tournamentDetailBody) {
      tournamentDetailBody.innerHTML = `<p class="empty-state">${escapeHtml(
        error.message || 'No fue posible cargar el detalle del torneo.'
      )}</p>`;
    }
  } finally {
    if (pendingTournamentDetailId === normalized) {
      pendingTournamentDetailId = null;
    }
  }
}

function updateTournamentCategoriesPoster(detail) {
  if (!tournamentCategoriesPoster) return;

  tournamentCategoriesPoster.innerHTML = '';

  const posterUrl = typeof detail?.poster === 'string' ? detail.poster.trim() : '';
  if (!posterUrl) {
    tournamentCategoriesPoster.hidden = true;
    return;
  }

  const poster = document.createElement('img');
  poster.className = 'tournament-categories__poster-image';
  poster.src = posterUrl;
  poster.alt = detail?.name ? `Cartel del torneo ${detail.name}` : 'Cartel del torneo';
  poster.loading = 'lazy';
  tournamentCategoriesPoster.appendChild(poster);
  tournamentCategoriesPoster.hidden = false;
}

function renderTournamentCategories({ loading = false } = {}) {
  if (!tournamentCategoriesList || !tournamentCategoriesEmpty) return;
  tournamentCategoriesList.innerHTML = '';

  const tournamentId = state.selectedTournamentCategoriesId;
  if (!tournamentId) {
    updateTournamentCategoriesPoster(null);
    tournamentCategoriesEmpty.hidden = false;
    tournamentCategoriesEmpty.textContent = 'Selecciona un torneo para consultar sus categorías.';
    return;
  }

  const detail = state.tournamentDetails.get(tournamentId) || getTournamentById(tournamentId);
  updateTournamentCategoriesPoster(detail);

  if (loading) {
    tournamentCategoriesEmpty.hidden = false;
    tournamentCategoriesEmpty.textContent = 'Cargando categorías del torneo...';
    return;
  }

  const categories = getTournamentCategories(tournamentId);
  if (!Array.isArray(categories) || !categories.length) {
    tournamentCategoriesEmpty.hidden = false;
    const hasDetail = state.tournamentDetails.has(tournamentId);
    tournamentCategoriesEmpty.textContent = hasDetail
      ? 'No hay categorías registradas para este torneo.'
      : 'Cargando categorías del torneo...';
    return;
  }

  const admin = isAdmin();
  const tournamentPosterUrl = typeof detail?.poster === 'string' ? detail.poster.trim() : '';
  const tournamentName = detail?.name || '';
  tournamentCategoriesEmpty.hidden = true;

  categories
    .slice()
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
    .forEach((category) => {
      const item = document.createElement('li');
      const content = document.createElement('div');
      content.className = 'list-item__content';
      item.appendChild(content);

      const categoryId = normalizeId(category);
      if (categoryId) {
        item.dataset.categoryId = categoryId;
      }

      const categoryColor = getCategoryColor(category);
      if (categoryColor) {
        applyCategoryColorStyles(item, categoryColor, { backgroundAlpha: 0.14, borderAlpha: 0.3 });
      }

      const title = document.createElement('strong');
      title.textContent = category.name || 'Categoría';
      if (categoryColor) {
        const indicator = createCategoryColorIndicator(categoryColor, category.name);
        if (indicator) {
          title.classList.add('with-category-color');
          title.prepend(indicator);
        }
      }
      content.appendChild(title);

      const meta = document.createElement('div');
      meta.className = 'meta meta-category';

      if (category.gender) {
        const genderSpan = document.createElement('span');
        genderSpan.textContent = translateGender(category.gender);
        meta.appendChild(genderSpan);
      }

      if (category.matchType) {
        const matchTypeSpan = document.createElement('span');
        matchTypeSpan.textContent = formatTournamentMatchType(category.matchType);
        meta.appendChild(matchTypeSpan);
      }

      if (category.matchFormat) {
        const formatSpan = document.createElement('span');
        formatSpan.textContent = formatTournamentMatchFormat(category.matchFormat);
        meta.appendChild(formatSpan);
      }

      const statusValue = category.status || 'inscripcion';
      const statusTag = document.createElement('span');
      statusTag.className = `tag category-status category-status--${statusValue}`;
      statusTag.textContent = formatTournamentCategoryStatusLabel(statusValue);
      meta.appendChild(statusTag);

      content.appendChild(meta);

      if (category.description) {
        const description = document.createElement('p');
        description.textContent = category.description;
        content.appendChild(description);
      }

      const enrollmentStats = category.enrollmentStats || {};
      const totalEnrollments = Number.isFinite(Number(enrollmentStats.total))
        ? Number(enrollmentStats.total)
        : Number.isFinite(Number(category.enrollmentCount))
        ? Number(category.enrollmentCount)
        : 0;
      const confirmedEnrollments = Number.isFinite(Number(enrollmentStats.confirmed))
        ? Number(enrollmentStats.confirmed)
        : 0;
      const pendingEnrollments = Number.isFinite(Number(enrollmentStats.pending))
        ? Number(enrollmentStats.pending)
        : Number(category.pendingEnrollmentCount || 0);

      const enrollmentSummary = document.createElement('div');
      enrollmentSummary.className = 'meta meta-enrollment';
      enrollmentSummary.textContent = `Inscripciones confirmadas: ${confirmedEnrollments}/${totalEnrollments}`;
      content.appendChild(enrollmentSummary);

      if (admin && pendingEnrollments > 0) {
        const pendingSummary = document.createElement('div');
        pendingSummary.className = 'meta meta-enrollment';
        pendingSummary.textContent =
          pendingEnrollments === 1
            ? '1 solicitud pendiente'
            : `${pendingEnrollments} solicitudes pendientes`;
        content.appendChild(pendingSummary);
      }

      const matches = Number.isFinite(Number(category.matches)) ? Number(category.matches) : 0;
      const matchesMeta = document.createElement('div');
      matchesMeta.className = 'meta meta-matches';
      matchesMeta.textContent = `${matches} ${matches === 1 ? 'partido' : 'partidos'}`;
      content.appendChild(matchesMeta);

      const actions = document.createElement('div');
      actions.className = 'actions category-actions';
      let hasActions = false;

      const detailId = normalizeId(category?.tournament) || tournamentId;
      const userEnrollment = category.userEnrollment || null;

      if (admin) {
        const editButton = document.createElement('button');
        editButton.type = 'button';
        editButton.className = 'secondary';
        editButton.dataset.tournamentCategoryAction = 'edit';
        editButton.dataset.tournamentId = tournamentId;
        editButton.dataset.categoryId = categoryId;
        editButton.textContent = 'Editar';
        actions.appendChild(editButton);
        hasActions = true;

        if (categoryId) {
          const manageButton = document.createElement('button');
          manageButton.type = 'button';
          manageButton.dataset.tournamentCategoryAction = 'enrollments';
          manageButton.dataset.tournamentId = tournamentId;
          manageButton.dataset.categoryId = categoryId;
          if (pendingEnrollments > 0) {
            manageButton.className = 'primary';
            manageButton.textContent =
              pendingEnrollments === 1
                ? 'Revisar solicitud'
                : `Revisar ${pendingEnrollments} solicitudes`;
          } else {
            manageButton.className = 'ghost';
            manageButton.textContent = 'Gestionar inscripciones';
          }
          actions.appendChild(manageButton);
        }

        const deleteButton = document.createElement('button');
        deleteButton.type = 'button';
        deleteButton.className = 'danger';
        deleteButton.dataset.tournamentCategoryAction = 'delete';
        deleteButton.dataset.tournamentId = tournamentId;
        deleteButton.dataset.categoryId = categoryId;
        deleteButton.textContent = 'Eliminar';
        actions.appendChild(deleteButton);
      } else if (categoryId) {
        if (userEnrollment?.status) {
          const enrollmentStatus = userEnrollment.status;
          const statusClass = enrollmentStatus === 'confirmada' ? 'tag tag--success' : 'tag';
          const enrollmentTag = document.createElement('span');
          enrollmentTag.className = statusClass;
          enrollmentTag.textContent = formatTournamentEnrollmentStatusLabel(enrollmentStatus);
          actions.appendChild(enrollmentTag);
          hasActions = true;
        }

        if (category.canRequestEnrollment) {
          const requestButton = document.createElement('button');
          requestButton.type = 'button';
          requestButton.className = 'primary';
          requestButton.dataset.tournamentAction = 'request-enrollment';
          requestButton.dataset.tournamentId = detailId;
          requestButton.dataset.categoryId = categoryId;
          requestButton.textContent = 'Solicitar inscripción';
          actions.appendChild(requestButton);
          hasActions = true;
        } else if (!userEnrollment) {
          const note = document.createElement('span');
          note.className = 'note';
          note.textContent = 'Inscripciones cerradas';
          actions.appendChild(note);
          hasActions = true;
        }
      }

      if (!admin && userEnrollment?.status === 'cancelada') {
        const cancelledTag = document.createElement('span');
        cancelledTag.className = 'tag';
        cancelledTag.textContent = 'Inscripción cancelada';
        actions.appendChild(cancelledTag);
        hasActions = true;
      }

      if (hasActions || admin) {
        content.appendChild(actions);
      }

      const rawCategoryPoster = typeof category.poster === 'string' ? category.poster.trim() : '';
      const posterUrl = rawCategoryPoster || tournamentPosterUrl;
      if (posterUrl) {
        item.classList.add('list-item--with-poster');
        const posterWrapper = document.createElement('div');
        posterWrapper.className = 'list-item__poster';
        const poster = document.createElement('img');
        poster.className = 'list-item__poster-image';
        poster.src = posterUrl;
        if (rawCategoryPoster && category.name) {
          poster.alt = `Cartel de la categoría ${category.name}`;
        } else if (tournamentName) {
          poster.alt = `Cartel del torneo ${tournamentName}`;
        } else {
          poster.alt = 'Cartel del torneo';
        }
        poster.loading = 'lazy';
        posterWrapper.appendChild(poster);
        item.appendChild(posterWrapper);
      }

      tournamentCategoriesList.appendChild(item);
    });
}

function createTournamentDoublesCategoryCard(group) {
  const category = group?.category || {};
  const players = Array.isArray(group?.players) ? group.players : [];
  const pairs = Array.isArray(group?.pairs) ? group.pairs : [];

  const card = document.createElement('div');
  card.className = 'collection-card';

  const header = document.createElement('div');
  header.className = 'collection-card__header';

  const title = document.createElement('div');
  title.className = 'collection-card__title';
  const categoryColor = category.color;
  if (categoryColor) {
    const indicator = createCategoryColorIndicator(categoryColor, category.name);
    if (indicator) {
      title.appendChild(indicator);
    }
  }
  title.appendChild(
    document.createTextNode(category.menuTitle || category.name || 'Categoría de dobles')
  );
  header.appendChild(title);

  if (category.status) {
    const statusLabel = formatTournamentCategoryStatusLabel(category.status);
    if (statusLabel) {
      const subtitle = document.createElement('span');
      subtitle.className = 'collection-card__subtitle';
      subtitle.textContent = statusLabel;
      header.appendChild(subtitle);
    }
  }

  card.appendChild(header);

  const metaParts = [];
  const genderLabel = translateGender(category.gender);
  if (genderLabel) {
    metaParts.push(genderLabel);
  }
  const matchTypeLabel = formatTournamentMatchType(category.matchType);
  if (matchTypeLabel) {
    metaParts.push(matchTypeLabel);
  }
  const playerCount = players.length;
  metaParts.push(`${playerCount} ${playerCount === 1 ? 'jugador' : 'jugadores'}`);
  const pairCount = pairs.length;
  metaParts.push(`${pairCount} ${pairCount === 1 ? 'pareja' : 'parejas'}`);

  if (metaParts.length) {
    const meta = document.createElement('div');
    meta.className = 'collection-card__meta';
    meta.textContent = metaParts.join(' · ');
    card.appendChild(meta);
  }

  if (!players.length) {
    const empty = document.createElement('p');
    empty.className = 'empty-state';
    empty.textContent = 'Sin inscripciones registradas.';
    card.appendChild(empty);
    return card;
  }

  const categoryId = normalizeId(category);
  const pairByPlayerId = new Map();
  pairs.forEach((pair) => {
    const members = Array.isArray(pair.players) ? pair.players : [];
    members.forEach((member) => {
      const memberId = normalizeId(member);
      if (memberId) {
        pairByPlayerId.set(memberId, pair);
      }
    });
  });

  const formatMetadataLabel = (key) => {
    if (!key) return '';
    return key
      .toString()
      .split(/[_\s]+/)
      .filter(Boolean)
      .map((part) => `${part.charAt(0).toUpperCase()}${part.slice(1)}`)
      .join(' ');
  };

  const list = document.createElement('ul');
  list.className = 'collection-card__list';

  players.forEach((entry) => {
    const listItem = document.createElement('li');
    listItem.className = 'collection-card__list-item';

    const playerInfo = document.createElement('div');
    playerInfo.className = 'collection-card__player';

    const name = document.createElement('strong');
    const playerName = entry?.user?.fullName || entry?.user?.email || 'Jugador';
    name.textContent = playerName;
    playerInfo.appendChild(name);

    const details = [];
    const email = typeof entry?.user?.email === 'string' ? entry.user.email.trim() : '';
    if (email) {
      details.push(email);
    }
    const phone = typeof entry?.user?.phone === 'string' ? entry.user.phone.trim() : '';
    if (phone) {
      details.push(phone);
    }
    const scheduleValue = entry?.user?.preferredSchedule;
    if (scheduleValue) {
      details.push(`Horario: ${translateSchedule(scheduleValue)}`);
    }
    const seedNumber = Number(entry?.seedNumber);
    if (Number.isFinite(seedNumber) && seedNumber > 0) {
      details.push(`Siembra ${seedNumber}`);
    }
    const shirtSize = typeof entry?.shirtSize === 'string' ? entry.shirtSize.trim() : '';
    if (shirtSize) {
      details.push(`Talla ${shirtSize}`);
    }
    if (entry?.enrolledAt) {
      details.push(`Inscrito: ${formatShortDate(entry.enrolledAt)}`);
    }

    const metadata = entry?.metadata && typeof entry.metadata === 'object' ? entry.metadata : {};
    Object.entries(metadata).forEach(([key, value]) => {
      const text = typeof value === 'string' ? value.trim() : '';
      if (!text) {
        return;
      }
      const label = formatMetadataLabel(key);
      details.push(label ? `${label}: ${text}` : text);
    });

    const playerId = normalizeId(entry?.user);
    const pair = playerId ? pairByPlayerId.get(playerId) : null;
    if (pair) {
      const partners = Array.isArray(pair.players) ? pair.players : [];
      const partnerEntry = partners.find((member) => {
        const memberId = normalizeId(member);
        return memberId && memberId !== playerId;
      });
      const partnerNames = partners
        .map((member) => member.fullName || member.email || '')
        .filter(Boolean);
      const partnerName = partnerEntry?.fullName || partnerEntry?.email || partnerNames.join(' / ');
      if (partnerName) {
        details.push(`Pareja: ${partnerName}`);
      }
    }

    if (entry?.notes) {
      details.push(`Notas: ${entry.notes}`);
    }

    if (details.length) {
      const detailLine = document.createElement('span');
      detailLine.textContent = details.join(' · ');
      playerInfo.appendChild(detailLine);
    }

    listItem.appendChild(playerInfo);

    const statusValue = entry?.status;
    if (statusValue) {
      const statusTag = document.createElement('span');
      statusTag.className = statusValue === 'confirmada' ? 'tag tag--success' : 'tag';
      statusTag.textContent = formatTournamentEnrollmentStatusLabel(statusValue);
      listItem.appendChild(statusTag);
    }

    list.appendChild(listItem);
  });

  card.appendChild(list);

  const pairsTitle = document.createElement('h4');
  pairsTitle.className = 'collection-card__subtitle';
  pairsTitle.textContent = 'Parejas registradas';
  card.appendChild(pairsTitle);

  if (pairs.length) {
    const pairList = document.createElement('ul');
    pairList.className = 'collection-card__list';

    pairs.forEach((pair) => {
      const item = document.createElement('li');
      item.className = 'collection-card__list-item';

      const pairInfo = document.createElement('div');
      pairInfo.className = 'collection-card__player';
      const members = Array.isArray(pair.players) ? pair.players : [];
      const names = members.map((player) => player.fullName || player.email || 'Jugador');

      if (members.length) {
        const membersWrapper = document.createElement('div');
        membersWrapper.className = 'doubles-pair-members';

        members.forEach((player) => {
          const member = document.createElement('div');
          member.className = 'doubles-pair-member';

          member.appendChild(createAvatarElement(player, { size: 'sm' }));

          const memberName = document.createElement('strong');
          memberName.className = 'doubles-pair-member__name';
          memberName.textContent = player.fullName || player.email || 'Jugador';
          member.appendChild(memberName);

          membersWrapper.appendChild(member);
        });

        pairInfo.appendChild(membersWrapper);
      } else {
        const pairLabel = names.length ? names.join(' · ') : 'Pareja';
        const pairName = document.createElement('strong');
        pairName.textContent = pairLabel;
        pairInfo.appendChild(pairName);
      }

      if (pair.createdAt) {
        const created = document.createElement('span');
        created.textContent = `Creada: ${formatShortDate(pair.createdAt)}`;
        pairInfo.appendChild(created);
      }

      item.appendChild(pairInfo);

      if (isAdmin()) {
        const deleteButton = document.createElement('button');
        deleteButton.type = 'button';
        deleteButton.className = 'danger';
        deleteButton.textContent = 'Eliminar pareja';
        deleteButton.dataset.action = 'delete-pair';
        deleteButton.dataset.pairId = normalizeId(pair);
        deleteButton.dataset.categoryId = categoryId;
        item.appendChild(deleteButton);
      }

      pairList.appendChild(item);
    });

    card.appendChild(pairList);
  } else {
    const emptyPairs = document.createElement('p');
    emptyPairs.className = 'empty-state';
    emptyPairs.textContent = 'Aún no hay parejas registradas.';
    card.appendChild(emptyPairs);
  }

  if (isAdmin()) {
    const availablePlayers = players.filter((entry) => {
      const userId = normalizeId(entry?.user);
      if (!userId) {
        return false;
      }
      return !pairByPlayerId.has(userId);
    });

    const formWrapper = document.createElement('div');
    formWrapper.className = 'collection-card__form doubles-pair-form-wrapper';

    if (availablePlayers.length >= 2) {
      const form = document.createElement('form');
      form.className = 'doubles-pair-form';
      form.dataset.categoryId = categoryId;

      const playerOneField = document.createElement('label');
      playerOneField.className = 'inline-field';
      playerOneField.textContent = 'Jugador 1';
      const playerOneSelect = document.createElement('select');
      playerOneSelect.name = 'playerA';
      playerOneSelect.innerHTML = '<option value="">Selecciona jugador</option>';
      availablePlayers.forEach((entry) => {
        const option = document.createElement('option');
        option.value = normalizeId(entry?.user);
        option.textContent = entry?.user?.fullName || entry?.user?.email || 'Jugador';
        playerOneSelect.appendChild(option);
      });
      playerOneField.appendChild(playerOneSelect);

      const playerTwoField = document.createElement('label');
      playerTwoField.className = 'inline-field';
      playerTwoField.textContent = 'Jugador 2';
      const playerTwoSelect = document.createElement('select');
      playerTwoSelect.name = 'playerB';
      playerTwoSelect.innerHTML = '<option value="">Selecciona jugador</option>';
      availablePlayers.forEach((entry) => {
        const option = document.createElement('option');
        option.value = normalizeId(entry?.user);
        option.textContent = entry?.user?.fullName || entry?.user?.email || 'Jugador';
        playerTwoSelect.appendChild(option);
      });
      playerTwoField.appendChild(playerTwoSelect);

      const actions = document.createElement('div');
      actions.className = 'doubles-pair-form__actions';
      const submitButton = document.createElement('button');
      submitButton.type = 'submit';
      submitButton.className = 'secondary';
      submitButton.textContent = 'Crear pareja';
      actions.appendChild(submitButton);

      form.appendChild(playerOneField);
      form.appendChild(playerTwoField);
      form.appendChild(actions);

      formWrapper.appendChild(form);
    } else {
      const info = document.createElement('p');
      info.className = 'meta';
      info.textContent = 'No hay suficientes jugadores sin pareja para crear una nueva.';
      formWrapper.appendChild(info);
    }

    card.appendChild(formWrapper);
  }

  return card;
}

function renderTournamentDoubles(list = null, { loading = false, error = '' } = {}) {
  if (!tournamentDoublesContainer || !tournamentDoublesEmpty) {
    return;
  }

  tournamentDoublesContainer.innerHTML = '';

  const tournamentId = state.selectedDoublesTournamentId;
  const normalizedId = normalizeId(tournamentId);

  if (!normalizedId) {
    tournamentDoublesEmpty.hidden = false;
    tournamentDoublesEmpty.textContent = 'Selecciona un torneo para ver las inscripciones de dobles.';
    return;
  }

  if (loading) {
    tournamentDoublesEmpty.hidden = false;
    tournamentDoublesEmpty.textContent = 'Cargando inscripciones de dobles...';
    return;
  }

  if (error) {
    tournamentDoublesEmpty.hidden = false;
    tournamentDoublesEmpty.textContent = error;
    return;
  }

  if (!state.tournamentDoubles.has(normalizedId) && list === null) {
    tournamentDoublesEmpty.hidden = false;
    tournamentDoublesEmpty.textContent = 'Selecciona un torneo para ver las inscripciones de dobles.';
    return;
  }

  const groups = Array.isArray(list)
    ? list
    : state.tournamentDoubles.get(normalizedId) || [];

  if (!groups.length) {
    tournamentDoublesEmpty.hidden = false;
    tournamentDoublesEmpty.textContent = 'No hay inscripciones de dobles registradas.';
    return;
  }

  groups.forEach((group) => {
    const card = createTournamentDoublesCategoryCard(group);
    if (card) {
      tournamentDoublesContainer.appendChild(card);
    }
  });

  if (!tournamentDoublesContainer.childElementCount) {
    tournamentDoublesEmpty.hidden = false;
    tournamentDoublesEmpty.textContent = 'No hay inscripciones de dobles registradas.';
    return;
  }

  tournamentDoublesEmpty.hidden = true;
  tournamentDoublesEmpty.textContent = '';
}

async function refreshTournamentDoubles({ force = false } = {}) {
  const tournamentId = state.selectedDoublesTournamentId;
  const normalizedId = normalizeId(tournamentId);

  if (!normalizedId) {
    renderTournamentDoubles([], { loading: false });
    return;
  }

  if (!force && state.tournamentDoubles.has(normalizedId)) {
    renderTournamentDoubles();
    return;
  }

  pendingTournamentDoublesId = normalizedId;
  renderTournamentDoubles([], { loading: true });

  try {
    const response = await request(`/tournaments/${normalizedId}/doubles`, {
      requireAuth: Boolean(state.token),
    });
    const groups = Array.isArray(response) ? response : [];
    state.tournamentDoubles.set(normalizedId, groups);
    if (pendingTournamentDoublesId === normalizedId) {
      renderTournamentDoubles(groups);
    }
  } catch (error) {
    if (pendingTournamentDoublesId === normalizedId) {
      renderTournamentDoubles([], {
        error: error.message || 'No fue posible cargar las parejas de dobles.',
      });
    }
  } finally {
    if (pendingTournamentDoublesId === normalizedId) {
      pendingTournamentDoublesId = '';
    }
  }
}

function fillTournamentSelect(select, tournaments, selectedId, placeholder = 'Selecciona un torneo') {
  if (!select) return;

  select.innerHTML = '';
  const placeholderOption = document.createElement('option');
  placeholderOption.value = '';
  placeholderOption.textContent = tournaments.length ? placeholder : 'Sin torneos disponibles';
  select.appendChild(placeholderOption);

  tournaments.forEach((tournament) => {
    const tournamentId = normalizeId(tournament);
    if (!tournamentId) {
      return;
    }
    const option = document.createElement('option');
    option.value = tournamentId;
    option.textContent = tournament.name || 'Torneo';
    if (tournamentId === selectedId) {
      option.selected = true;
    }
    select.appendChild(option);
  });

  select.disabled = !tournaments.length;
  select.value = selectedId && !select.disabled ? selectedId : '';
}

function updateTournamentSelectors() {
  const tournaments = Array.isArray(state.tournaments) ? state.tournaments : [];
  const ids = tournaments.map((tournament) => normalizeId(tournament)).filter(Boolean);

  const resolveSelection = (value) => {
    if (!ids.length) {
      return '';
    }
    if (value && ids.includes(value)) {
      return value;
    }
    return ids[0];
  };

  state.selectedTournamentId = resolveSelection(state.selectedTournamentId);
  state.selectedTournamentCategoriesId = resolveSelection(state.selectedTournamentCategoriesId);
  state.selectedEnrollmentTournamentId = resolveSelection(state.selectedEnrollmentTournamentId);
  state.selectedMatchTournamentId = resolveSelection(state.selectedMatchTournamentId);
  state.selectedDoublesTournamentId = resolveSelection(state.selectedDoublesTournamentId);
  state.selectedBracketTournamentId = resolveSelection(state.selectedBracketTournamentId);

  fillTournamentSelect(
    tournamentCategoryTournamentSelect,
    tournaments,
    state.selectedTournamentCategoriesId,
    'Selecciona un torneo'
  );
  fillTournamentSelect(
    tournamentEnrollmentTournamentSelect,
    tournaments,
    state.selectedEnrollmentTournamentId,
    'Selecciona un torneo'
  );
  fillTournamentSelect(
    tournamentMatchTournamentSelect,
    tournaments,
    state.selectedMatchTournamentId,
    'Selecciona un torneo'
  );
  fillTournamentSelect(
    tournamentDoublesTournamentSelect,
    tournaments,
    state.selectedDoublesTournamentId,
    'Selecciona un torneo'
  );
  fillTournamentSelect(
    tournamentBracketTournamentSelect,
    tournaments,
    state.selectedBracketTournamentId,
    'Selecciona un torneo'
  );

  renderTournaments(tournaments);
  renderTournamentDetail();
  renderTournamentCategories();
  updateEnrollmentCategoryOptions();
  updateMatchCategoryOptions();
  updateBracketCategoryOptions();
  renderTournamentDoubles();
  updateTournamentActionAvailability();
}

function updateEnrollmentCategoryOptions() {
  if (!tournamentEnrollmentCategorySelect) return;

  const tournamentId = state.selectedEnrollmentTournamentId;
  const categories = getTournamentCategories(tournamentId);

  tournamentEnrollmentCategorySelect.innerHTML = '';
  const allOption = document.createElement('option');
  allOption.value = TOURNAMENT_ENROLLMENT_ALL_OPTION;
  allOption.textContent = 'Todos los jugadores';
  tournamentEnrollmentCategorySelect.appendChild(allOption);

  if (!tournamentId) {
    tournamentEnrollmentCategorySelect.disabled = true;
    state.selectedEnrollmentCategoryId = TOURNAMENT_ENROLLMENT_ALL_OPTION;
    renderTournamentEnrollments([], { loading: false });
    return;
  }

  categories
    .slice()
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
    .forEach((category) => {
      const categoryId = normalizeId(category);
      if (!categoryId) {
        return;
      }
      const option = document.createElement('option');
      option.value = categoryId;
      option.textContent = category.menuTitle || category.name || 'Categoría';
      tournamentEnrollmentCategorySelect.appendChild(option);
    });

  tournamentEnrollmentCategorySelect.disabled = false;

  const availableIds = [TOURNAMENT_ENROLLMENT_ALL_OPTION].concat(
    categories.map((category) => normalizeId(category)).filter(Boolean)
  );

  if (!availableIds.includes(state.selectedEnrollmentCategoryId)) {
    state.selectedEnrollmentCategoryId = TOURNAMENT_ENROLLMENT_ALL_OPTION;
    clearTournamentEnrollmentFilters();
  }

  tournamentEnrollmentCategorySelect.value = state.selectedEnrollmentCategoryId;
  refreshTournamentEnrollments();
}

function updateMatchCategoryOptions() {
  if (!tournamentMatchCategorySelect) return;

  const tournamentId = state.selectedMatchTournamentId;
  const categories = getTournamentCategories(tournamentId);

  tournamentMatchCategorySelect.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = categories.length ? 'Selecciona una categoría' : 'Sin categorías disponibles';
  tournamentMatchCategorySelect.appendChild(placeholder);

  if (!tournamentId || !categories.length) {
    tournamentMatchCategorySelect.disabled = true;
    state.selectedMatchCategoryId = '';
    renderTournamentMatches([], { loading: false });
    return;
  }

  categories
    .slice()
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
    .forEach((category) => {
      const categoryId = normalizeId(category);
      if (!categoryId) {
        return;
      }
      const option = document.createElement('option');
      option.value = categoryId;
      option.textContent = category.menuTitle || category.name || 'Categoría';
      tournamentMatchCategorySelect.appendChild(option);
    });

  tournamentMatchCategorySelect.disabled = false;

  const availableIds = categories.map((category) => normalizeId(category)).filter(Boolean);
  if (!availableIds.includes(state.selectedMatchCategoryId)) {
    state.selectedMatchCategoryId = availableIds[0] || '';
  }

  tournamentMatchCategorySelect.value = state.selectedMatchCategoryId || '';

  if (state.selectedMatchCategoryId) {
    refreshTournamentMatches();
  } else {
    renderTournamentMatches([], { loading: false });
  }
}

function updateBracketCategoryOptions() {
  if (!tournamentBracketCategorySelect) {
    return;
  }

  const tournamentId = state.selectedBracketTournamentId;
  const categories = getTournamentCategories(tournamentId);

  tournamentBracketCategorySelect.innerHTML = '';
  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = categories.length
    ? 'Selecciona una categoría'
    : 'Sin categorías disponibles';
  tournamentBracketCategorySelect.appendChild(placeholder);

  if (!tournamentId || !categories.length) {
    tournamentBracketCategorySelect.disabled = true;
    state.selectedBracketCategoryId = '';
    renderTournamentBracketSeeds();
    renderTournamentBracket([], { loading: false });
    updateTournamentActionAvailability();
    return;
  }

  categories
    .slice()
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
    .forEach((category) => {
      const categoryId = normalizeId(category);
      if (!categoryId) {
        return;
      }
      const option = document.createElement('option');
      option.value = categoryId;
      option.textContent = category.menuTitle || category.name || 'Categoría';
      tournamentBracketCategorySelect.appendChild(option);
    });

  tournamentBracketCategorySelect.disabled = false;

  const availableIds = categories.map((category) => normalizeId(category)).filter(Boolean);
  if (!availableIds.includes(state.selectedBracketCategoryId)) {
    state.selectedBracketCategoryId = '';
  }

  if (!state.selectedBracketCategoryId && availableIds.length) {
    state.selectedBracketCategoryId = availableIds[0];
  }

  tournamentBracketCategorySelect.value = state.selectedBracketCategoryId || '';

  if (state.selectedBracketCategoryId) {
    loadTournamentBracketContext({
      tournamentId,
      categoryId: state.selectedBracketCategoryId,
      forceMatches: false,
    });
  } else {
    renderTournamentBracketSeeds({
      tournamentId,
      categoryId: '',
      enrollments: [],
      category: null,
      pairs: [],
    });
    renderTournamentBracket([], { loading: false });
  }

  updateTournamentActionAvailability();
}

function ensureTournamentEnrollmentFilters() {
  if (!state.tournamentEnrollmentFilters) {
    state.tournamentEnrollmentFilters = { search: '', gender: '' };
  }
  return state.tournamentEnrollmentFilters;
}

function clearTournamentEnrollmentFilters() {
  const filters = ensureTournamentEnrollmentFilters();
  filters.search = '';
  filters.gender = '';
  if (tournamentEnrollmentSearch) {
    tournamentEnrollmentSearch.value = '';
  }
  if (tournamentEnrollmentGender) {
    tournamentEnrollmentGender.value = '';
  }
}

function setTournamentEnrollmentFilterAvailability(enabled) {
  const filters = ensureTournamentEnrollmentFilters();
  if (tournamentEnrollmentSearch) {
    tournamentEnrollmentSearch.disabled = !enabled;
    tournamentEnrollmentSearch.value = enabled ? filters.search || '' : '';
    if (!enabled) {
      filters.search = '';
    }
  }
  if (tournamentEnrollmentGender) {
    tournamentEnrollmentGender.disabled = !enabled;
    tournamentEnrollmentGender.value = enabled ? filters.gender || '' : '';
    if (!enabled) {
      filters.gender = '';
    }
  }
}

function updateTournamentEnrollmentCount(total) {
  if (tournamentEnrollmentCount) {
    tournamentEnrollmentCount.textContent = String(Number.isFinite(total) ? total : 0);
  }
}

function getTournamentEnrollmentCacheKey(tournamentId, categoryId) {
  if (!tournamentId || !categoryId) {
    return '';
  }
  return `${tournamentId}:${categoryId}`;
}

function getTournamentDoublesPairCacheKey(tournamentId, categoryId) {
  if (!tournamentId || !categoryId) {
    return '';
  }
  return `${tournamentId}:${categoryId}`;
}

function getTournamentBracketCacheKey(tournamentId, categoryId) {
  if (!tournamentId || !categoryId) {
    return '';
  }
  return `${tournamentId}:${categoryId}`;
}

function collectEnrollmentShirtSizes(enrollment) {
  const sizes = new Set();
  const pushSize = (value) => {
    const normalized = typeof value === 'string' ? value.trim() : '';
    if (normalized) {
      sizes.add(normalized);
    }
  };

  pushSize(enrollment?.shirtSize);

  if (Array.isArray(enrollment?.shirtSizes)) {
    enrollment.shirtSizes.forEach(pushSize);
  }

  const categories = Array.isArray(enrollment?.tournamentCategories)
    ? enrollment.tournamentCategories
    : [];
  categories.forEach((category) => pushSize(category?.shirtSize));

  pushSize(enrollment?.user?.shirtSize);

  return Array.from(sizes.values());
}

function renderTournamentEnrollments(enrollments = [], { loading = false } = {}) {
  if (!tournamentEnrollmentList || !tournamentEnrollmentEmpty) return;

  tournamentEnrollmentList.innerHTML = '';
  const tournamentId = state.selectedEnrollmentTournamentId;
  const categoryId = state.selectedEnrollmentCategoryId;
  const hasSelection = Boolean(tournamentId && categoryId);
  const isAllPlayersView = categoryId === TOURNAMENT_ENROLLMENT_ALL_OPTION;

  setTournamentEnrollmentFilterAvailability(hasSelection);

  if (!hasSelection) {
    updateTournamentEnrollmentCount(0);
    tournamentEnrollmentEmpty.hidden = false;
    tournamentEnrollmentEmpty.textContent =
      'Selecciona un torneo para consultar los jugadores inscritos.';
    return;
  }

  if (loading) {
    updateTournamentEnrollmentCount(0);
    tournamentEnrollmentEmpty.hidden = false;
    tournamentEnrollmentEmpty.textContent = isAllPlayersView
      ? 'Cargando jugadores...'
      : 'Cargando inscripciones...';
    return;
  }

  if (!Array.isArray(enrollments) || !enrollments.length) {
    updateTournamentEnrollmentCount(0);
    tournamentEnrollmentEmpty.hidden = false;
    tournamentEnrollmentEmpty.textContent = isAllPlayersView
      ? 'Aún no hay jugadores inscritos en este torneo.'
      : 'No hay inscripciones registradas todavía.';
    return;
  }

  const filters = ensureTournamentEnrollmentFilters();
  const normalizedSearch = (filters.search || '').trim().toLowerCase();
  const genderFilter = (filters.gender || '').toLowerCase();

  const filteredEnrollments = enrollments.filter((enrollment) => {
    const user = enrollment?.user || {};
    const categories = Array.isArray(enrollment?.tournamentCategories)
      ? enrollment.tournamentCategories
      : [];

    if (normalizedSearch) {
      const tokens = [user.fullName, user.email, user.phone];

      const shirtSizes = collectEnrollmentShirtSizes(enrollment);
      if (shirtSizes.length) {
        tokens.push(shirtSizes.join(' '));
      }

      categories.forEach((category) => {
        const label = category?.category?.menuTitle || category?.category?.name;
        if (label) {
          tokens.push(label);
        }
        const statusLabel = formatTournamentEnrollmentStatusLabel(category?.status || '');
        if (statusLabel) {
          tokens.push(statusLabel);
        }
      });

      const searchSource = tokens
        .filter(Boolean)
        .join(' ')
        .toLowerCase();
      if (!searchSource.includes(normalizedSearch)) {
        return false;
      }
    }

    if (genderFilter) {
      const userGender = (user.gender || '').toLowerCase();
      if (userGender !== genderFilter) {
        return false;
      }
    }

    return true;
  });

  updateTournamentEnrollmentCount(filteredEnrollments.length);

  if (!filteredEnrollments.length) {
    tournamentEnrollmentEmpty.hidden = false;
    tournamentEnrollmentEmpty.textContent = isAllPlayersView
      ? 'No hay jugadores que coincidan con los filtros aplicados.'
      : 'No hay inscripciones que coincidan con los filtros aplicados.';
    return;
  }

  tournamentEnrollmentEmpty.hidden = true;

  filteredEnrollments.forEach((enrollment) => {
    const user = enrollment?.user || {};
    const categories = Array.isArray(enrollment?.tournamentCategories)
      ? enrollment.tournamentCategories
      : [];

    const item = document.createElement('li');
    item.className = 'tournament-player-entry';

    const playerCell = buildPlayerCell(user, { includeSchedule: true, size: 'sm' });
    playerCell.classList.add('tournament-player-entry__player');
    item.appendChild(playerCell);

    if (categories.length) {
      const categoryRow = document.createElement('div');
      categoryRow.className = 'tournament-player-entry__categories';

      categories.forEach((category) => {
        const statusValue = category?.status || 'pendiente';
        const label = category?.category?.menuTitle || category?.category?.name || 'Categoría';
        const tag = document.createElement('span');
        tag.className = `tag status-${statusValue}`;
        tag.textContent = label;
        const statusLabel = formatTournamentEnrollmentStatusLabel(statusValue);
        if (statusLabel && statusLabel !== label) {
          tag.title = statusLabel;
        }
        categoryRow.appendChild(tag);
      });

      item.appendChild(categoryRow);
    }

    const meta = document.createElement('div');
    meta.className = 'meta tournament-player-entry__meta';

    const shirtSizes = collectEnrollmentShirtSizes(enrollment);
    if (shirtSizes.length) {
      const shirtSpan = document.createElement('span');
      shirtSpan.textContent =
        shirtSizes.length === 1
          ? `Camiseta: ${shirtSizes[0]}`
          : `Camisetas: ${shirtSizes.join(', ')}`;
      meta.appendChild(shirtSpan);
    }

    if (user.email) {
      const emailSpan = document.createElement('span');
      emailSpan.textContent = user.email;
      meta.appendChild(emailSpan);
    }

    if (user.phone) {
      const phoneSpan = document.createElement('span');
      phoneSpan.textContent = user.phone;
      meta.appendChild(phoneSpan);
    }

    if (meta.childElementCount) {
      item.appendChild(meta);
    }

    tournamentEnrollmentList.appendChild(item);
  });
}

async function fetchTournamentEnrollments(tournamentId, categoryId, { forceReload = false } = {}) {
  if (!tournamentId || !categoryId) {
    return [];
  }

  const cacheKey = getTournamentEnrollmentCacheKey(tournamentId, categoryId);
  if (!forceReload && state.tournamentEnrollments.has(cacheKey)) {
    return state.tournamentEnrollments.get(cacheKey) || [];
  }

  const endpoint =
    categoryId === TOURNAMENT_ENROLLMENT_ALL_OPTION
      ? `/tournaments/${tournamentId}/enrollments`
      : `/tournaments/${tournamentId}/categories/${categoryId}/enrollments`;

  const response = await request(endpoint);
  const list = Array.isArray(response) ? response : [];
  state.tournamentEnrollments.set(cacheKey, list);
  return list;
}

function normalizeDoublesPair(pair) {
  if (!pair || typeof pair !== 'object') {
    return null;
  }

  const normalized = { ...pair };
  const id = normalizeId(pair);
  if (id) {
    normalized.id = id;
    if (!normalized._id) {
      normalized._id = id;
    }
  }

  const members = Array.isArray(pair.players)
    ? pair.players
        .map((member) => {
          if (!member) {
            return null;
          }
          if (typeof member === 'object') {
            const memberId = normalizeId(member);
            return {
              ...member,
              id: memberId || member.id || member._id || '',
              _id: memberId || member._id || member.id || '',
            };
          }
          if (typeof member === 'string') {
            const trimmed = member.trim();
            if (!trimmed) {
              return null;
            }
            return { id: trimmed, _id: trimmed, fullName: trimmed };
          }
          return null;
        })
        .filter(Boolean)
    : [];

  normalized.players = members;

  if (!normalized.fullName || !normalized.fullName.trim()) {
    const names = members
      .map((member) => {
        if (!member || typeof member !== 'object') {
          return '';
        }
        if (typeof member.fullName === 'string' && member.fullName.trim()) {
          return member.fullName.trim();
        }
        if (typeof member.email === 'string' && member.email.trim()) {
          return member.email.trim();
        }
        return '';
      })
      .filter((name) => Boolean(name && name.trim()));

    if (names.length) {
      normalized.fullName = names.join(' / ');
    }
  }

  return normalized;
}

function cloneNormalizedDoublesPair(pair) {
  if (!pair || typeof pair !== 'object') {
    return null;
  }

  const players = Array.isArray(pair.players)
    ? pair.players.map((member) => (member && typeof member === 'object' ? { ...member } : member))
    : [];

  return { ...pair, players };
}

function buildDoublesPairMap(pairs = []) {
  const map = new Map();
  (Array.isArray(pairs) ? pairs : []).forEach((pair) => {
    const normalized = normalizeDoublesPair(pair);
    if (normalized && normalized.id) {
      map.set(normalized.id, normalized);
    }
  });
  return map;
}

function matchesRequireDoublesPairs(matches = []) {
  return matches.some((match) => {
    if (!match || match.playerType !== 'TournamentDoublesPair') {
      return false;
    }

    const players = Array.isArray(match.players) ? match.players : [];
    if (!players.length) {
      return false;
    }

    return players.some((player) => {
      if (!player) {
        return false;
      }
      if (typeof player === 'object') {
        return !Array.isArray(player.players) || !player.players.length;
      }
      return true;
    });
  });
}

async function hydrateTournamentMatchesWithPairs(matches, options = {}) {
  const list = Array.isArray(matches) ? matches : [];
  if (!list.length) {
    return list;
  }

  const includesDoubles = list.some((match) => match && match.playerType === 'TournamentDoublesPair');
  if (!includesDoubles) {
    return list;
  }

  const needsExternalPairs = matchesRequireDoublesPairs(list);

  let pairMap = new Map();
  const tournamentId = normalizeId(options.tournamentId);
  const categoryId = normalizeId(options.categoryId);

  if (needsExternalPairs && tournamentId && categoryId) {
    try {
      const pairs = await fetchTournamentDoublesPairs(tournamentId, categoryId, { forceReload: false });
      pairMap = buildDoublesPairMap(pairs);
    } catch (error) {
      pairMap = new Map();
    }
  }

  return list.map((match) => {
    if (!match || match.playerType !== 'TournamentDoublesPair') {
      return match;
    }

    const players = Array.isArray(match.players) ? match.players : [];
    const resolvedPlayers = players.map((player) => {
      if (player && typeof player === 'object') {
        if (Array.isArray(player.players) && player.players.length) {
          return cloneNormalizedDoublesPair(normalizeDoublesPair(player)) || player;
        }
        const playerId = normalizeId(player);
        if (playerId && pairMap.has(playerId)) {
          return cloneNormalizedDoublesPair(pairMap.get(playerId)) || player;
        }
        return normalizeDoublesPair(player) || player;
      }

      const playerId = normalizeId(player);
      if (playerId && pairMap.has(playerId)) {
        return cloneNormalizedDoublesPair(pairMap.get(playerId)) || player;
      }
      if (playerId) {
        return { id: playerId, _id: playerId, players: [] };
      }
      return player;
    });

    const normalizedPlayers = resolvedPlayers.map((entry) => normalizeDoublesPair(entry) || entry);

    return {
      ...match,
      playerType: 'TournamentDoublesPair',
      players: normalizedPlayers,
    };
  });
}

async function fetchTournamentDoublesPairs(tournamentId, categoryId, { forceReload = false } = {}) {
  if (!tournamentId || !categoryId) {
    return [];
  }

  const cacheKey = getTournamentDoublesPairCacheKey(tournamentId, categoryId);
  if (!forceReload && state.tournamentDoublesPairs.has(cacheKey)) {
    const cached = state.tournamentDoublesPairs.get(cacheKey) || [];
    return cached.map((pair) => cloneNormalizedDoublesPair(pair) || pair).filter(Boolean);
  }

  const response = await request(
    `/tournaments/${tournamentId}/categories/${categoryId}/doubles-pairs`,
    { requireAuth: Boolean(state.token) }
  );
  const list = Array.isArray(response) ? response : [];
  const normalizedList = list
    .map((pair) => normalizeDoublesPair(pair))
    .filter((pair) => Boolean(pair && pair.id));
  state.tournamentDoublesPairs.set(cacheKey, normalizedList);
  return normalizedList.map((pair) => cloneNormalizedDoublesPair(pair) || pair).filter(Boolean);
}

async function ensurePlayersLoaded() {
  if (Array.isArray(state.players) && state.players.length) {
    return state.players;
  }

  try {
    const players = await request('/players');
    state.players = Array.isArray(players) ? players : [];
    return state.players;
  } catch (error) {
    showGlobalMessage('No fue posible cargar la lista de jugadores.', 'error');
    throw error;
  }
}

async function refreshTournamentEnrollments({ forceReload = false } = {}) {
  const tournamentId = state.selectedEnrollmentTournamentId;
  const categoryId = state.selectedEnrollmentCategoryId;

  if (!tournamentId || !categoryId) {
    renderTournamentEnrollments([], { loading: false });
    return;
  }

  const cacheKey = getTournamentEnrollmentCacheKey(tournamentId, categoryId);
  if (!forceReload && state.tournamentEnrollments.has(cacheKey)) {
    renderTournamentEnrollments(state.tournamentEnrollments.get(cacheKey) || []);
    return;
  }

  pendingTournamentEnrollmentKey = cacheKey;
  renderTournamentEnrollments([], { loading: true });

  try {
    const list = await fetchTournamentEnrollments(tournamentId, categoryId, { forceReload });
    if (pendingTournamentEnrollmentKey === cacheKey) {
      renderTournamentEnrollments(list);
    }
  } catch (error) {
    if (pendingTournamentEnrollmentKey === cacheKey) {
      tournamentEnrollmentList.innerHTML = '';
      tournamentEnrollmentEmpty.hidden = false;
      tournamentEnrollmentEmpty.textContent =
        error.message || 'No fue posible cargar las inscripciones.';
      updateTournamentEnrollmentCount(0);
    }
  } finally {
    if (pendingTournamentEnrollmentKey === cacheKey) {
      pendingTournamentEnrollmentKey = '';
    }
  }
}

function renderTournamentMatches(matches = [], { loading = false } = {}) {
  if (!tournamentMatchesList || !tournamentMatchesEmpty) return;

  tournamentMatchesList.innerHTML = '';
  const tournamentId = state.selectedMatchTournamentId;
  const categoryId = state.selectedMatchCategoryId;

  updateTournamentOrderOfPlayControls();

  if (!tournamentId || !categoryId) {
    tournamentMatchesEmpty.hidden = false;
    tournamentMatchesEmpty.textContent = 'Selecciona una categoría para revisar sus partidos.';
    return;
  }

  if (loading) {
    tournamentMatchesEmpty.hidden = false;
    tournamentMatchesEmpty.textContent = 'Cargando partidos...';
    return;
  }

  if (!Array.isArray(matches) || !matches.length) {
    tournamentMatchesEmpty.hidden = false;
    tournamentMatchesEmpty.textContent = 'No hay partidos registrados para esta categoría.';
    return;
  }

  tournamentMatchesEmpty.hidden = true;

  matches.forEach((match) => {
    const item = document.createElement('li');
    item.classList.add('tournament-match-item');
    const title = document.createElement('strong');
    const players = Array.isArray(match?.players)
      ? match.players.map((player) => player?.fullName).filter(Boolean)
      : [];
    title.textContent = players.length ? players.join(' vs ') : 'Partido pendiente';
    item.appendChild(title);

    const meta = document.createElement('div');
    meta.className = 'tournament-match-meta';

    if (match.round) {
      const roundSpan = document.createElement('span');
      roundSpan.textContent = `Ronda: ${match.round}`;
      meta.appendChild(roundSpan);
    }

    if (Number.isFinite(Number(match.matchNumber))) {
      const numberSpan = document.createElement('span');
      numberSpan.textContent = `Partido ${match.matchNumber}`;
      meta.appendChild(numberSpan);
    }

    if (match.scheduledAt) {
      const dateSpan = document.createElement('span');
      dateSpan.textContent = formatDate(match.scheduledAt);
      meta.appendChild(dateSpan);
    }

    if (match.court) {
      const courtSpan = document.createElement('span');
      courtSpan.textContent = `Pista: ${match.court}`;
      meta.appendChild(courtSpan);
    }

    const statusValue = match.status || 'pendiente';
    const statusTag = document.createElement('span');
    statusTag.className = `tag status-${statusValue}`;
    statusTag.textContent = formatTournamentMatchStatusLabel(statusValue);
    meta.appendChild(statusTag);

    item.appendChild(meta);

    const result = match?.result || null;
    const rawScore = typeof result?.score === 'string' ? result.score.trim() : '';
    const rawNotes = typeof result?.notes === 'string' ? result.notes.trim() : '';
    const winnerId = normalizeId(result?.winner);
    const hasResultInfo = Boolean(rawScore || rawNotes || winnerId);

    if (hasResultInfo) {
      const resultContainer = document.createElement('div');
      resultContainer.className = 'tournament-match-result';

      const header = document.createElement('div');
      header.className = 'tournament-match-result__header';

      const statusValue = match.resultStatus || 'sin_resultado';
      const statusTag = document.createElement('span');
      statusTag.className = `tag tournament-match-result__status tournament-match-result__status--${statusValue}`;
      statusTag.textContent = formatTournamentResultStatusLabel(statusValue);
      header.appendChild(statusTag);

      if (rawScore) {
        const scoreSpan = document.createElement('span');
        scoreSpan.className = 'tournament-match-result__score';
        scoreSpan.textContent = `Marcador: ${rawScore}`;
        header.appendChild(scoreSpan);
      }

      resultContainer.appendChild(header);

      if (winnerId) {
        let winnerName = '';
        if (Array.isArray(match?.players)) {
          const winnerPlayer = match.players.find((player) => normalizeId(player) === winnerId);
          winnerName = winnerPlayer ? getPlayerDisplayName(winnerPlayer) : '';
        }
        const winnerParagraph = document.createElement('p');
        winnerParagraph.className = 'tournament-match-result__meta';
        winnerParagraph.textContent = winnerName ? `Ganador: ${winnerName}` : 'Ganador asignado en el cuadro';
        resultContainer.appendChild(winnerParagraph);
      }

      if (rawNotes) {
        const notesParagraph = document.createElement('p');
        notesParagraph.className = 'tournament-match-result__notes';
        notesParagraph.textContent = rawNotes;
        resultContainer.appendChild(notesParagraph);
      }

      item.appendChild(resultContainer);
    }

    if (isAdmin()) {
      const matchId = normalizeId(match);
      if (matchId) {
        const actions = document.createElement('div');
        actions.className = 'tournament-match-item__actions';

        const scheduleButton = document.createElement('button');
        scheduleButton.type = 'button';
        const hasSchedule = Boolean(match?.scheduledAt);
        scheduleButton.className = hasSchedule ? 'secondary' : 'primary';
        scheduleButton.dataset.action = 'schedule-tournament-match';
        scheduleButton.dataset.matchId = matchId;
        const tournamentIdAttr =
          normalizeId(match?.tournament) || state.selectedMatchTournamentId || '';
        const categoryIdAttr =
          normalizeId(match?.category) || state.selectedMatchCategoryId || '';
        scheduleButton.dataset.tournamentId = tournamentIdAttr;
        scheduleButton.dataset.categoryId = categoryIdAttr;
        scheduleButton.textContent = hasSchedule ? 'Editar horario' : 'Programar partido';
        actions.appendChild(scheduleButton);

        const hasResult = hasResultInfo;
        const resultButton = document.createElement('button');
        resultButton.type = 'button';
        resultButton.className = hasResult ? 'ghost' : 'secondary';
        resultButton.dataset.action = 'record-tournament-result';
        resultButton.dataset.matchId = matchId;
        resultButton.dataset.tournamentId = tournamentIdAttr;
        resultButton.dataset.categoryId = categoryIdAttr;
        resultButton.textContent = hasResult ? 'Editar resultado' : 'Registrar resultado';
        actions.appendChild(resultButton);

        item.appendChild(actions);
      }
    }
    tournamentMatchesList.appendChild(item);
  });
}

async function refreshTournamentMatches({ forceReload = false } = {}) {
  const tournamentId = state.selectedMatchTournamentId;
  const categoryId = state.selectedMatchCategoryId;

  if (!tournamentId || !categoryId) {
    renderTournamentMatches([], { loading: false });
    return;
  }

  const cacheKey = `${tournamentId}:${categoryId}`;
  if (!forceReload && state.tournamentMatches.has(cacheKey)) {
    let cached = state.tournamentMatches.get(cacheKey) || [];
    cached = await hydrateTournamentMatchesWithPairs(cached, {
      tournamentId,
      categoryId,
    });
    state.tournamentMatches.set(cacheKey, cached);
    recomputeTournamentOrderOfPlayDays(tournamentId);
    renderTournamentMatches(cached);
    return;
  }

  pendingTournamentMatchesKey = cacheKey;
  renderTournamentMatches([], { loading: true });

  try {
    const response = await request(`/tournaments/${tournamentId}/categories/${categoryId}/matches`);
    let list = Array.isArray(response) ? response : [];
    list = await hydrateTournamentMatchesWithPairs(list, { tournamentId, categoryId });
    state.tournamentMatches.set(cacheKey, list);
    recomputeTournamentOrderOfPlayDays(tournamentId);
    if (pendingTournamentMatchesKey === cacheKey) {
      renderTournamentMatches(list);
    }
  } catch (error) {
    if (pendingTournamentMatchesKey === cacheKey) {
      tournamentMatchesList.innerHTML = '';
      tournamentMatchesEmpty.hidden = false;
      tournamentMatchesEmpty.textContent =
        error.message || 'No fue posible cargar los partidos del torneo.';
    }
  } finally {
    if (pendingTournamentMatchesKey === cacheKey) {
      pendingTournamentMatchesKey = '';
    }
  }
}

function createBracketPlayerAvatar(player, placeholderLabel = '') {
  const avatarGroup = document.createElement('div');
  avatarGroup.className = 'bracket-player__avatars';

  const members = Array.isArray(player?.players)
    ? player.players.filter(Boolean)
    : [];

  if (members.length) {
    avatarGroup.classList.add('bracket-player__avatars--pair');
    members.forEach((member) => {
      const avatar = createAvatarElement(member, { size: 'sm' });
      avatar.classList.add('bracket-player__avatar');
      avatarGroup.appendChild(avatar);
    });
    return avatarGroup;
  }

  const avatar = document.createElement('div');
  avatar.className = 'player-avatar player-avatar--sm bracket-player__avatar';

  const photo = typeof player?.photo === 'string' ? player.photo : '';

  if (photo) {
    const image = document.createElement('img');
    image.src = photo;
    image.alt = `Avatar de ${getPlayerDisplayName(player)}`;
    avatar.appendChild(image);
  } else {
    avatar.classList.add('player-avatar--placeholder');
    const textSource = placeholderLabel || getPlayerDisplayName(player);
    const initial = textSource ? textSource.trim().charAt(0).toUpperCase() : '—';
    avatar.textContent = initial || '—';
  }

  avatarGroup.appendChild(avatar);

  return avatarGroup;
}

function createBracketMatchCard(match, seedByPlayer = new Map(), options = {}) {
  const {
    roundIndex = 0,
    totalRounds = 1,
    slotIndex = 0,
    isPlaceholder = false,
    matchNumber = '',
    placeholderLabels = [],
    useConnectors = true,
  } = options;

  const matchId = match ? normalizeId(match) : '';
  const editable = Boolean(matchId) && isAdmin();

  const card = document.createElement('div');
  card.className = 'bracket-match';

  if (matchId) {
    card.dataset.matchId = matchId;
  }

  const displayMatchNumber = match?.matchNumber || matchNumber;
  if (displayMatchNumber) {
    card.dataset.matchNumber = `${displayMatchNumber}`;
  }

  const previousMatchIds = Array.isArray(match?.previousMatches)
    ? match.previousMatches
        .map((previous) => normalizeId(previous))
        .filter((value, index, list) => Boolean(value) && list.indexOf(value) === index)
    : [];
  if (previousMatchIds.length) {
    card.dataset.previousMatchIds = previousMatchIds.join(',');
  }

  const placeholderSources = [];
  if (Array.isArray(placeholderLabels)) {
    placeholderSources.push(...placeholderLabels);
  }
  if (typeof match?.placeholderA === 'string') {
    placeholderSources.push(match.placeholderA);
  }
  if (typeof match?.placeholderB === 'string') {
    placeholderSources.push(match.placeholderB);
  }

  const placeholderMatchNumbers = new Set();
  placeholderSources.forEach((text) => {
    if (typeof text !== 'string' || !/partido/i.test(text)) {
      return;
    }
    const numberRegex = /\d+/g;
    numberRegex.lastIndex = 0;
    let matchResult = null;
    while ((matchResult = numberRegex.exec(text))) {
      const [numberValue] = matchResult;
      if (numberValue) {
        placeholderMatchNumbers.add(numberValue);
      }
    }
  });
  if (placeholderMatchNumbers.size) {
    card.dataset.previousMatchNumbers = Array.from(placeholderMatchNumbers).join(',');
  }

  if (useConnectors && roundIndex > 0) {
    card.classList.add('bracket-match--has-prev');
  }
  if (useConnectors && roundIndex < totalRounds - 1) {
    card.classList.add('bracket-match--has-next');
    card.classList.add(slotIndex % 2 === 0 ? 'bracket-match--top' : 'bracket-match--bottom');
  }
  if (isPlaceholder) {
    card.classList.add('bracket-match--placeholder');
  }

  const header = document.createElement('div');
  header.className = 'bracket-match__header';

  const label = document.createElement('span');
  label.className = 'bracket-match__label';
  label.textContent = displayMatchNumber ? `Partido ${displayMatchNumber}` : 'Partido';
  header.appendChild(label);

  const statusValue = match?.status || 'pendiente';
  const pendingLabel = formatTournamentMatchStatusLabel('pendiente') || 'Pendiente';
  const statusLabel =
    !isPlaceholder && typeof statusValue === 'string'
      ? formatTournamentMatchStatusLabel(statusValue) || statusValue
      : pendingLabel;
  const statusSpan = document.createElement('span');
  statusSpan.className = 'bracket-match__status';
  statusSpan.textContent = statusLabel || pendingLabel;
  header.appendChild(statusSpan);

  card.appendChild(header);

  const playersContainer = document.createElement('div');
  playersContainer.className = 'bracket-match__players';

  const players = Array.isArray(match?.players) ? match.players : [];
  const winnerId = resolveWinnerId(match);

  const sets = getMatchSets(match);
  const scoreParticipants = getMatchScores(match);
  const participantById = new Map();
  scoreParticipants.forEach((participant) => {
    if (participant?.id) {
      participantById.set(participant.id, participant);
    }
  });

  const canRenderInlineScores =
    !isPlaceholder &&
    sets.length > 0 &&
    players.every((player) => {
      if (!player) {
        return false;
      }
      const playerId = normalizeId(player);
      return Boolean(playerId && participantById.has(playerId));
    });

  for (let index = 0; index < 2; index += 1) {
    const player = players[index];
    const wrapper = document.createElement('div');
    wrapper.className = 'bracket-player';

    const seedSpan = document.createElement('span');
    seedSpan.className = 'bracket-player__seed';

    const rawPlaceholderLabel =
      placeholderLabels[index] || (index === 0 ? match?.placeholderA : match?.placeholderB) || '';
    const displayPlaceholder = rawPlaceholderLabel && rawPlaceholderLabel.trim() ? rawPlaceholderLabel : 'Pendiente';

    if (player) {
      const playerId = normalizeId(player);
      const seedNumber = seedByPlayer.get(playerId);
      seedSpan.textContent = seedNumber ? `#${seedNumber}` : '';
    } else {
      seedSpan.textContent = '';
    }
    wrapper.appendChild(seedSpan);

    wrapper.appendChild(createBracketPlayerAvatar(player, player ? '' : displayPlaceholder));

    const nameSpan = document.createElement('span');
    nameSpan.className = 'bracket-player__name';
    if (player) {
      nameSpan.textContent = getPlayerDisplayName(player);
    } else {
      nameSpan.textContent = displayPlaceholder;
      wrapper.classList.add('bracket-player--placeholder');
      nameSpan.classList.add('bracket-player__name--placeholder');
    }
    wrapper.appendChild(nameSpan);

    const statusSpan = document.createElement('span');
    statusSpan.className = 'bracket-player__status';

    let playerId = '';
    if (player) {
      playerId = normalizeId(player);
      if (winnerId && playerId === winnerId) {
        wrapper.classList.add('bracket-player--winner');
        statusSpan.textContent = 'Ganador';
      } else if (winnerId) {
        wrapper.classList.add('bracket-player--eliminated');
        statusSpan.textContent = 'Eliminado';
      }
    }

    wrapper.appendChild(statusSpan);

    if (player && playerId && canRenderInlineScores) {
      const participant = participantById.get(playerId) || null;
      if (participant) {
        wrapper.classList.add('bracket-player--with-score');
        wrapper.style.setProperty('--player-sets-count', Math.max(sets.length, 1));

        const scoresContainer = document.createElement('div');
        scoresContainer.className = 'bracket-player__scores';

        sets.forEach((set, setIndex) => {
          const scoreSpan = document.createElement('span');
          scoreSpan.className = 'bracket-player__score';

          const scoreValue = Number(set.scores?.[participant.id]);
          const displayValue = Number.isFinite(scoreValue) && scoreValue >= 0 ? Math.floor(scoreValue) : '';
          scoreSpan.textContent = displayValue;

          if (set.tieBreak) {
            scoreSpan.classList.add('bracket-player__score--tiebreak');
            scoreSpan.setAttribute('aria-label', `Super tie-break set ${setIndex + 1}: ${displayValue}`);
          } else if (displayValue !== '') {
            scoreSpan.setAttribute('aria-label', `Set ${setIndex + 1}: ${displayValue}`);
          }

          if (winnerId && participant.id === winnerId) {
            scoreSpan.classList.add('bracket-player__score--winner');
          }

          scoresContainer.appendChild(scoreSpan);
        });

        wrapper.appendChild(scoresContainer);
      }
    }

    playersContainer.appendChild(wrapper);
  }

  card.appendChild(playersContainer);

  const scoreboard = !isPlaceholder && !canRenderInlineScores ? createResultScoreboard(match) : null;
  if (scoreboard) {
    card.appendChild(scoreboard);
  } else if (match?.result?.score) {
    const scoreMeta = document.createElement('div');
    scoreMeta.className = 'bracket-match__meta';
    scoreMeta.textContent = match.result.score;
    card.appendChild(scoreMeta);
  }

  const meta = document.createElement('div');
  meta.className = 'bracket-match__meta';
  if (match?.scheduledAt) {
    const dateSpan = document.createElement('span');
    dateSpan.textContent = formatDate(match.scheduledAt);
    meta.appendChild(dateSpan);
  }
  if (match?.court) {
    const courtSpan = document.createElement('span');
    courtSpan.textContent = `Pista: ${match.court}`;
    meta.appendChild(courtSpan);
  }
  if (match?.result?.notes) {
    const notesSpan = document.createElement('span');
    notesSpan.textContent = match.result.notes;
    meta.appendChild(notesSpan);
  }

  if (meta.childElementCount) {
    card.appendChild(meta);
  }

  if (editable) {
    const actions = document.createElement('div');
    actions.className = 'bracket-match__actions';

    const scheduleButton = document.createElement('button');
    scheduleButton.type = 'button';
    const hasSchedule = Boolean(match?.scheduledAt);
    scheduleButton.className = hasSchedule
      ? 'secondary bracket-match__action'
      : 'primary bracket-match__action';
    scheduleButton.dataset.action = 'schedule-tournament-match';
    scheduleButton.dataset.matchId = matchId;
    const bracketTournamentId =
      normalizeId(match?.tournament) || state.selectedBracketTournamentId || '';
    const bracketCategoryId =
      normalizeId(match?.category) || state.selectedBracketCategoryId || '';
    scheduleButton.dataset.tournamentId = bracketTournamentId;
    scheduleButton.dataset.categoryId = bracketCategoryId;
    scheduleButton.textContent = hasSchedule ? 'Editar horario' : 'Programar partido';

    actions.appendChild(scheduleButton);

    const resultWinnerId = normalizeId(match?.result?.winner);
    const resultScore = typeof match?.result?.score === 'string' ? match.result.score.trim() : '';
    const hasResult = Boolean(resultWinnerId || resultScore);
    const resultButton = document.createElement('button');
    resultButton.type = 'button';
    resultButton.className = hasResult ? 'ghost bracket-match__action' : 'secondary bracket-match__action';
    resultButton.dataset.action = 'record-tournament-result';
    resultButton.dataset.matchId = matchId;
    resultButton.dataset.tournamentId = bracketTournamentId;
    resultButton.dataset.categoryId = bracketCategoryId;
    resultButton.textContent = hasResult ? 'Editar resultado' : 'Registrar resultado';

    actions.appendChild(resultButton);
    card.appendChild(actions);
  }

  return card;
}

function determineInitialBracketRoundIndex(roundEntries = []) {
  if (!Array.isArray(roundEntries) || roundEntries.length === 0) {
    return 0;
  }

  for (let index = 0; index < roundEntries.length; index += 1) {
    const roundMatches = Array.isArray(roundEntries[index]?.matches)
      ? roundEntries[index].matches
      : [];

    const hasPendingMatch = roundMatches.some(
      (match) => !bracketMatchesHaveRecordedResults([match])
    );

    if (hasPendingMatch) {
      return index;
    }
  }

  return roundEntries.length - 1;
}

function createBracketRoundNavigation(roundSections = [], grid, { initialRoundIndex = 0 } = {}) {
  const sections = Array.isArray(roundSections)
    ? roundSections.filter((section) => section instanceof HTMLElement)
    : [];

  if (!(grid instanceof HTMLElement) || sections.length <= 1) {
    return null;
  }

  const nav = document.createElement('div');
  nav.className = 'bracket-round-nav';
  nav.setAttribute('aria-label', 'Navegación de rondas del cuadro');

  const prevButton = document.createElement('button');
  prevButton.type = 'button';
  prevButton.className = 'bracket-round-nav__control bracket-round-nav__control--prev';
  prevButton.setAttribute('aria-label', 'Ronda anterior');
  prevButton.title = 'Ronda anterior';
  prevButton.innerHTML = '<span aria-hidden="true">‹</span>';

  const nextButton = document.createElement('button');
  nextButton.type = 'button';
  nextButton.className = 'bracket-round-nav__control bracket-round-nav__control--next';
  nextButton.setAttribute('aria-label', 'Ronda siguiente');
  nextButton.title = 'Ronda siguiente';
  nextButton.innerHTML = '<span aria-hidden="true">›</span>';

  const buttonList = document.createElement('div');
  buttonList.className = 'bracket-round-nav__list';

  nav.appendChild(prevButton);
  nav.appendChild(buttonList);

  const activeLabel = document.createElement('div');
  activeLabel.className = 'bracket-round-nav__active-label';
  activeLabel.setAttribute('aria-live', 'polite');
  activeLabel.hidden = true;

  nav.appendChild(activeLabel);
  nav.appendChild(nextButton);

  const totalRounds = sections.length;
  const evaluateFocusMode = () => totalRounds > 1 && !(desktopMediaQuery?.matches);
  let useFocusMode = evaluateFocusMode();
  grid.classList.toggle('tournament-bracket-grid--focus-mode', useFocusMode);

  const clamp = (value, min, max) => Math.min(Math.max(value, min), max);

  const roundButtons = sections.map((section, index) => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'bracket-round-nav__button';
    const rawLabel = section.dataset.roundName ||
      section.querySelector('.bracket-round__title')?.textContent;
    const label = typeof rawLabel === 'string' && rawLabel.trim() ? rawLabel.trim() : `Ronda ${
      index + 1
    }`;
    button.textContent = label;
    button.setAttribute('aria-label', label);
    button.dataset.roundIndex = String(index);
    button.addEventListener('click', () => {
      setActiveRound(index);
    });
    buttonList.appendChild(button);
    return button;
  });

  let activeRoundIndex = clamp(initialRoundIndex, 0, totalRounds - 1);

  const getRoundLabel = (index) => {
    if (index < 0 || index >= roundButtons.length) {
      return '';
    }
    const label = roundButtons[index]?.textContent;
    return typeof label === 'string' ? label.trim() : '';
  };

  const updateActiveLabel = () => {
    const label = getRoundLabel(activeRoundIndex);
    if (label) {
      activeLabel.textContent = label;
      activeLabel.dataset.roundIndex = String(activeRoundIndex);
    } else {
      activeLabel.textContent = '';
      delete activeLabel.dataset.roundIndex;
    }

    const previousIndex = activeRoundIndex - 1;
    const nextIndex = activeRoundIndex + 1;
    const previousLabel = getRoundLabel(previousIndex);
    const nextLabel = getRoundLabel(nextIndex);

    if (previousLabel) {
      prevButton.setAttribute('aria-label', `Ver ${previousLabel}`);
      prevButton.title = previousLabel;
    } else {
      prevButton.setAttribute('aria-label', 'Ronda anterior');
      prevButton.title = 'Ronda anterior';
    }

    if (nextLabel) {
      nextButton.setAttribute('aria-label', `Ver ${nextLabel}`);
      nextButton.title = nextLabel;
    } else {
      nextButton.setAttribute('aria-label', 'Ronda siguiente');
      nextButton.title = 'Ronda siguiente';
    }
  };

  const setActiveRound = (index) => {
    const clampedIndex = clamp(index, 0, totalRounds - 1);
    activeRoundIndex = clampedIndex;
    grid.dataset.activeRoundIndex = String(clampedIndex);
    nav.dataset.activeRoundIndex = String(clampedIndex);

    sections.forEach((section, sectionIndex) => {
      const isActive = sectionIndex === clampedIndex;
      const isPrevious = sectionIndex === clampedIndex - 1;
      const isNext = sectionIndex === clampedIndex + 1;
      const shouldHide = useFocusMode && sectionIndex !== clampedIndex;

      section.classList.toggle('bracket-round--active', isActive);
      section.classList.toggle('bracket-round--previous', isPrevious);
      section.classList.toggle('bracket-round--next', isNext);
      section.classList.toggle('bracket-round--hidden', shouldHide);
    });

    roundButtons.forEach((button, buttonIndex) => {
      const isActive = buttonIndex === clampedIndex;
      button.classList.toggle('bracket-round-nav__button--active', isActive);
      button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
      button.setAttribute('aria-current', isActive ? 'true' : 'false');
    });

    prevButton.disabled = clampedIndex <= 0;
    nextButton.disabled = clampedIndex >= totalRounds - 1;

    updateActiveLabel();

    scheduleOnNextAnimationFrame(() => applyTournamentBracketRoundOffsets(grid));
  };

  const updateFocusMode = () => {
    const nextFocusMode = evaluateFocusMode();
    if (nextFocusMode === useFocusMode) {
      grid.classList.toggle('tournament-bracket-grid--focus-mode', useFocusMode);
      nav.classList.toggle('bracket-round-nav--focus', useFocusMode);
      buttonList.hidden = useFocusMode;
      activeLabel.hidden = !useFocusMode;
      nav.dataset.focusMode = useFocusMode ? 'true' : 'false';
      updateActiveLabel();
      return;
    }

    useFocusMode = nextFocusMode;
    grid.classList.toggle('tournament-bracket-grid--focus-mode', useFocusMode);
    nav.classList.toggle('bracket-round-nav--focus', useFocusMode);
    buttonList.hidden = useFocusMode;
    activeLabel.hidden = !useFocusMode;
    nav.dataset.focusMode = useFocusMode ? 'true' : 'false';
    setActiveRound(activeRoundIndex);
  };

  prevButton.addEventListener('click', () => {
    setActiveRound(activeRoundIndex - 1);
  });

  nextButton.addEventListener('click', () => {
    setActiveRound(activeRoundIndex + 1);
  });

  nav.addEventListener('keydown', (event) => {
    const target = event.target instanceof HTMLElement ? event.target : null;
    const buttonTarget = target ? target.closest('.bracket-round-nav__button') : null;
    if (!buttonTarget) {
      return;
    }

    let handled = false;
    if (event.key === 'ArrowLeft') {
      setActiveRound(activeRoundIndex - 1);
      handled = true;
    } else if (event.key === 'ArrowRight') {
      setActiveRound(activeRoundIndex + 1);
      handled = true;
    } else if (event.key === 'Home') {
      setActiveRound(0);
      handled = true;
    } else if (event.key === 'End') {
      setActiveRound(totalRounds - 1);
      handled = true;
    }

    if (handled) {
      event.preventDefault();
      const activeButton = roundButtons[activeRoundIndex];
      if (activeButton) {
        activeButton.focus();
      }
    }
  });

  if (desktopMediaQuery?.addEventListener) {
    desktopMediaQuery.addEventListener('change', updateFocusMode);
  } else if (desktopMediaQuery?.addListener) {
    desktopMediaQuery.addListener(updateFocusMode);
  }

  setActiveRound(activeRoundIndex);

  updateFocusMode();

  updateActiveLabel();

  return nav;
}

function buildTournamentBracketGrid(matches = [], { seedByPlayer = new Map() } = {}) {
  const sanitizedMatches = Array.isArray(matches) ? matches.filter(Boolean) : [];
  const roundsByOrder = new Map();

  sanitizedMatches.forEach((match) => {
    const order = Math.max(Number(match?.roundOrder) || 1, 1);
    if (!roundsByOrder.has(order)) {
      roundsByOrder.set(order, { order, matches: [], name: '' });
    }

    const roundEntry = roundsByOrder.get(order);
    roundEntry.matches.push(match);

    if (!roundEntry.name && typeof match?.round === 'string' && match.round.trim()) {
      roundEntry.name = match.round.trim();
    }
  });

  const sortedRounds = Array.from(roundsByOrder.values()).sort((a, b) => a.order - b.order);

  if (!sortedRounds.length && sanitizedMatches.length) {
    sortedRounds.push({ order: 1, matches: sanitizedMatches.slice(), name: '' });
  }

  const totalRounds = sortedRounds.length || 1;

  const fallbackTitleMap = new Map([
    [1, 'Final'],
    [2, 'Semifinales'],
    [4, 'Cuartos de final'],
    [8, 'Octavos de final'],
    [16, 'Dieciseisavos de final'],
    [32, 'Treintaidosavos de final'],
  ]);

  const grid = document.createElement('div');
  grid.className = 'tournament-bracket-grid tournament-bracket-grid--by-round';
  const roundSections = [];

  sortedRounds.forEach((roundEntry, roundIndex) => {
    const roundMatches = Array.isArray(roundEntry.matches) ? roundEntry.matches.slice() : [];
    roundMatches.sort((a, b) => (Number(a?.matchNumber) || 0) - (Number(b?.matchNumber) || 0));

    const roundSection = document.createElement('section');
    roundSection.className = 'bracket-round';
    roundSection.dataset.roundIndex = String(roundIndex);

    const roundTitle = document.createElement('h5');
    roundTitle.className = 'bracket-round__title';

    const matchCountLabel = Math.max(roundMatches.length, 1);
    const displayName =
      roundEntry.name ||
      fallbackTitleMap.get(matchCountLabel) ||
      `Ronda ${roundEntry.order || roundIndex + 1}`;

    roundTitle.textContent = displayName;
    roundSection.dataset.roundName = displayName;
    roundSection.appendChild(roundTitle);

    const matchList = document.createElement('div');
    matchList.className = 'bracket-round__matches bracket-round__matches--list';

    if (!roundMatches.length) {
      const placeholder = document.createElement('div');
      placeholder.className = 'bracket-round__empty';
      placeholder.textContent = 'Partidos pendientes de definir.';
      matchList.appendChild(placeholder);
    } else {
      roundMatches.forEach((match, matchIndex) => {
        const card = createBracketMatchCard(match, seedByPlayer, {
          roundIndex,
          totalRounds,
          slotIndex: matchIndex,
          useConnectors: true,
        });
        matchList.appendChild(card);
      });
    }

    roundSection.appendChild(matchList);
    grid.appendChild(roundSection);
    roundSections.push(roundSection);
  });

  const initialRoundIndex = determineInitialBracketRoundIndex(sortedRounds);
  const navigation = createBracketRoundNavigation(roundSections, grid, {
    initialRoundIndex,
  });

  if (navigation) {
    const wrapper = document.createElement('div');
    wrapper.className = 'tournament-bracket-grid-wrapper';
    wrapper.appendChild(navigation);
    wrapper.appendChild(grid);
    return wrapper;
  }

  return grid;
}

function createTournamentBracketSection({
  title = '',
  matches = [],
  seedByPlayer = new Map(),
  drawSize = null,
} = {}) {
  const section = document.createElement('section');
  section.className = 'tournament-bracket-section';

  const heading = document.createElement('h4');
  heading.className = 'tournament-bracket-section__title';
  heading.textContent = title || '';
  section.appendChild(heading);

  const grid = buildTournamentBracketGrid(matches, { seedByPlayer, drawSize });
  section.appendChild(grid);

  scheduleTournamentBracketAlignment(section);

  return section;
}

function renderTournamentBracket(
  matches = [],
  { loading = false, error = '', preview = false, previewDrawSize = null } = {}
) {
  if (!tournamentBracketView || !tournamentBracketEmpty) {
    return;
  }

  tournamentBracketView.innerHTML = '';
  if (tournamentConsolationView) {
    tournamentConsolationView.innerHTML = '';
  }

  if (state.tournamentBracketAlignmentCallbacks instanceof Set) {
    state.tournamentBracketAlignmentCallbacks.clear();
  }

  const hideConsolationCard = (message) => {
    if (tournamentConsolationEmpty) {
      tournamentConsolationEmpty.hidden = false;
      tournamentConsolationEmpty.textContent =
        message || 'El cuadro de consolación se mostrará aquí cuando esté disponible.';
    }
    if (tournamentConsolationViewCard) {
      tournamentConsolationViewCard.hidden = true;
    }
  };

  const showConsolationMessage = (message) => {
    if (tournamentConsolationEmpty) {
      tournamentConsolationEmpty.hidden = false;
      tournamentConsolationEmpty.textContent = message;
    }
    if (tournamentConsolationViewCard) {
      tournamentConsolationViewCard.hidden = false;
    }
  };

  hideConsolationCard();

  const tournamentId = state.selectedBracketTournamentId;
  const categoryId = state.selectedBracketCategoryId;

  if (tournamentBracketViewCard) {
    if (preview) {
      tournamentBracketViewCard.dataset.preview = 'true';
    } else {
      delete tournamentBracketViewCard.dataset.preview;
    }
  }

  if (!tournamentId || !categoryId) {
    tournamentBracketEmpty.hidden = false;
    tournamentBracketEmpty.textContent =
      'Selecciona una categoría para visualizar su cuadro de juego.';
    return;
  }

  if (loading) {
    tournamentBracketEmpty.hidden = false;
    tournamentBracketEmpty.textContent = 'Cargando cuadro de juego...';
    showConsolationMessage('Cargando cuadro de consolación...');
    return;
  }

  if (error) {
    tournamentBracketEmpty.hidden = false;
    tournamentBracketEmpty.textContent = error;
    showConsolationMessage('No fue posible cargar el cuadro de consolación.');
    return;
  }

  const normalizedMatches = Array.isArray(matches) ? matches : [];
  const normalizedPreviewDrawSize = Number(previewDrawSize);
  const hasPreviewDrawSize =
    Number.isFinite(normalizedPreviewDrawSize) && normalizedPreviewDrawSize > 0;
  const mainMatches = normalizedMatches.filter((match) => match?.bracketType === 'principal');
  const consolationMatches = normalizedMatches.filter((match) => match?.bracketType === 'consolacion');

  if (!mainMatches.length && !consolationMatches.length) {
    tournamentBracketEmpty.hidden = false;
    if (preview) {
      tournamentBracketEmpty.textContent = 'La previsualización del cuadro no tiene partidos que mostrar.';
      showConsolationMessage('La previsualización del cuadro de consolación no tiene partidos.');
    } else {
      tournamentBracketEmpty.textContent = 'Aún no se ha generado el cuadro para esta categoría.';
      showConsolationMessage('Aún no se ha generado el cuadro de consolación para esta categoría.');
    }
    return;
  }

  const category = getTournamentCategoryById(tournamentId, categoryId);
  const seedLookup = buildSeedLookup(category);
  const seedByPlayer = seedLookup.byPlayer;
  const effectiveDrawSize = hasPreviewDrawSize
    ? normalizedPreviewDrawSize
    : Number(category?.drawSize);

  if (mainMatches.length) {
    const mainSection = createTournamentBracketSection({
      title: 'Cuadro principal',
      matches: mainMatches,
      seedByPlayer,
      drawSize: effectiveDrawSize,
    });
    tournamentBracketView.appendChild(mainSection);
    tournamentBracketEmpty.hidden = true;
  } else {
    tournamentBracketEmpty.hidden = false;
    tournamentBracketEmpty.textContent = 'Esta categoría no tiene partidos en el cuadro principal.';
  }

  if (consolationMatches.length && tournamentConsolationView) {
    const consolationSection = createTournamentBracketSection({
      title: 'Cuadro de consolación',
      matches: consolationMatches,
      seedByPlayer,
    });
    tournamentConsolationView.appendChild(consolationSection);
    if (tournamentConsolationEmpty) {
      tournamentConsolationEmpty.hidden = true;
    }
    if (tournamentConsolationViewCard) {
      tournamentConsolationViewCard.hidden = false;
    }
  } else {
    showConsolationMessage('Esta categoría no tiene partidos en el cuadro de consolación.');
  }
}

function renderTournamentBracketSeeds({
  tournamentId = '',
  categoryId = '',
  enrollments = [],
  category = null,
  pairs = [],
} = {}) {
  if (!tournamentBracketSeedsContainer) {
    return;
  }

  tournamentBracketSeedsContainer.innerHTML = '';

  const hasSelection = Boolean(tournamentId && categoryId);
  if (!hasSelection) {
    const message = document.createElement('p');
    message.className = 'empty-state';
    message.textContent = 'Selecciona un torneo y categoría para configurar las siembras.';
    tournamentBracketSeedsContainer.appendChild(message);
    state.tournamentBracketSeedsDirty = false;
    if (tournamentBracketSaveSeedsButton) {
      tournamentBracketSaveSeedsButton.disabled = true;
    }
    return;
  }

  const isDoubles = category?.matchType === 'dobles';
  const participantPluralLabel = isDoubles ? 'parejas' : 'jugadores';

  let participants = [];

  if (isDoubles) {
    participants = (Array.isArray(pairs) ? pairs : [])
      .map((pair) => {
        if (!pair) {
          return null;
        }
        const id = normalizeId(pair);
        if (!id) {
          return null;
        }
        const members = Array.isArray(pair.players)
          ? pair.players.map((member) => (member ? member : null)).filter(Boolean)
          : [];
        if (members.length !== 2) {
          return null;
        }
        return { ...pair, id };
      })
      .filter(Boolean)
      .sort((a, b) => getPlayerDisplayName(a).localeCompare(getPlayerDisplayName(b), 'es'));
  } else {
    const activeEnrollments = Array.isArray(enrollments)
      ? enrollments.filter((entry) => entry && entry.status !== 'cancelada' && entry.user)
      : [];

    participants = activeEnrollments
      .map((entry) => entry.user)
      .filter(Boolean)
      .sort((a, b) => (a.fullName || '').localeCompare(b.fullName || '', 'es'));
  }

  const seedLookup = buildSeedLookup(category);
  const drawSizeValue = Number(tournamentBracketSizeSelect?.value);
  const baseDrawSize = Number(category?.drawSize);
  const participantCount = participants.length;
  const drawSize = drawSizeValue || baseDrawSize || participantCount;
  // Número correcto de cabezas de serie según el tamaño del cuadro
  const SEEDS_BY_DRAW = { 8: 2, 16: 4, 32: 8 };
  const desiredSeeds =
    SEEDS_BY_DRAW[drawSize] ?? Math.max(1, Math.floor((Number(drawSize) || 0) / 4));
  const maxSeeds = Math.min(desiredSeeds, participantCount);

  const editable = isAdmin();

  if (!participants.length) {
    const empty = document.createElement('p');
    empty.className = 'empty-state';
    empty.textContent = `No hay ${participantPluralLabel} inscritos disponibles para asignar siembras.`;
    tournamentBracketSeedsContainer.appendChild(empty);
    state.tournamentBracketSeedsDirty = false;
    if (tournamentBracketSaveSeedsButton) {
      tournamentBracketSaveSeedsButton.disabled = true;
    }
    return;
  }

  for (let seedNumber = 1; seedNumber <= Math.max(maxSeeds, 1); seedNumber += 1) {
    const entry = document.createElement('div');
    entry.className = 'tournament-seed-entry';

    const label = document.createElement('div');
    label.className = 'tournament-seed-entry__label';
    label.textContent = `Cabeza de serie #${seedNumber}`;
    entry.appendChild(label);

    const assignedPlayerId = seedLookup.bySeed.get(seedNumber);
    if (editable) {
      const select = document.createElement('select');
      select.dataset.seedNumber = String(seedNumber);
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Sin asignar';
      select.appendChild(placeholder);

      participants.forEach((participant) => {
        const option = document.createElement('option');
        const participantId = normalizeId(participant);
        option.value = participantId;
        option.textContent = getPlayerDisplayName(participant);
        if (assignedPlayerId && participantId === assignedPlayerId) {
          option.selected = true;
        }
        select.appendChild(option);
      });

      select.addEventListener('change', () => {
        state.tournamentBracketSeedsDirty = true;
        if (tournamentBracketSaveSeedsButton) {
          tournamentBracketSaveSeedsButton.disabled = false;
        }
        updateTournamentActionAvailability();
      });

      entry.appendChild(select);
    } else {
      const info = document.createElement('div');
      info.className = 'tournament-seed-entry__player';
      if (assignedPlayerId) {
        const participant =
          participants.find((item) => normalizeId(item) === assignedPlayerId) ||
          (Array.isArray(category?.seeds)
            ? category.seeds.find((seed) => normalizeId(seed.player) === assignedPlayerId)?.player
            : null);
        const participantName =
          participant && typeof participant === 'object'
            ? getPlayerDisplayName(participant)
            : '';
        info.textContent = participantName || 'Sin asignar';
      } else {
        info.textContent = 'Sin asignar';
      }
      entry.appendChild(info);
    }

    tournamentBracketSeedsContainer.appendChild(entry);
  }

  state.tournamentBracketSeedsDirty = false;
  if (tournamentBracketSaveSeedsButton) {
    tournamentBracketSaveSeedsButton.disabled = !editable;
  }

  updateTournamentActionAvailability();
}

function collectTournamentSeedAssignments() {
  if (!tournamentBracketSeedsContainer) {
    return [];
  }

  const selects = tournamentBracketSeedsContainer.querySelectorAll('select[data-seed-number]');
  const assignments = [];
  selects.forEach((select) => {
    const seedNumber = Number(select.dataset.seedNumber);
    const playerId = select.value;
    if (Number.isFinite(seedNumber) && seedNumber > 0 && playerId) {
      assignments.push({ seedNumber, player: playerId });
    }
  });
  return assignments;
}

function validateTournamentSeedAssignments(assignments = []) {
  const seenSeeds = new Set();
  const seenPlayers = new Set();
  for (const entry of assignments) {
    const seedNumber = Number(entry?.seedNumber);
    const playerId = normalizeId(entry?.player);
    if (!seedNumber || !playerId) {
      continue;
    }
    if (seenSeeds.has(seedNumber)) {
      return 'Cada número de siembra solo se puede asignar a un participante.';
    }
    if (seenPlayers.has(playerId)) {
      return 'Un participante no puede tener más de una siembra asignada.';
    }
    seenSeeds.add(seedNumber);
    seenPlayers.add(playerId);
  }
  return '';
}

async function persistTournamentBracketSeeds(assignments, { silent = false } = {}) {
  if (!isAdmin()) {
    return true;
  }

  const tournamentId = state.selectedBracketTournamentId;
  const categoryId = state.selectedBracketCategoryId;
  if (!tournamentId || !categoryId) {
    return false;
  }

  const payload = Array.isArray(assignments) ? assignments : [];

  try {
    const response = await request(`/tournaments/${tournamentId}/categories/${categoryId}/seeds`, {
      method: 'POST',
      body: { seeds: payload },
    });
    if (response && typeof response === 'object') {
      updateTournamentCategoryCache(tournamentId, response);
    }
    state.tournamentBracketSeedsDirty = false;
    if (tournamentBracketSaveSeedsButton) {
      tournamentBracketSaveSeedsButton.disabled = true;
    }
    if (!silent) {
      setStatusMessage(
        tournamentBracketStatus,
        'success',
        'Cabezas de serie actualizadas correctamente.'
      );
    }
    await refreshTournamentDetail(tournamentId);
    return true;
  } catch (error) {
    if (!silent) {
      setStatusMessage(tournamentBracketStatus, 'error', error.message);
    }
    return false;
  }
}

function updateBracketSizeSelect(category) {
  if (!tournamentBracketSizeSelect) {
    return;
  }

  if (!tournamentBracketSizeSelect.childElementCount) {
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Selecciona un tamaño';
    tournamentBracketSizeSelect.appendChild(placeholder);
    TOURNAMENT_BRACKET_SIZES.forEach((size) => {
      const option = document.createElement('option');
      option.value = String(size);
      option.textContent = `${size} jugadores`;
      tournamentBracketSizeSelect.appendChild(option);
    });
  }

  const drawSize = Number(category?.drawSize);
  if (TOURNAMENT_BRACKET_SIZES.includes(drawSize)) {
    tournamentBracketSizeSelect.value = String(drawSize);
  } else {
    tournamentBracketSizeSelect.value = '';
  }

  tournamentBracketSizeSelect.disabled = !isAdmin();

  if (tournamentBracketSizeWrapper) {
    tournamentBracketSizeWrapper.hidden = !isAdmin();
  }
}

async function refreshTournamentBracketMatches({ forceReload = false } = {}) {
  const tournamentId = state.selectedBracketTournamentId;
  const categoryId = state.selectedBracketCategoryId;

  if (!tournamentId || !categoryId) {
    renderTournamentBracket([], { loading: false });
    return;
  }

  const cacheKey = getTournamentBracketCacheKey(tournamentId, categoryId);
  if (!forceReload && state.tournamentBracketMatches.has(cacheKey)) {
    let cached = state.tournamentBracketMatches.get(cacheKey) || [];
    cached = await hydrateTournamentMatchesWithPairs(cached, {
      tournamentId,
      categoryId,
    });
    state.tournamentBracketMatches.set(cacheKey, cached);
    renderTournamentBracket(cached);
    updateTournamentActionAvailability();
    return;
  }

  pendingTournamentBracketKey = cacheKey;
  renderTournamentBracket([], { loading: true });

  try {
    const response = await request(`/tournaments/${tournamentId}/categories/${categoryId}/matches`);
    let list = Array.isArray(response) ? response : [];
    list = await hydrateTournamentMatchesWithPairs(list, { tournamentId, categoryId });
    state.tournamentBracketMatches.set(cacheKey, list);
    if (pendingTournamentBracketKey === cacheKey) {
      renderTournamentBracket(list);
      updateTournamentActionAvailability();
    }
  } catch (error) {
    if (pendingTournamentBracketKey === cacheKey) {
      renderTournamentBracket([], {
        error: error.message || 'No fue posible cargar el cuadro.',
      });
      updateTournamentActionAvailability();
    }
  } finally {
    if (pendingTournamentBracketKey === cacheKey) {
      pendingTournamentBracketKey = '';
    }
  }
}

async function loadTournamentBracketContext({
  tournamentId = state.selectedBracketTournamentId,
  categoryId = state.selectedBracketCategoryId,
  forceMatches = false,
} = {}) {
  if (!tournamentId || !categoryId) {
    renderTournamentBracketSeeds();
    renderTournamentBracket([], { loading: false });
    return;
  }

  setStatusMessage(tournamentBracketStatus, '', '');

  let category = getTournamentCategoryById(tournamentId, categoryId);
  if (!category) {
    try {
      await refreshTournamentDetail(tournamentId);
      category = getTournamentCategoryById(tournamentId, categoryId);
    } catch (error) {
      setStatusMessage(tournamentBracketStatus, 'error', error.message);
    }
  }

  updateBracketSizeSelect(category);

  let enrollments = [];
  try {
    enrollments = await fetchTournamentEnrollments(tournamentId, categoryId, { forceReload: false });
  } catch (error) {
    setStatusMessage(tournamentBracketStatus, 'error', error.message);
  }

  let pairs = [];
  if (category?.matchType === 'dobles') {
    try {
      pairs = await fetchTournamentDoublesPairs(tournamentId, categoryId, { forceReload: false });
    } catch (error) {
      setStatusMessage(tournamentBracketStatus, 'error', error.message);
    }
  }

  renderTournamentBracketSeeds({
    tournamentId,
    categoryId,
    enrollments,
    category,
    pairs,
  });

  await refreshTournamentBracketMatches({ forceReload: forceMatches });
}

async function reloadTournaments({ selectTournamentId } = {}) {
  let tournaments = [];

  try {
    const response = await request('/tournaments');
    tournaments = Array.isArray(response) ? response : [];
  } catch (error) {
    showGlobalMessage(error.message, 'error');
    throw error;
  }

  state.tournaments = tournaments;

  const normalizedSelection = selectTournamentId ? normalizeId(selectTournamentId) : '';
  if (normalizedSelection) {
    state.selectedTournamentId = normalizedSelection;
    state.selectedTournamentCategoriesId = normalizedSelection;
    state.selectedEnrollmentTournamentId = normalizedSelection;
    state.selectedMatchTournamentId = normalizedSelection;
    state.selectedDoublesTournamentId = normalizedSelection;
  }

  const validTournamentIds = new Set(
    tournaments.map((tournament) => normalizeId(tournament)).filter(Boolean)
  );
  state.tournamentDoubles = new Map(
    Array.from(state.tournamentDoubles.entries()).filter(([id]) => validTournamentIds.has(id))
  );
  state.tournamentDoublesPairs = new Map(
    Array.from(state.tournamentDoublesPairs.entries()).filter(([key]) => {
      const [tournamentKey] = String(key).split(':');
      return validTournamentIds.has(tournamentKey);
    })
  );
  state.tournamentBracketMatches = new Map(
    Array.from(state.tournamentBracketMatches.entries()).filter(([key]) => {
      const [tournamentKey] = String(key).split(':');
      return validTournamentIds.has(tournamentKey);
    })
  );

  updateTournamentSelectors();
  updateTournamentPaymentControls();

  if (state.activeSection === 'section-tournament-doubles' && state.selectedDoublesTournamentId) {
    await refreshTournamentDoubles({ force: true });
  }
  return tournaments;
}

function normalizeId(value) {
  if (!value) return '';
  if (typeof value === 'string') return value;
  if (typeof value === 'object') {
    if (value._id) return value._id.toString();
    if (value.id) return value.id.toString();
  }
  return '';
}

function clearTournamentState(tournamentId) {
  const normalized = normalizeId(tournamentId);
  if (!normalized) {
    return;
  }

  if (state.tournamentDetails instanceof Map) {
    state.tournamentDetails.delete(normalized);
  }

  const deleteEntriesWithPrefix = (map) => {
    if (!(map instanceof Map)) {
      return;
    }

    Array.from(map.keys()).forEach((key) => {
      if (String(key).startsWith(`${normalized}:`)) {
        map.delete(key);
      }
    });
  };

  deleteEntriesWithPrefix(state.tournamentEnrollments);
  deleteEntriesWithPrefix(state.tournamentMatches);
  deleteEntriesWithPrefix(state.tournamentDoublesPairs);
  deleteEntriesWithPrefix(state.tournamentBracketMatches);

  if (state.tournamentPayments instanceof Map) {
    state.tournamentPayments.delete(normalized);
  }

  if (state.tournamentDoubles instanceof Map) {
    state.tournamentDoubles.delete(normalized);
  }

  if (state.tournamentOrderOfPlayDays instanceof Map) {
    state.tournamentOrderOfPlayDays.delete(normalized);
  }

  if (state.selectedMatchTournamentId === normalized) {
    state.selectedOrderOfPlayDay = '';
    updateTournamentOrderOfPlayControls();
  }

  if (
    state.tournamentPaymentFilters &&
    typeof state.tournamentPaymentFilters === 'object' &&
    state.tournamentPaymentFilters.tournament === normalized
  ) {
    state.tournamentPaymentFilters.tournament = '';
    state.tournamentPaymentFilters.search = '';
  }
}

function extractScoreMap(rawScores) {
  if (!rawScores) return new Map();
  if (typeof rawScores.get === 'function') {
    return new Map(rawScores);
  }
  if (typeof rawScores === 'object') {
    return new Map(
      Object.entries(rawScores).map(([key, value]) => {
        const numeric = Number(value);
        return [key, Number.isFinite(numeric) && numeric > 0 ? Math.floor(numeric) : 0];
      })
    );
  }
  return new Map();
}

function extractResultSets(match) {
  const players = Array.isArray(match?.players) ? match.players : [];
  const playerIds = players.map((player) => normalizeId(player));
  const rawSets = Array.isArray(match?.result?.sets) ? match.result.sets : [];

  if (!playerIds.length) {
    return [];
  }

  const normalizedSets = rawSets
    .map((set, index) => {
      const number = Number.isFinite(Number(set?.number)) ? Number(set.number) : index + 1;
      const tieBreak = Boolean(set?.tieBreak);
      const scoresMap = extractScoreMap(set?.scores);
      const scores = {};
      playerIds.forEach((playerId) => {
        const value = Number(scoresMap.get(playerId));
        scores[playerId] = Number.isFinite(value) && value >= 0 ? Math.floor(value) : 0;
      });
      const total = Object.values(scores).reduce((acc, value) => acc + value, 0);
      if (total === 0) {
        return null;
      }
      return { number, tieBreak, scores };
    })
    .filter(Boolean);

  if (normalizedSets.length) {
    return normalizedSets;
  }

  return parseScoreStringSets(match?.result?.score, playerIds);
}

function parseScoreStringSets(rawScore, playerIds = []) {
  if (typeof rawScore !== 'string' || playerIds.length < 2) {
    return [];
  }

  const cleaned = rawScore.trim();
  if (!cleaned) {
    return [];
  }

  const sets = [];
  const regex = /([\d]{1,2})\s*[-–—xX/]\s*([\d]{1,2})/g;
  let matchResult;

  while ((matchResult = regex.exec(cleaned)) !== null) {
    const firstScore = Number(matchResult[1]);
    const secondScore = Number(matchResult[2]);

    if (!Number.isFinite(firstScore) || !Number.isFinite(secondScore)) {
      continue;
    }

    const segment = matchResult[0];
    const scores = {};
    scores[playerIds[0]] = Math.max(0, Math.floor(firstScore));
    scores[playerIds[1]] = Math.max(0, Math.floor(secondScore));

    const maximumScore = Math.max(scores[playerIds[0]], scores[playerIds[1]]);
    const minimumScore = Math.min(scores[playerIds[0]], scores[playerIds[1]]);
    const tieBreak =
      /tb|tie|super/i.test(segment) ||
      /[\[\]()]/.test(segment) ||
      maximumScore >= 8 ||
      (maximumScore === 7 && minimumScore === 6);

    sets.push({
      number: sets.length + 1,
      tieBreak,
      scores,
    });
  }

  return sets;
}

function aggregateSetsForPlayers(sets, playerIds = []) {
  if (!Array.isArray(sets) || !sets.length) {
    return null;
  }
  const totals = {};
  playerIds.forEach((playerId) => {
    totals[playerId] = 0;
  });
  sets.forEach((set) => {
    playerIds.forEach((playerId) => {
      const value = Number(set.scores?.[playerId]);
      if (Number.isFinite(value)) {
        totals[playerId] += Math.max(0, value);
      }
    });
  });
  return totals;
}

function getMatchSets(match) {
  const sets = extractResultSets(match);
  const players = Array.isArray(match?.players) ? match.players : [];
  const playerIds = players.map((player) => normalizeId(player));
  if (!sets.length || playerIds.length < 2) {
    return [];
  }

  return sets.map((set) => {
    const normalizedScores = {};
    playerIds.forEach((playerId) => {
      const value = Number(set.scores?.[playerId]);
      normalizedScores[playerId] = Number.isFinite(value) && value >= 0 ? Math.floor(value) : 0;
    });
    return {
      number: set.number,
      tieBreak: Boolean(set.tieBreak),
      scores: normalizedScores,
    };
  });
}

function getMatchScores(match) {
  const players = Array.isArray(match?.players) ? match.players : [];
  const playerIds = players.map((player) => normalizeId(player));
  const sets = getMatchSets(match);
  let scoreMap;

  if (sets.length) {
    const totals = aggregateSetsForPlayers(sets, playerIds) || {};
    scoreMap = new Map(Object.entries(totals));
  } else {
    scoreMap = extractScoreMap(match?.result?.scores);
  }

  return players.map((player) => {
    const id = normalizeId(player);
    const games = Number(scoreMap.get(id)) || 0;
    return {
      id,
      games,
      player,
    };
  });
}

function resolveWinnerId(match) {
  const winner = match?.result?.winner;
  if (!winner) {
    return '';
  }

  if (typeof winner === 'string') {
    return winner;
  }

  if (typeof winner === 'object') {
    return normalizeId(winner);
  }

  return '';
}

function createResultScoreboard(match) {
  const sets = getMatchSets(match);
  const participants = getMatchScores(match);

  if (!sets.length || participants.length < 2) {
    return null;
  }

  const scoreboard = document.createElement('div');
  scoreboard.className = 'result-scoreboard';
  scoreboard.setAttribute('role', 'table');
  scoreboard.setAttribute('aria-label', 'Marcador por sets');
  scoreboard.style.setProperty('--sets-count', Math.max(sets.length, 1));

  const winnerId = resolveWinnerId(match);

  participants.forEach((participant) => {
    const row = document.createElement('div');
    row.className = 'result-scoreboard__row';
    row.setAttribute('role', 'row');

    if (participant.id && participant.id === winnerId) {
      row.classList.add('result-scoreboard__row--winner');
    }

    const nameCell = document.createElement('span');
    nameCell.className = 'result-scoreboard__cell result-scoreboard__cell--player';
    nameCell.setAttribute('role', 'rowheader');
    const playerName =
      typeof participant.player === 'object'
        ? participant.player.fullName || participant.player.email || 'Jugador'
        : 'Jugador';
    nameCell.textContent = playerName;
    row.appendChild(nameCell);

    sets.forEach((set, index) => {
      const scoreCell = document.createElement('span');
      scoreCell.className = 'result-scoreboard__cell result-scoreboard__cell--score';
      scoreCell.setAttribute('role', 'cell');

      const scoreValue = Number(set.scores?.[participant.id]);
      const displayValue = Number.isFinite(scoreValue) && scoreValue >= 0 ? Math.floor(scoreValue) : '';
      scoreCell.textContent = displayValue;

      if (set.tieBreak) {
        scoreCell.classList.add('result-scoreboard__cell--tiebreak');
        scoreCell.setAttribute('aria-label', `Super tie-break set ${index + 1}: ${displayValue}`);
      }

      row.appendChild(scoreCell);
    });

    scoreboard.appendChild(row);
  });

  return scoreboard;
}

function formatMatchScore(match) {
  const sets = getMatchSets(match);
  const participants = getMatchScores(match);
  if (sets.length >= 1 && participants.length >= 2) {
    const [first, second] = participants;
    const setLabels = sets.map((set) => {
      const firstScore = set.scores?.[first.id] ?? 0;
      const secondScore = set.scores?.[second.id] ?? 0;
      const base = `${firstScore}-${secondScore}`;
      return set.tieBreak ? `[${base}]` : base;
    });
    return `Marcador: ${setLabels.join(', ')}`;
  }

  const scores = participants;
  if (!scores.length) {
    return '';
  }

  return scores
    .map(({ player, games }) => {
      const name = typeof player === 'object' ? player.fullName || player.email || 'Jugador' : 'Jugador';
      return `${name}: ${games} juego${games === 1 ? '' : 's'}`;
    })
    .join(' · ');
}

function getResultConfirmation(match, userId) {
  if (!match?.result?.confirmations || !userId) return null;
  const confirmations = match.result.confirmations;
  if (typeof confirmations.get === 'function') {
    return confirmations.get(userId) || null;
  }
  if (typeof confirmations === 'object') {
    return confirmations[userId] || null;
  }
  return null;
}

function getProposalCalendarDate(match) {
  if (!match || match.status !== 'propuesto') {
    return null;
  }

  const proposal = match.proposal || {};
  const proposalStatus = proposal.status || 'pendiente';
  if (proposalStatus !== 'pendiente') {
    return null;
  }

  const proposedFor = proposal.proposedFor;
  if (!proposedFor) {
    return null;
  }

  const proposedDate = new Date(proposedFor);
  if (Number.isNaN(proposedDate.getTime())) {
    return null;
  }

  return proposedDate;
}

function getMatchCalendarDate(match) {
  if (!match) {
    return null;
  }

  if (match.scheduledAt) {
    const scheduledDate = new Date(match.scheduledAt);
    if (!Number.isNaN(scheduledDate.getTime())) {
      return scheduledDate;
    }
  }

  return getProposalCalendarDate(match);
}

function buildCalendarDataset(matches = []) {
  const scheduled = [];
  const unscheduled = [];

  matches.forEach((match) => {
    const calendarDate = getMatchCalendarDate(match);
    if (calendarDate) {
      if (match.scheduledAt) {
        scheduled.push(match);
      } else {
        scheduled.push({ ...match, scheduledAt: calendarDate.toISOString() });
      }
    } else {
      unscheduled.push(match);
    }
  });

  scheduled.sort((a, b) => {
    const firstDate = getMatchCalendarDate(a);
    const secondDate = getMatchCalendarDate(b);
    if (!firstDate || !secondDate) {
      return 0;
    }
    return firstDate - secondDate;
  });

  const grouped = new Map();
  scheduled.forEach((match) => {
    const matchDate = getMatchCalendarDate(match);
    if (!matchDate) {
      return;
    }
    const key = startOfDay(matchDate).getTime();
    if (!grouped.has(key)) {
      grouped.set(key, []);
    }
    grouped.get(key).push(match);
  });

  grouped.forEach((dayMatches) => {
    dayMatches.sort((a, b) => {
      const firstDate = getMatchCalendarDate(a);
      const secondDate = getMatchCalendarDate(b);
      if (!firstDate || !secondDate) {
        return 0;
      }
      return firstDate - secondDate;
    });
  });

  return { grouped, unscheduled };
}

const CALENDAR_MATCH_STATUS_SET = new Set(CALENDAR_MATCH_STATUSES);

function getCalendarMatchesForDisplay() {
  const matches = Array.isArray(state.calendarMatches) ? state.calendarMatches : [];
  return matches.filter((match) => CALENDAR_MATCH_STATUS_SET.has(match.status));
}

function getScheduledCalendarMatches() {
  return getCalendarMatchesForDisplay().filter((match) => Boolean(match.scheduledAt));
}

function findMatchById(matchId) {
  const normalizedId = normalizeId(matchId);
  if (!normalizedId) {
    return null;
  }

  const sources = [
    state.calendarMatches,
    state.upcomingMatches,
    state.myMatches,
    state.pendingApprovalMatches,
    state.completedMatches,
  ];

  for (const source of sources) {
    if (!Array.isArray(source)) continue;
    const found = source.find((item) => normalizeId(item) === normalizedId);
    if (found) {
      return found;
    }
  }

  return null;
}

function findTournamentMatchContext(matchId) {
  const normalizedId = normalizeId(matchId);
  if (!normalizedId) {
    return null;
  }

  const parseKey = (key = '') => {
    if (!key) {
      return { tournamentId: '', categoryId: '' };
    }
    const [tournamentId = '', categoryId = ''] = key.split(':');
    return {
      tournamentId: tournamentId || '',
      categoryId: categoryId || '',
    };
  };

  const sources = [
    state.tournamentMatches instanceof Map ? state.tournamentMatches : null,
    state.tournamentBracketMatches instanceof Map ? state.tournamentBracketMatches : null,
  ].filter(Boolean);

  for (const source of sources) {
    for (const [key, matches] of source.entries()) {
      if (!Array.isArray(matches)) continue;
      const found = matches.find((entry) => normalizeId(entry) === normalizedId);
      if (found) {
        const context = parseKey(key);
        return {
          match: found,
          tournamentId: context.tournamentId,
          categoryId: context.categoryId,
        };
      }
    }
  }

  return null;
}

async function applyTournamentMatchUpdate(updatedMatch) {
  const normalizedId = normalizeId(updatedMatch);
  if (!normalizedId) {
    return;
  }

  const hydrationTasks = [];
  const tournamentsToRecompute = new Set();

  const processMap = (map, trackOrderOfPlay = false) => {
    if (!(map instanceof Map)) {
      return;
    }

    map.forEach((matches, key) => {
      if (!Array.isArray(matches)) {
        return;
      }

      let changed = false;
      const nextMatches = matches.map((entry) => {
        if (normalizeId(entry) === normalizedId) {
          changed = true;
          return updatedMatch;
        }
        return entry;
      });

      if (!changed) {
        return;
      }

      map.set(key, nextMatches);

      if (trackOrderOfPlay) {
        const [tournamentId = ''] = (key || '').split(':');
        if (tournamentId) {
          tournamentsToRecompute.add(tournamentId);
        }
      }

      const [tournamentId = '', categoryId = ''] = (key || '').split(':');
      hydrationTasks.push(
        (async () => {
          try {
            const hydrated = await hydrateTournamentMatchesWithPairs(nextMatches, {
              tournamentId,
              categoryId,
            });
            map.set(key, hydrated);
          } catch (error) {
            map.set(key, nextMatches);
          }
        })()
      );
    });
  };

  processMap(state.tournamentMatches, true);
  processMap(state.tournamentBracketMatches);

  if (hydrationTasks.length) {
    await Promise.all(hydrationTasks);
  }

  tournamentsToRecompute.forEach((tournamentId) => {
    recomputeTournamentOrderOfPlayDays(tournamentId);
  });
}

function isUserMatchParticipant(match, user = state.user) {
  if (!match || !Array.isArray(match.players)) {
    return false;
  }

  const userId = normalizeId(user);
  if (!userId) {
    return false;
  }

  return match.players.some((player) => normalizeId(player) === userId);
}

function collectMatchDetailMessages(match) {
  if (!match) {
    return [];
  }

  const messages = [];
  const resultStatus = match.result?.status || '';

  if (match.status === 'programado') {
    if (match.scheduledAt) {
      const scheduleLabel = formatDate(match.scheduledAt);
      const courtLabel = formatCourtDisplay(match.court);
      messages.push(
        courtLabel ? `Programado para ${scheduleLabel} · ${courtLabel}` : `Programado para ${scheduleLabel}`
      );
    } else if (match.court) {
      const courtLabel = formatCourtDisplay(match.court);
      if (courtLabel) {
        messages.push(`Pista asignada: ${courtLabel}.`);
      }
    }
  } else if (match.status === 'pendiente') {
    messages.push('A la espera de que alguien proponga fecha y hora.');
  } else if (match.status === 'propuesto' && match.proposal) {
    const proposer = getPlayerDisplayName(match.proposal.requestedBy) || 'Un jugador';
    if (match.proposal.proposedFor) {
      messages.push(`${proposer} propuso ${formatDate(match.proposal.proposedFor)}.`);
    } else {
      messages.push(`${proposer} ha propuesto disputar el partido.`);
    }
    if (match.court) {
      const courtLabel = formatCourtDisplay(match.court);
      if (courtLabel) {
        messages.push(`Pista sugerida: ${courtLabel}.`);
      }
    }
    if (match.proposal.message) {
      messages.push(`Mensaje: ${match.proposal.message}`);
    }
  } else if (match.status === 'revision' || resultStatus === 'en_revision') {
    messages.push('Resultado pendiente de confirmación.');
  } else if (match.status === 'caducado') {
    messages.push('El plazo para disputar el partido venció sin puntos.');
  }

  if (resultStatus === 'rechazado') {
    messages.push('El resultado enviado fue rechazado. Vuelve a registrarlo.');
  }

  return messages;
}

function getResultStatusMessage(status) {
  switch (status) {
    case 'confirmado':
      return 'Resultado confirmado.';
    case 'en_revision':
      return 'Resultado pendiente de confirmación.';
    case 'rechazado':
      return 'El resultado enviado fue rechazado.';
    case 'pendiente':
      return 'Resultado pendiente.';
    default:
      return '';
  }
}

function formatCourtDisplay(value) {
  if (!value) {
    return '';
  }

  const court = (typeof value === 'string' ? value : String(value)).trim();
  if (!court) {
    return '';
  }

  return court.toLocaleLowerCase('es-ES').startsWith('pista') ? court : `Pista ${court}`;
}

function getMatchParticipantName(match, participant) {
  if (!participant) {
    return '';
  }

  if (typeof participant === 'object') {
    return getPlayerDisplayName(participant);
  }

  if (typeof participant === 'string' && Array.isArray(match?.players)) {
    const found = match.players.find((player) => normalizeId(player) === participant);
    if (found) {
      return getPlayerDisplayName(found);
    }
  }

  return '';
}

function openMatchViewer(match, { allowResultEdit = false, allowMatchEdit = false } = {}) {
  if (!match) {
    showGlobalMessage('No fue posible cargar los datos del partido.', 'error');
    return;
  }

  const matchId = normalizeId(match);
  const container = document.createElement('div');
  container.className = 'match-viewer';

  const infoSection = document.createElement('div');
  infoSection.className = 'match-viewer__section';
  const infoList = document.createElement('dl');
  infoList.className = 'match-viewer__info';

  const appendInfo = (label, value) => {
    const term = document.createElement('dt');
    term.textContent = label;
    infoList.appendChild(term);
    const detail = document.createElement('dd');
    if (value instanceof Node) {
      detail.appendChild(value);
    } else {
      detail.textContent = value;
    }
    infoList.appendChild(detail);
  };

  const statusTag = document.createElement('span');
  statusTag.className = `tag status-${match.status}`;
  statusTag.textContent = STATUS_LABELS[match.status] || match.status || 'Estado por confirmar';
  appendInfo('Estado', statusTag);

  const categoryLabel = document.createElement('span');
  categoryLabel.className = 'tag match-category-tag';
  categoryLabel.textContent = match.category?.name || 'Sin categoría';
  const categoryColor = match.category ? getCategoryColor(match.category) : '';
  applyCategoryTagColor(categoryLabel, categoryColor);
  appendInfo('Categoría', categoryLabel);

  const scheduleLabel = match.scheduledAt ? formatDate(match.scheduledAt) : 'Por confirmar';
  const courtDisplay = formatCourtDisplay(match.court) || 'Por confirmar';
  appendInfo('Fecha', scheduleLabel);
  appendInfo('Pista', courtDisplay);

  infoSection.appendChild(infoList);
  container.appendChild(infoSection);

  const detailMessages = collectMatchDetailMessages(match);
  if (detailMessages.length) {
    const detailsSection = document.createElement('div');
    detailsSection.className = 'match-viewer__section';
    const detailsList = document.createElement('div');
    detailsList.className = 'match-viewer__details';
    detailMessages.forEach((message) => {
      const paragraph = document.createElement('p');
      paragraph.className = 'meta';
      paragraph.textContent = message;
      detailsList.appendChild(paragraph);
    });
    detailsSection.appendChild(detailsList);
    container.appendChild(detailsSection);
  }

  const warningMessage = getExpirationWarningMessage(match);
  if (warningMessage && match.status !== 'caducado') {
    const warning = document.createElement('p');
    warning.className = 'deadline-warning';
    warning.textContent = warningMessage;
    container.appendChild(warning);
  }

  const playersSection = document.createElement('div');
  playersSection.className = 'match-viewer__section';
  const playersTitle = document.createElement('h4');
  playersTitle.textContent = 'Jugadores';
  playersSection.appendChild(playersTitle);

  const playersList = document.createElement('ul');
  playersList.className = 'match-viewer__players';
  const players = Array.isArray(match.players) ? match.players : [];

  if (!players.length) {
    const empty = document.createElement('li');
    empty.className = 'match-viewer__player';
    empty.textContent = 'Jugadores por definir.';
    playersList.appendChild(empty);
  } else {
    const currentUserId = normalizeId(state.user);
    players.forEach((player) => {
      const item = document.createElement('li');
      item.className = 'match-viewer__player';

      const name = document.createElement('span');
      name.className = 'match-viewer__player-name';
      name.textContent = getPlayerDisplayName(player);
      item.appendChild(name);

      const meta = [];
      if (player?.preferredSchedule) {
        meta.push(`Horario preferido: ${translateSchedule(player.preferredSchedule)}`);
      }
      if (normalizeId(player) === currentUserId) {
        meta.push('Tú');
      }

      if (meta.length) {
        const metaRow = document.createElement('div');
        metaRow.className = 'match-viewer__player-meta';
        meta.forEach((entry) => {
          if (entry === 'Tú') {
            const selfTag = document.createElement('span');
            selfTag.className = 'tag';
            selfTag.textContent = entry;
            metaRow.appendChild(selfTag);
          } else {
            const metaItem = document.createElement('span');
            metaItem.textContent = entry;
            metaRow.appendChild(metaItem);
          }
        });
        item.appendChild(metaRow);
      }

      playersList.appendChild(item);
    });
  }

  playersSection.appendChild(playersList);
  container.appendChild(playersSection);

  const resultSection = document.createElement('div');
  resultSection.className = 'match-viewer__section';
  const resultTitle = document.createElement('h4');
  resultTitle.textContent = 'Resultado';
  resultSection.appendChild(resultTitle);

  const resultStatusMessage = getResultStatusMessage(match.result?.status);
  if (resultStatusMessage) {
    const statusParagraph = document.createElement('p');
    statusParagraph.className = 'meta';
    statusParagraph.textContent = resultStatusMessage;
    resultSection.appendChild(statusParagraph);
  }

  const winnerName = getMatchParticipantName(match, match.result?.winner);
  if (winnerName) {
    const winnerParagraph = document.createElement('p');
    winnerParagraph.className = 'meta';
    winnerParagraph.textContent = `Ganador: ${winnerName}`;
    resultSection.appendChild(winnerParagraph);
  }

  const scoreboard = createResultScoreboard(match);
  const scoreSummary = formatMatchScore(match);

  if (scoreboard) {
    resultSection.appendChild(scoreboard);
  } else if (scoreSummary) {
    const summaryParagraph = document.createElement('p');
    summaryParagraph.className = 'meta';
    summaryParagraph.textContent = scoreSummary;
    resultSection.appendChild(summaryParagraph);
  }

  if (match.result?.notes) {
    const resultNotes = document.createElement('p');
    resultNotes.className = 'match-viewer__notes';
    resultNotes.textContent = match.result.notes;
    resultSection.appendChild(resultNotes);
  }

  const reporterName = getMatchParticipantName(match, match.result?.reportedBy);
  if (reporterName) {
    const reporterParagraph = document.createElement('p');
    reporterParagraph.className = 'meta';
    reporterParagraph.textContent = `Reportado por ${reporterName}.`;
    resultSection.appendChild(reporterParagraph);
  }

  if (resultSection.childNodes.length > 1) {
    container.appendChild(resultSection);
  }

  if (isAdmin() && match.notes) {
    const adminNotesSection = document.createElement('div');
    adminNotesSection.className = 'match-viewer__section';
    const adminNotesTitle = document.createElement('h4');
    adminNotesTitle.textContent = 'Notas internas';
    adminNotesSection.appendChild(adminNotesTitle);
    const adminNotes = document.createElement('p');
    adminNotes.className = 'match-viewer__notes';
    adminNotes.textContent = match.notes;
    adminNotesSection.appendChild(adminNotes);
    container.appendChild(adminNotesSection);
  }

  if (allowMatchEdit || allowResultEdit) {
    const actions = document.createElement('div');
    actions.className = 'match-viewer__actions';

    if (allowResultEdit && matchId) {
      const needsReview = match.status === 'revision' || match.result?.status === 'en_revision';
      const resultButton = document.createElement('button');
      resultButton.type = 'button';
      resultButton.className = 'primary';
      resultButton.textContent = needsReview ? 'Revisar resultado' : 'Registrar resultado';
      resultButton.addEventListener('click', () => {
        closeModal();
        openResultModal(matchId);
      });
      actions.appendChild(resultButton);
    }

    if (allowMatchEdit && matchId) {
      const editButton = document.createElement('button');
      editButton.type = 'button';
      editButton.className = 'secondary';
      editButton.textContent = 'Editar partido';
      editButton.addEventListener('click', () => {
        closeModal();
        openMatchModal(matchId);
      });
      actions.appendChild(editButton);
    }

    if (actions.childNodes.length) {
      container.appendChild(actions);
    }
  }

  const modalTitle = Array.isArray(match.players) && match.players.length
    ? match.players.map((player) => getPlayerDisplayName(player)).join(' vs ')
    : 'Detalle del partido';

  openModal({
    title: modalTitle,
    content: (body) => {
      body.appendChild(container);
    },
  });
}

function openCalendarMatch(matchId) {
  if (!matchId) return;

  const match = findMatchById(matchId);
  if (!match) {
    showGlobalMessage('No fue posible cargar los datos del partido.', 'error');
    return;
  }

  const allowMatchEdit = isAdmin();
  const allowResultEdit = allowMatchEdit || isUserMatchParticipant(match);
  openMatchViewer(match, { allowMatchEdit, allowResultEdit });
}

function bindCalendarEvent(element, matchId) {
  if (!element || !matchId) return;
  element.dataset.matchId = matchId;
  element.tabIndex = 0;
  element.setAttribute('role', 'button');
  element.classList.add('calendar-event--actionable');
  element.addEventListener('click', () => {
    openCalendarMatch(matchId);
  });
  element.addEventListener('keydown', (event) => {
    if (event.key === 'Enter' || event.key === ' ') {
      event.preventDefault();
      openCalendarMatch(matchId);
    }
  });
}

function createCalendarEvent(match) {
  const container = document.createElement('div');
  container.className = `calendar-event ${match.status === 'programado' ? 'confirmed' : 'pending'}`;
  const categoryColor = match.category ? getCategoryColor(match.category) : '';

  const title = document.createElement('strong');
  const players = Array.isArray(match.players)
    ? match.players.map((player) => player.fullName || 'Jugador').join(' vs ')
    : 'Partido';
  title.textContent = players;
  if (categoryColor) {
    const indicator = createCategoryColorIndicator(categoryColor, match.category?.name);
    if (indicator) {
      title.classList.add('with-category-color');
      title.prepend(indicator);
    }
  }
  container.appendChild(title);

  const meta = document.createElement('div');
  meta.className = 'meta';
  meta.appendChild(document.createElement('span')).textContent = formatTime(match.scheduledAt);
  if (match.court) {
    meta.appendChild(document.createElement('span')).textContent = `Pista ${match.court}`;
  }
  const statusTag = document.createElement('span');
  statusTag.className = `tag status-${match.status}`;
  statusTag.textContent = STATUS_LABELS[match.status] || match.status;
  meta.appendChild(statusTag);
  container.appendChild(meta);

  if (match.category?.name) {
    const category = document.createElement('div');
    category.className = 'meta';
    const categoryTag = document.createElement('span');
    categoryTag.className = 'tag match-category-tag';
    categoryTag.textContent = match.category.name;
    applyCategoryTagColor(categoryTag, categoryColor, { backgroundAlpha: 0.22 });
    category.appendChild(categoryTag);
    container.appendChild(category);
  }

  if (categoryColor) {
    applyCategoryColorStyles(container, categoryColor, { backgroundAlpha: 0.18, borderAlpha: 0.32 });
  }

  const matchId = normalizeId(match);
  if (matchId) {
    bindCalendarEvent(container, matchId);
  }

  return container;
}

function renderUnscheduledMatches(matches = [], container = calendarContainer) {
  if (!matches.length || !container) return;

  const block = document.createElement('div');
  block.className = 'calendar-day';
  const header = document.createElement('div');
  header.className = 'calendar-day-header';
  header.innerHTML = '<strong>Sin fecha asignada</strong><span>Pendientes de confirmar</span>';
  block.appendChild(header);

  matches.forEach((match) => {
    const statusClass = match.status === 'programado' ? 'confirmed' : 'pending';
    const event = document.createElement('div');
    event.className = `calendar-event ${statusClass}`;
    const categoryColor = match.category ? getCategoryColor(match.category) : '';
    const title = document.createElement('strong');
    const players = Array.isArray(match.players)
      ? match.players.map((player) => player.fullName || 'Jugador').join(' vs ')
      : 'Partido';
    title.textContent = players;
    if (categoryColor) {
      const indicator = createCategoryColorIndicator(categoryColor, match.category?.name);
      if (indicator) {
        title.classList.add('with-category-color');
        title.prepend(indicator);
      }
    }
    event.appendChild(title);

    const meta = document.createElement('div');
    meta.className = 'meta';
    const statusTag = document.createElement('span');
    statusTag.className = `tag status-${match.status}`;
    statusTag.textContent = STATUS_LABELS[match.status] || match.status;
    meta.appendChild(statusTag);

    if (match.category?.name) {
      const categoryTag = document.createElement('span');
      categoryTag.className = 'tag match-category-tag';
      categoryTag.textContent = match.category.name;
      applyCategoryTagColor(categoryTag, categoryColor, { backgroundAlpha: 0.22 });
      meta.appendChild(categoryTag);
    } else {
      const pendingCategory = document.createElement('span');
      pendingCategory.textContent = 'Categoría por confirmar';
      meta.appendChild(pendingCategory);
    }
    event.appendChild(meta);

    const matchId = normalizeId(match);
    if (matchId) {
      bindCalendarEvent(event, matchId);
    }

    if (categoryColor) {
      applyCategoryColorStyles(event, categoryColor, { backgroundAlpha: 0.18, borderAlpha: 0.32 });
    }

    block.appendChild(event);
  });

  container.appendChild(block);
}

function createCalendarDayBlock(date, events = [], { weekdayLength = 'short' } = {}) {
  const dayBlock = document.createElement('div');
  dayBlock.className = 'calendar-day';

  const header = document.createElement('div');
  header.className = 'calendar-day-header';
  const normalizedLength = weekdayLength === 'long' ? 'long' : 'short';
  header.innerHTML = `<strong>${date.getDate()}</strong><span>${new Intl.DateTimeFormat('es-ES', {
    weekday: normalizedLength,
  }).format(date)}</span>`;
  dayBlock.appendChild(header);

  if (!events.length) {
    const empty = document.createElement('div');
    empty.className = 'calendar-empty';
    empty.textContent = '—';
    dayBlock.appendChild(empty);
    return dayBlock;
  }

  events.forEach((match) => {
    dayBlock.appendChild(createCalendarEvent(match));
  });

  return dayBlock;
}

function normalizeCourtKey(value) {
  if (!value) return '';
  return String(value)
    .trim()
    .toLowerCase()
    .replace(/^pista\s+/i, '')
    .trim();
}

function getCalendarCourtsForDay(events = []) {
  const configuredCourts = Array.isArray(state.club?.courts) ? state.club.courts : [];
  const courtMap = new Map();

  const registerCourt = (rawName) => {
    if (!rawName) return;
    const key = normalizeCourtKey(rawName);
    if (!key) return;
    if (courtMap.has(key)) {
      return;
    }
    const display = formatCourtDisplay(rawName) || rawName;
    courtMap.set(key, {
      key,
      name: rawName,
      label: display,
    });
  };

  configuredCourts.forEach((court) => {
    if (court?.name) {
      registerCourt(court.name);
    }
  });

  events.forEach((event) => {
    if (event?.match?.court || event?.court) {
      registerCourt(event.match?.court || event.court);
    }
  });

  return Array.from(courtMap.values());
}

function createCalendarDaySchedule(date, events = []) {
  const normalizedDate = startOfDay(date instanceof Date ? date : new Date(date));
  let slots = getReservationSlotStartsForDate(normalizedDate);
  const normalizedEvents = events
    .map((match) => {
      if (!match?.scheduledAt) {
        return null;
      }
      const scheduledAt = new Date(match.scheduledAt);
      if (Number.isNaN(scheduledAt.getTime())) {
        return null;
      }
      return {
        match,
        scheduledAt,
        courtKey: normalizeCourtKey(match.court),
      };
    })
    .filter(Boolean);

  const courts = getCalendarCourtsForDay(normalizedEvents);
  const unassignedMatches = normalizedEvents.filter((item) => !item.courtKey).map((item) => item.match);
  const matchesByCourt = normalizedEvents.reduce((map, item) => {
    if (!item.courtKey) {
      return map;
    }
    if (!map.has(item.courtKey)) {
      map.set(item.courtKey, []);
    }
    map.get(item.courtKey).push(item);
    return map;
  }, new Map());
  matchesByCourt.forEach((list) => {
    list.sort((a, b) => a.scheduledAt - b.scheduledAt);
  });
  const scheduledWithCourt = normalizedEvents.filter((item) => item.courtKey);

  if (!slots.length && scheduledWithCourt.length) {
    const earliestMatchTime = scheduledWithCourt.reduce(
      (min, item) => Math.min(min, item.scheduledAt.getTime()),
      scheduledWithCourt[0].scheduledAt.getTime()
    );
    slots = [
      roundDateToInterval(new Date(earliestMatchTime), CALENDAR_TIME_SLOT_MINUTES, 'floor'),
    ];
  }

  if (slots.length && scheduledWithCourt.length) {
    const earliestTime = scheduledWithCourt.reduce(
      (min, item) => Math.min(min, item.scheduledAt.getTime()),
      scheduledWithCourt[0].scheduledAt.getTime()
    );
    const latestTime = scheduledWithCourt.reduce(
      (max, item) => Math.max(max, item.scheduledAt.getTime()),
      scheduledWithCourt[0].scheduledAt.getTime()
    );
    const dayStartTime = normalizedDate.getTime();
    const dayEndTime = addDays(normalizedDate, 1).getTime();

    while (earliestTime < slots[0].getTime() && slots[0].getTime() > dayStartTime) {
      const previousSlot = addMinutes(slots[0], -COURT_RESERVATION_DEFAULT_DURATION);
      slots.unshift(previousSlot);
    }

    let lastSlotEndTime = getReservationSlotEnd(slots[slots.length - 1]).getTime();
    while (latestTime >= lastSlotEndTime && slots[slots.length - 1].getTime() < dayEndTime) {
      const nextSlot = addMinutes(slots[slots.length - 1], COURT_RESERVATION_DEFAULT_DURATION);
      if (nextSlot.getTime() === slots[slots.length - 1].getTime()) {
        break;
      }
      if (nextSlot.getTime() >= dayEndTime) {
        break;
      }
      slots.push(nextSlot);
      lastSlotEndTime = getReservationSlotEnd(slots[slots.length - 1]).getTime();
    }
  }

  if (!courts.length || !slots.length) {
    const fallbackContainer = document.createElement('div');
    fallbackContainer.className = 'calendar-day-list';
    fallbackContainer.appendChild(createCalendarDayBlock(date, events, { weekdayLength: 'long' }));
    if (unassignedMatches.length) {
      const unassignedSection = document.createElement('div');
      unassignedSection.className = 'calendar-day-schedule__unassigned';
      const title = document.createElement('p');
      title.className = 'calendar-day-schedule__unassigned-title';
      title.textContent = 'Partidos sin pista asignada';
      unassignedSection.appendChild(title);
      const list = document.createElement('div');
      list.className = 'calendar-day-schedule__unassigned-list';
      unassignedMatches.forEach((match) => {
        const event = createCalendarEvent(match);
        event.classList.add('calendar-schedule-event');
        list.appendChild(event);
      });
      unassignedSection.appendChild(list);
      fallbackContainer.appendChild(unassignedSection);
    }
    return fallbackContainer;
  }

  const block = document.createElement('div');
  block.className = 'calendar-day calendar-day--schedule';

  const header = document.createElement('div');
  header.className = 'calendar-day-header calendar-day-schedule__header';
  header.innerHTML = `<strong>${normalizedDate.getDate()}</strong><span>${new Intl.DateTimeFormat('es-ES', {
    weekday: 'long',
  }).format(normalizedDate)}</span>`;
  block.appendChild(header);

  const scroller = document.createElement('div');
  scroller.className = 'calendar-day-schedule';
  block.appendChild(scroller);

  const grid = document.createElement('div');
  grid.className = 'calendar-day-schedule__grid';
  grid.style.setProperty('--calendar-schedule-court-count', courts.length);
  scroller.appendChild(grid);

  const headerRow = document.createElement('div');
  headerRow.className = 'calendar-day-schedule__row calendar-day-schedule__row--header';
  headerRow.style.setProperty('--calendar-schedule-court-count', courts.length);
  const timeHeaderCell = document.createElement('div');
  timeHeaderCell.className = 'calendar-day-schedule__cell calendar-day-schedule__cell--time';
  timeHeaderCell.textContent = 'Horario';
  headerRow.appendChild(timeHeaderCell);
  courts.forEach((court, index) => {
    const courtCell = document.createElement('div');
    courtCell.className = 'calendar-day-schedule__cell calendar-day-schedule__cell--court calendar-day-schedule__cell--header';
    courtCell.textContent = court.label;
    if (index === courts.length - 1) {
      courtCell.classList.add('calendar-day-schedule__cell--last-column');
    }
    headerRow.appendChild(courtCell);
  });
  grid.appendChild(headerRow);

  slots.forEach((slotStart, slotIndex) => {
    const slotEnd = getReservationSlotEnd(slotStart);
    const row = document.createElement('div');
    row.className = 'calendar-day-schedule__row calendar-day-schedule__row--body';
    row.style.setProperty('--calendar-schedule-court-count', courts.length);

    const timeCell = document.createElement('div');
    timeCell.className = 'calendar-day-schedule__cell calendar-day-schedule__cell--time';
    timeCell.textContent = formatReservationSlotLabel(slotStart);
    if (slotIndex === slots.length - 1) {
      timeCell.classList.add('calendar-day-schedule__cell--last-row');
    }
    row.appendChild(timeCell);

    courts.forEach((court, courtIndex) => {
      const cell = document.createElement('div');
      cell.className = 'calendar-day-schedule__cell calendar-day-schedule__cell--court';
      if (slotIndex === slots.length - 1) {
        cell.classList.add('calendar-day-schedule__cell--last-row');
      }
      if (courtIndex === courts.length - 1) {
        cell.classList.add('calendar-day-schedule__cell--last-column');
      }
      const matchesForCourt = matchesByCourt.get(court.key) || [];
      const slotMatches = matchesForCourt.filter(
        (item) => item.scheduledAt >= slotStart && item.scheduledAt < slotEnd
      );
      if (!slotMatches.length) {
        const empty = document.createElement('span');
        empty.className = 'calendar-day-schedule__empty';
        empty.textContent = 'Libre';
        cell.appendChild(empty);
      } else {
        slotMatches.forEach((item) => {
          const event = createCalendarEvent(item.match);
          event.classList.add('calendar-schedule-event');
          cell.appendChild(event);
        });
      }
      row.appendChild(cell);
    });

    grid.appendChild(row);
  });

  if (unassignedMatches.length) {
    const unassignedSection = document.createElement('div');
    unassignedSection.className = 'calendar-day-schedule__unassigned';
    const title = document.createElement('p');
    title.className = 'calendar-day-schedule__unassigned-title';
    title.textContent = 'Partidos sin pista asignada';
    unassignedSection.appendChild(title);
    const list = document.createElement('div');
    list.className = 'calendar-day-schedule__unassigned-list';
    unassignedMatches.forEach((match) => {
      const event = createCalendarEvent(match);
      event.classList.add('calendar-schedule-event');
      list.appendChild(event);
    });
    unassignedSection.appendChild(list);
    block.appendChild(unassignedSection);
  }

  return block;
}

function renderCalendarView({
  container,
  labelElement,
  referenceDate,
  matches,
  includeUnscheduled = false,
  viewMode = 'month',
}) {
  if (!container) return;

  const reference =
    referenceDate instanceof Date && !Number.isNaN(referenceDate.getTime())
      ? new Date(referenceDate)
      : new Date();
  const list = Array.isArray(matches) ? matches : [];
  const { grouped, unscheduled } = buildCalendarDataset(list);
  container.innerHTML = '';

  const mode = viewMode === 'day' ? 'day' : 'month';

  if (mode === 'day') {
    const dayReference = startOfDay(reference);
    if (labelElement) {
      labelElement.textContent = formatDayLabel(dayReference);
    }
    const key = dayReference.getTime();
    const events = grouped.get(key) || [];
    container.appendChild(createCalendarDaySchedule(dayReference, events));
  } else {
    const monthStart = startOfMonth(reference);
    if (labelElement) {
      labelElement.textContent = formatMonthLabel(monthStart);
    }
    const dayList = document.createElement('div');
    dayList.className = 'calendar-day-list';
    for (let cursor = new Date(monthStart); cursor < endOfMonth(monthStart); cursor = addDays(cursor, 1)) {
      const key = startOfDay(cursor).getTime();
      const events = grouped.get(key) || [];
      dayList.appendChild(createCalendarDayBlock(cursor, events));
    }
    container.appendChild(dayList);
  }

  if (includeUnscheduled) {
    renderUnscheduledMatches(unscheduled, container);
  }
}

function setCalendarViewButtonState(buttons, activeView) {
  if (!buttons) return;
  buttons.forEach((button) => {
    const view =
      button.dataset.globalCalendarView ||
      button.dataset.calendarView ||
      button.dataset.courtCalendarView ||
      '';
    const isActive = view === activeView;
    button.classList.toggle('is-active', isActive);
    button.setAttribute('aria-pressed', isActive ? 'true' : 'false');
  });
}

function renderCalendar() {
  if (!calendarContainer) return;

  const matches = getCalendarMatchesForDisplay();

  renderCalendarView({
    container: calendarContainer,
    labelElement: calendarLabel,
    referenceDate: state.calendarDate,
    matches,
    includeUnscheduled: true,
    viewMode: 'month',
  });
}

function renderGlobalCalendar() {
  if (!globalCalendarContainer) return;

  const confirmedMatches = getScheduledCalendarMatches();
  const viewMode = state.globalCalendarViewMode === 'day' ? 'day' : 'month';
  renderCalendarView({
    container: globalCalendarContainer,
    labelElement: globalCalendarLabel,
    referenceDate: state.globalCalendarDate,
    matches: confirmedMatches,
    viewMode,
  });
}

function renderAllCalendars() {
  renderCalendar();
  renderGlobalCalendar();
}

function shiftCalendar(step) {
  const reference = new Date(state.calendarDate);
  state.calendarDate = new Date(reference.getFullYear(), reference.getMonth() + step, 1);
  renderCalendar();
}

function shiftGlobalCalendar(step) {
  const reference = new Date(state.globalCalendarDate);
  if (state.globalCalendarViewMode === 'day') {
    const base = startOfDay(reference);
    state.globalCalendarDate = addDays(base, step);
  } else {
    state.globalCalendarDate = new Date(reference.getFullYear(), reference.getMonth() + step, 1);
  }
  renderGlobalCalendar();
}

async function loadPlayerCourtData() {
  if (!state.token) {
    return;
  }

  try {
    const reservations = await request('/courts/reservations');
    state.courtReservations = Array.isArray(reservations) ? reservations : [];
    renderCourtReservations();
  } catch (error) {
    state.courtReservations = [];
    renderCourtReservations();
    showGlobalMessage(error.message, 'error');
  }

  await refreshCourtAvailability('player');
}

async function refreshCourtAvailability(
  scope = 'player',
  { court: courtValue = '', ignoreManualLimit = false } = {}
) {
  const normalizedCourt = typeof courtValue === 'string' ? courtValue.trim() : '';
  const targetDate = scope === 'admin' ? state.courtAdminDate : state.courtAvailabilityDate;
  const formatted = formatDateInput(targetDate) || formatDateInput(new Date());
  if (!formatted) {
    return;
  }

  const normalizedIgnoreManualLimit = Boolean(ignoreManualLimit);

  if (scope === 'admin' && courtAdminStatus) {
    setStatusMessage(courtAdminStatus, 'info', 'Cargando reservas...');
  } else if (scope === 'player' && playerCourtCalendarStatus) {
    setStatusMessage(playerCourtCalendarStatus, 'info', 'Cargando disponibilidad de pistas...');
  }

  try {
    const params = new URLSearchParams({ date: formatted });
    if (normalizedCourt) {
      params.append('court', normalizedCourt);
    }
    if (normalizedIgnoreManualLimit) {
      params.append('ignoreManualLimit', 'true');
    }
    const availability = await request(`/courts/availability?${params.toString()}`);
    const courts = Array.isArray(availability?.courts) ? availability.courts : [];
    if (scope === 'admin') {
      state.courtAdminCourt = normalizedCourt;
      state.courtAdminSchedule = courts;
      state.courtAdminBlocks = Array.isArray(availability?.blocks)
        ? availability.blocks
        : [];
      state.courtAdminIgnoreManualLimit = normalizedIgnoreManualLimit;
      renderCourtAdminSchedule();
      if (courtAdminStatus) {
        setStatusMessage(courtAdminStatus, '', '');
      }
    } else {
      state.courtAvailabilityCourt = normalizedCourt;
      state.courtAvailability = courts;
      state.courtAvailabilityIgnoreManualLimit = normalizedIgnoreManualLimit;
      renderCourtAvailability();
      renderPlayerCourtCalendar();
      if (playerCourtCalendarStatus) {
        setStatusMessage(playerCourtCalendarStatus, '', '');
      }
    }
  } catch (error) {
    if (scope === 'admin') {
      state.courtAdminCourt = normalizedCourt;
      state.courtAdminSchedule = [];
      state.courtAdminBlocks = [];
      state.courtAdminIgnoreManualLimit = normalizedIgnoreManualLimit;
      renderCourtAdminSchedule();
      if (courtAdminStatus) {
        setStatusMessage(courtAdminStatus, 'error', error.message);
      }
    } else {
      state.courtAvailabilityCourt = normalizedCourt;
      state.courtAvailability = [];
      state.courtAvailabilityIgnoreManualLimit = normalizedIgnoreManualLimit;
      renderCourtAvailability();
      renderPlayerCourtCalendar();
      if (playerCourtCalendarStatus) {
        setStatusMessage(playerCourtCalendarStatus, 'error', error.message);
      } else {
        showGlobalMessage(error.message, 'error');
      }
    }
  }
}

async function loadAdminCourtData() {
  if (!hasCourtManagementAccess()) {
    state.courtAdminSchedule = [];
    state.courtAdminBlocks = [];
    renderCourtAdminSchedule();
    return;
  }

  await refreshCourtAvailability('admin');
}

function getMatchCalendarDurationMinutes(match) {
  const duration = Number(match?.durationMinutes);
  if (Number.isFinite(duration) && duration > 0) {
    return Math.round(duration);
  }
  return MATCH_CALENDAR_DEFAULT_DURATION_MINUTES;
}

function formatCalendarDateTimeUTC(date) {
  if (!(date instanceof Date) || Number.isNaN(date.getTime())) {
    return '';
  }
  return date.toISOString().replace(/[-:]|\.\d{3}/g, '');
}

function escapeICSValue(value = '') {
  return String(value)
    .replace(/\\/g, '\\\\')
    .replace(/,/g, '\\,')
    .replace(/;/g, '\\;')
    .replace(/\r?\n/g, '\\n');
}

function buildMatchCalendarSummary(match, playersLabel) {
  if (playersLabel && playersLabel !== 'Jugadores por definir') {
    return `Partido: ${playersLabel}`;
  }
  if (match?.category?.name) {
    return `Partido de ${match.category.name}`;
  }
  return 'Partido programado';
}

function buildMatchCalendarDescription(match, playersLabel, startDate) {
  const descriptionParts = [];
  if (playersLabel) {
    descriptionParts.push(`Jugadores: ${playersLabel}.`);
  }
  const formattedDate = formatDate(startDate);
  if (formattedDate && formattedDate !== 'Por confirmar') {
    descriptionParts.push(`Horario: ${formattedDate}.`);
  }
  if (match?.category?.name) {
    descriptionParts.push(`Categoría: ${match.category.name}.`);
  }
  if (typeof match?.notes === 'string') {
    const trimmedNotes = match.notes.trim();
    if (trimmedNotes) {
      descriptionParts.push(trimmedNotes);
    }
  }
  return descriptionParts.join(' ').trim();
}

function buildMatchCalendarLocation(match) {
  if (!match) {
    return '';
  }
  const locationParts = [];
  if (match.court) {
    locationParts.push(`Pista ${match.court}`);
  }
  const facilityName =
    typeof match.facility?.name === 'string' ? match.facility.name.trim() : '';
  if (facilityName) {
    locationParts.push(facilityName);
  }
  return locationParts.join(' · ');
}

function buildGoogleCalendarUrl({ summary, description, location, startDate, endDate }) {
  const url = new URL('https://calendar.google.com/calendar/render');
  url.searchParams.set('action', 'TEMPLATE');
  url.searchParams.set('text', summary);
  const start = formatCalendarDateTimeUTC(startDate);
  const end = formatCalendarDateTimeUTC(endDate);
  if (!start || !end) {
    return null;
  }
  url.searchParams.set('dates', `${start}/${end}`);
  if (description) {
    url.searchParams.set('details', description);
  }
  if (location) {
    url.searchParams.set('location', location);
  }
  return url.toString();
}

function buildOutlookCalendarUrl({ summary, description, location, startDate, endDate }) {
  const url = new URL('https://outlook.live.com/calendar/0/deeplink/compose');
  url.searchParams.set('path', '/calendar/action/compose');
  url.searchParams.set('rru', 'addevent');
  url.searchParams.set('subject', summary);
  if (description) {
    url.searchParams.set('body', description);
  }
  if (!(startDate instanceof Date) || Number.isNaN(startDate.getTime())) {
    return null;
  }
  if (!(endDate instanceof Date) || Number.isNaN(endDate.getTime())) {
    return null;
  }
  url.searchParams.set('startdt', startDate.toISOString());
  url.searchParams.set('enddt', endDate.toISOString());
  url.searchParams.set('allday', 'false');
  if (location) {
    url.searchParams.set('location', location);
  }
  return url.toString();
}

function buildMatchCalendarFileName(match, startDate, playersLabel) {
  const baseParts = [];
  if (playersLabel) {
    baseParts.push(playersLabel);
  } else if (match?.category?.name) {
    baseParts.push(match.category.name);
  } else {
    baseParts.push('partido');
  }
  if (startDate instanceof Date && !Number.isNaN(startDate.getTime())) {
    const year = startDate.getFullYear();
    const month = String(startDate.getMonth() + 1).padStart(2, '0');
    const day = String(startDate.getDate()).padStart(2, '0');
    const hours = String(startDate.getHours()).padStart(2, '0');
    const minutes = String(startDate.getMinutes()).padStart(2, '0');
    baseParts.push(`${year}${month}${day}-${hours}${minutes}`);
  }

  const combined = baseParts.join(' ');
  const slug = combined
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '')
    .replace(/[^a-zA-Z0-9]+/g, '-')
    .replace(/^-+|-+$/g, '')
    .toLowerCase();

  return `${slug || 'partido'}.ics`;
}

function buildAppleCalendarDataUrl(match, summary, description, location, startDate, endDate, playersLabel) {
  const lines = [
    'BEGIN:VCALENDAR',
    'VERSION:2.0',
    'CALSCALE:GREGORIAN',
    'PRODID:-//PlayCourt//Partidos//ES',
    'BEGIN:VEVENT',
  ];

  const uidSource = match?._id || match?.id || `${startDate.getTime()}-${endDate.getTime()}`;
  const dtStart = formatCalendarDateTimeUTC(startDate);
  const dtEnd = formatCalendarDateTimeUTC(endDate);
  if (!dtStart || !dtEnd) {
    return null;
  }
  lines.push(`UID:match-${uidSource}@playcourt`);
  lines.push(`DTSTAMP:${formatCalendarDateTimeUTC(new Date())}`);
  lines.push(`DTSTART:${dtStart}`);
  lines.push(`DTEND:${dtEnd}`);
  if (summary) {
    lines.push(`SUMMARY:${escapeICSValue(summary)}`);
  }
  if (description) {
    lines.push(`DESCRIPTION:${escapeICSValue(description)}`);
  }
  if (location) {
    lines.push(`LOCATION:${escapeICSValue(location)}`);
  }
  lines.push('END:VEVENT');
  lines.push('END:VCALENDAR');

  const content = `${lines.join('\r\n')}\r\n`;
  const encoded = encodeURIComponent(content);
  const filename = buildMatchCalendarFileName(match, startDate, playersLabel);

  return { url: `data:text/calendar;charset=utf-8,${encoded}`, filename };
}

function createMatchCalendarActions(match, playersLabel) {
  if (!match?.scheduledAt || match?.status !== 'programado') {
    return null;
  }

  const startDate = new Date(match.scheduledAt);
  if (Number.isNaN(startDate.getTime())) {
    return null;
  }

  const durationMinutes = getMatchCalendarDurationMinutes(match);
  const endDate = new Date(startDate.getTime() + durationMinutes * 60 * 1000);

  const summary = buildMatchCalendarSummary(match, playersLabel);
  const description = buildMatchCalendarDescription(match, playersLabel, startDate);
  const location = buildMatchCalendarLocation(match);

  const googleUrl = buildGoogleCalendarUrl({ summary, description, location, startDate, endDate });
  const outlookUrl = buildOutlookCalendarUrl({ summary, description, location, startDate, endDate });
  const appleData = buildAppleCalendarDataUrl(
    match,
    summary,
    description,
    location,
    startDate,
    endDate,
    playersLabel,
  );

  if (!googleUrl && !outlookUrl && !appleData) {
    return null;
  }

  const container = document.createElement('div');
  container.className = 'match-calendar-actions';

  const label = document.createElement('span');
  label.className = 'match-calendar-actions__label';
  label.textContent = 'Añadir a tu calendario:';
  container.appendChild(label);

  if (googleUrl) {
    const googleLink = document.createElement('a');
    googleLink.className = 'ghost match-calendar-actions__link';
    googleLink.href = googleUrl;
    googleLink.target = '_blank';
    googleLink.rel = 'noopener noreferrer';
    googleLink.textContent = 'Google';
    container.appendChild(googleLink);
  }

  if (outlookUrl) {
    const outlookLink = document.createElement('a');
    outlookLink.className = 'ghost match-calendar-actions__link';
    outlookLink.href = outlookUrl;
    outlookLink.target = '_blank';
    outlookLink.rel = 'noopener noreferrer';
    outlookLink.textContent = 'Outlook';
    container.appendChild(outlookLink);
  }

  if (appleData) {
    const appleLink = document.createElement('a');
    appleLink.className = 'ghost match-calendar-actions__link';
    appleLink.href = appleData.url;
    appleLink.download = appleData.filename;
    appleLink.textContent = 'Apple';
    container.appendChild(appleLink);
  }

  return container;
}

function createMatchListItem(match, { isResultManagementList = false } = {}) {
  const item = document.createElement('li');
  const matchId = match?._id || match?.id;
  if (matchId) {
    item.dataset.matchId = matchId;
  }

  const categoryColor = match?.category ? getCategoryColor(match.category) : '';
  const title = document.createElement('strong');
  const players = Array.isArray(match?.players)
    ? match.players.map((player) => player.fullName || 'Jugador').join(' vs ')
    : 'Jugadores por definir';
  title.textContent = players;
  if (categoryColor) {
    const indicator = createCategoryColorIndicator(categoryColor, match.category?.name);
    if (indicator) {
      title.classList.add('with-category-color');
      title.prepend(indicator);
    }
  }
  item.appendChild(title);

  const metaPrimary = document.createElement('div');
  metaPrimary.className = 'meta';
  metaPrimary.appendChild(document.createElement('span')).textContent = formatDate(match?.scheduledAt);
  if (match?.court) {
    metaPrimary.appendChild(document.createElement('span')).textContent = `Pista ${match.court}`;
  }
  if (match?.category?.name) {
    const tag = document.createElement('span');
    tag.className = 'tag match-category-tag';
    tag.textContent = match.category.name;
    applyCategoryTagColor(tag, categoryColor);
    metaPrimary.appendChild(tag);
  }
  item.appendChild(metaPrimary);

  const calendarActions = createMatchCalendarActions(match, players);
  if (calendarActions) {
    item.appendChild(calendarActions);
  }

  if (categoryColor) {
    applyCategoryColorStyles(item, categoryColor, { shadowAlpha: 0.18 });
  }

  if (match?.status === 'pendiente' || match?.status === 'propuesto') {
    const warningMessage = getExpirationWarningMessage(match);
    if (warningMessage) {
      const warning = document.createElement('p');
      warning.className = 'deadline-warning';
      warning.textContent = warningMessage;
      item.appendChild(warning);
    }
  } else if (match?.status === 'caducado') {
    const deadlineDate = getMatchExpirationDate(match);
    const deadlineLabel = formatExpirationDeadline(deadlineDate);
    const warning = document.createElement('p');
    warning.className = 'deadline-warning deadline-warning--expired';
    warning.textContent = deadlineLabel
      ? `El plazo venció el ${deadlineLabel}. El partido caducó sin puntos.`
      : 'El plazo venció. El partido caducó sin puntos.';
    item.appendChild(warning);
  }

  if (match?.status === 'revision' || match?.result?.status === 'en_revision') {
    const pending = document.createElement('div');
    pending.className = 'meta warning';
    pending.textContent = 'Resultado pendiente de validación.';
    item.appendChild(pending);
  }

  if (match?.result?.status === 'confirmado' || match?.status === 'completado') {
    const summary = document.createElement('div');
    summary.className = 'meta result-meta';
    const winner = match?.result?.winner;
    if (winner) {
      const winnerName = getPlayerDisplayName(winner);
      summary.appendChild(document.createElement('span')).textContent = `Ganador: ${winnerName}`;
    }
    const scoreLabel = formatMatchScore(match);
    if (scoreLabel) {
      summary.appendChild(document.createElement('span')).textContent = scoreLabel;
    }
    if (match?.result?.reportedBy) {
      const reporterName = getPlayerDisplayName(match.result.reportedBy);
      summary.appendChild(document.createElement('span')).textContent = `Reportado por ${reporterName}`;
    }
    item.appendChild(summary);

    const scoreboard = createResultScoreboard(match);
    if (!scoreboard && scoreLabel) {
      const fallback = document.createElement('p');
      fallback.className = 'meta';
      fallback.textContent = scoreLabel;
      item.appendChild(fallback);
    }
    if (scoreboard) {
      item.appendChild(scoreboard);
    }
  } else if (match?.result?.status === 'rechazado') {
    const rejected = document.createElement('div');
    rejected.className = 'meta warning';
    rejected.textContent = 'El último resultado fue rechazado.';
    item.appendChild(rejected);
  }

  if (isAdmin()) {
    const actions = document.createElement('div');
    actions.className = 'actions';
    const editButton = document.createElement('button');
    editButton.type = 'button';
    editButton.className = 'secondary';
    if (matchId) {
      editButton.dataset.matchId = matchId;
    }
    if (isResultManagementList) {
      editButton.dataset.action = 'edit-result';
      editButton.textContent =
        match?.status === 'revision' || match?.result?.status === 'en_revision'
          ? 'Revisar resultado'
          : 'Editar resultado';
    } else {
      editButton.dataset.action = 'edit-match';
      editButton.textContent = 'Editar';
    }
    actions.appendChild(editButton);

    if (!isResultManagementList && matchId && match?.status !== 'completado') {
      const deleteButton = document.createElement('button');
      deleteButton.type = 'button';
      deleteButton.className = 'danger';
      deleteButton.dataset.matchId = matchId;
      deleteButton.dataset.action = 'delete-match';
      deleteButton.textContent = 'Eliminar';
      actions.appendChild(deleteButton);

      const resultButton = document.createElement('button');
      resultButton.type = 'button';
      resultButton.className = 'primary';
      resultButton.dataset.matchId = matchId;
      resultButton.dataset.action = 'report-result';
      resultButton.textContent =
        match?.status === 'revision' || match?.result?.status === 'en_revision'
          ? 'Revisar resultado'
          : 'Registrar resultado';
      actions.appendChild(resultButton);
    }
    item.appendChild(actions);
  }

  return item;
}

function renderMatches(
  matches = [],
  container,
  emptyMessage,
  { listKey = 'upcoming' } = {}
) {
  if (!container) return;

  container.innerHTML = '';

  const baseMatches = Array.isArray(matches) ? matches.slice() : [];
  const filteredMatches = filterMatchesByCategory(baseMatches);

  if (!filteredMatches.length) {
    container.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
    return;
  }

  const isResultManagementList =
    container === pendingApprovalsList || container === completedMatchesList;

  const grouped = new Map();

  filteredMatches.forEach((match) => {
    const key = getMatchCategoryKey(match);
    let group = grouped.get(key);
    if (!group) {
      const metadata = getMatchCategoryMetadata(key, match);
      group = {
        key,
        name: metadata.name,
        color: metadata.color,
        matches: [],
      };
      grouped.set(key, group);
    }
    group.matches.push(match);
    if (!group.color) {
      const metadata = getMatchCategoryMetadata(key, match);
      group.color = metadata.color;
      if (!group.name || group.name === 'Categoría') {
        group.name = metadata.name;
      }
    }
  });

  const sortedGroups = Array.from(grouped.values()).sort((a, b) => {
    const nameA = (a.name || '').toLocaleLowerCase('es-ES');
    const nameB = (b.name || '').toLocaleLowerCase('es-ES');
    return nameA.localeCompare(nameB);
  });

  sortedGroups.forEach((group) => {
    const totalMatches = group.matches.length;
    const totalPages = Math.max(1, Math.ceil(totalMatches / MATCHES_PER_PAGE));
    const currentPage = getMatchPaginationPage(listKey, group.key);
    const safePage = Math.min(Math.max(currentPage, 1), totalPages);
    if (safePage !== currentPage) {
      setMatchPaginationPage(listKey, group.key, safePage);
    }
    const startIndex = (safePage - 1) * MATCHES_PER_PAGE;
    const pageMatches = group.matches.slice(startIndex, startIndex + MATCHES_PER_PAGE);

    const groupItem = document.createElement('li');
    groupItem.className = 'match-category-group';
    groupItem.dataset.categoryId = group.key;

    const header = document.createElement('div');
    header.className = 'match-category-group__header';

    const title = document.createElement('div');
    title.className = 'match-category-group__title';
    if (group.color) {
      const indicator = createCategoryColorIndicator(group.color, group.name);
      if (indicator) {
        title.appendChild(indicator);
      }
    }
    const name = document.createElement('strong');
    name.textContent = group.name || UNCATEGORIZED_CATEGORY_LABEL;
    title.appendChild(name);
    header.appendChild(title);

    const count = document.createElement('span');
    count.className = 'match-category-group__count';
    count.textContent = `${totalMatches} ${totalMatches === 1 ? 'partido' : 'partidos'}`;
    header.appendChild(count);

    groupItem.appendChild(header);

    const list = document.createElement('ul');
    list.className = 'match-category-group__matches list';

    pageMatches.forEach((match) => {
      list.appendChild(createMatchListItem(match, { isResultManagementList }));
    });

    groupItem.appendChild(list);

    if (totalPages > 1) {
      const pagination = document.createElement('div');
      pagination.className = 'match-category-group__pagination';

      const info = document.createElement('span');
      info.className = 'match-category-group__pagination-info';
      info.textContent = `Página ${safePage} de ${totalPages}`;
      pagination.appendChild(info);

      const controls = document.createElement('div');
      controls.className = 'match-category-group__pagination-controls';

      const prevButton = document.createElement('button');
      prevButton.type = 'button';
      prevButton.className = 'ghost';
      prevButton.dataset.action = 'paginate';
      prevButton.dataset.list = listKey;
      prevButton.dataset.category = group.key;
      prevButton.dataset.direction = 'previous';
      prevButton.textContent = 'Anterior';
      prevButton.disabled = safePage <= 1;
      controls.appendChild(prevButton);

      const nextButton = document.createElement('button');
      nextButton.type = 'button';
      nextButton.className = 'ghost';
      nextButton.dataset.action = 'paginate';
      nextButton.dataset.list = listKey;
      nextButton.dataset.category = group.key;
      nextButton.dataset.direction = 'next';
      nextButton.textContent = 'Siguiente';
      nextButton.disabled = safePage >= totalPages;
      controls.appendChild(nextButton);

      pagination.appendChild(controls);
      groupItem.appendChild(pagination);
    }

    container.appendChild(groupItem);
  });
}

const MATCH_LIST_CONFIG = {
  upcoming: {
    getMatches: () => state.upcomingMatches,
    container: () => upcomingList,
    emptyMessage: 'No hay partidos programados.',
  },
  pending: {
    getMatches: () => state.pendingApprovalMatches,
    container: () => pendingApprovalsList,
    emptyMessage: 'No hay resultados pendientes por aprobar.',
  },
  completed: {
    getMatches: () => state.completedMatches,
    container: () => completedMatchesList,
    emptyMessage: 'Aún no hay partidos confirmados para mostrar.',
  },
};

function rerenderMatchList(listKey) {
  const config = MATCH_LIST_CONFIG[listKey];
  if (!config) {
    return;
  }
  const container = typeof config.container === 'function' ? config.container() : null;
  if (!container) {
    return;
  }
  const matches = config.getMatches ? config.getMatches() : [];
  renderMatches(Array.isArray(matches) ? matches : [], container, config.emptyMessage, { listKey });
}

function handleMatchPagination(dataset = {}) {
  const listKey = dataset.list || 'upcoming';
  const categoryKey = dataset.category;
  const currentPage = getMatchPaginationPage(listKey, categoryKey);
  let nextPage = currentPage;

  if (dataset.direction === 'previous') {
    nextPage = Math.max(1, currentPage - 1);
  } else if (dataset.direction === 'next') {
    nextPage = currentPage + 1;
  } else if (dataset.page) {
    const parsed = Number(dataset.page);
    if (Number.isFinite(parsed) && parsed > 0) {
      nextPage = Math.floor(parsed);
    }
  }

  setMatchPaginationPage(listKey, categoryKey, nextPage);
  rerenderMatchList(listKey);
}

function getReservationMatch(reservation) {
  if (!reservation) {
    return null;
  }
  if (reservation.tournamentMatch) {
    return reservation.tournamentMatch;
  }
  if (reservation.match) {
    return reservation.match;
  }
  return null;
}

function getReservationContext(reservation) {
  const match = getReservationMatch(reservation);
  if (match && reservation && reservation.tournamentMatch) {
    return 'tournament';
  }
  if (match) {
    return 'league';
  }
  return 'private';
}

function getReservationContextLabel(reservation) {
  const context = getReservationContext(reservation);
  if (context === 'tournament') {
    return 'Partido de torneo';
  }
  if (context === 'league') {
    return 'Partido de liga';
  }
  return 'Partido privado';
}

function getReservationParticipants(reservation) {
  if (!reservation) {
    return [];
  }
  if (Array.isArray(reservation.participants) && reservation.participants.length) {
    return reservation.participants;
  }
  const match = getReservationMatch(reservation);
  if (match && Array.isArray(match.players) && match.players.length) {
    return match.players;
  }
  if (reservation.createdBy) {
    return [reservation.createdBy];
  }
  return [];
}

function formatReservationParticipantsLabel(reservation) {
  const participants = getReservationParticipants(reservation);
  if (!participants.length) {
    return '';
  }
  return participants.map((participant) => getPlayerDisplayName(participant)).join(' · ');
}

function formatMatchPlayersLabel(players = []) {
  if (!Array.isArray(players)) {
    return '';
  }

  const teams = buildMatchTeams(players);
  if (teams.length) {
    const teamLabels = teams
      .map((team) => {
        const memberNames = team
          .map((player) => {
            const name = getPlayerDisplayName(player);
            return typeof name === 'string' ? name.trim() : '';
          })
          .filter(Boolean);
        return memberNames.join(' / ');
      })
      .filter(Boolean);

    if (teamLabels.length) {
      return teamLabels.join(' vs ');
    }
  }

  const playerLabels = players
    .map((player) => {
      const name = getPlayerDisplayName(player);
      return typeof name === 'string' ? name.trim() : '';
    })
    .filter(Boolean);

  return playerLabels.join(' vs ');
}

function formatReservationPlayerOptionLabel(player) {
  if (!player) {
    return 'Jugador';
  }
  const name = typeof player.fullName === 'string' ? player.fullName.trim() : '';
  const email = typeof player.email === 'string' ? player.email.trim() : '';
  if (name && email) {
    return `${name} · ${email}`;
  }
  return name || email || 'Jugador';
}

function getSelectableReservationPlayers() {
  const players = Array.isArray(state.reservationPlayers) ? state.reservationPlayers : [];
  const currentUserId = normalizeId(state.user);
  return players.filter((player) => {
    const playerId = normalizeId(player);
    return playerId && playerId !== currentUserId;
  });
}

async function ensureReservationPlayersLoaded() {
  if (Array.isArray(state.reservationPlayers) && state.reservationPlayers.length) {
    return state.reservationPlayers;
  }

  try {
    const players = await request('/courts/reservations/players');
    state.reservationPlayers = Array.isArray(players) ? players : [];
  } catch (error) {
    state.reservationPlayers = [];
    throw error;
  }

  return state.reservationPlayers;
}

function buildPlayerCourtCalendarEvents(availability = []) {
  const events = [];

  availability.forEach((entry) => {
    if (!entry) {
      return;
    }

    const courtName = entry.court || '';
    const courtLabel = formatCourtDisplay(courtName) || courtName || 'Pista por confirmar';
    const reservations = Array.isArray(entry.reservations) ? entry.reservations : [];
    const blocks = Array.isArray(entry.blocks) ? entry.blocks : [];

    reservations.forEach((reservation) => {
      if (!reservation) {
        return;
      }

      const startsAt = reservation.startsAt ? new Date(reservation.startsAt) : null;
      const endsAt = reservation.endsAt ? new Date(reservation.endsAt) : null;

      if (
        !startsAt ||
        !endsAt ||
        Number.isNaN(startsAt.getTime()) ||
        Number.isNaN(endsAt.getTime())
      ) {
        return;
      }

      const participantsLabel = formatReservationParticipantsLabel(reservation);
      const reservationCourtLabel = formatCourtDisplay(reservation.court) || courtLabel;
      const match = getReservationMatch(reservation);
      if (match) {
        const playersLabel =
          formatMatchPlayersLabel(match.players) || participantsLabel || 'Partido programado';
        const subtitleParts = [getReservationContextLabel(reservation)];
        const isPreReserved = reservation.status === 'pre_reservada';
        if (isPreReserved) {
          subtitleParts.push('Pre-reserva pendiente de confirmación');
        }
        if (reservation.tournamentMatch) {
          if (match.tournament?.name) {
            subtitleParts.push(match.tournament.name);
          }
          if (match.category?.name) {
            subtitleParts.push(match.category.name);
          }
        } else {
          if (match.league?.name) {
            subtitleParts.push(match.league.name);
          }
          if (match.tournament?.name) {
            subtitleParts.push(match.tournament.name);
          }
        }

        const isTournament = Boolean(reservation.tournamentMatch);
        const eventPayload = {
          id: reservation._id || reservation.id,
          type: isTournament ? 'tournament-match' : 'match',
          startsAt,
          endsAt,
          title: playersLabel,
          subtitle: subtitleParts.join(' · '),
          court: reservation.court || courtName,
          courtLabel: reservationCourtLabel,
          status: reservation.status || 'reservada',
          preReserved: isPreReserved,
        };

        if (isTournament) {
          eventPayload.tournamentMatchId = match._id || match.id;
          eventPayload.tournamentId = normalizeId(match.tournament);
          eventPayload.categoryId = normalizeId(match.category);
        } else {
          eventPayload.matchId = match._id || match.id;
        }

        events.push(eventPayload);
        return;
      }

      const contextLabel = getReservationContextLabel(reservation);
      const ownerLabel = reservation.createdBy ? getPlayerDisplayName(reservation.createdBy) : '';
      const subtitleParts = [];
      if (ownerLabel) {
        subtitleParts.push(`Reserva de ${ownerLabel}`);
      }
      if (participantsLabel) {
        subtitleParts.push(`Jugadores: ${participantsLabel}`);
      }

      events.push({
        id: reservation._id || reservation.id,
        type: 'reservation',
        startsAt,
        endsAt,
        title: contextLabel,
        subtitle: subtitleParts.join(' · '),
        notes: reservation.notes || '',
        court: reservation.court || courtName,
        courtLabel: reservationCourtLabel,
        reservationId: reservation._id || reservation.id,
        status: reservation.status || 'reservada',
      });
    });

    blocks.forEach((block) => {
      if (!block) {
        return;
      }

      const startsAt = block.startsAt ? new Date(block.startsAt) : null;
      const endsAt = block.endsAt ? new Date(block.endsAt) : null;

      if (
        !startsAt ||
        !endsAt ||
        Number.isNaN(startsAt.getTime()) ||
        Number.isNaN(endsAt.getTime())
      ) {
        return;
      }

      const appliesToAllCourts = Boolean(block.appliesToAllCourts);
      const blockCourts = Array.isArray(block.courts) ? block.courts : [];
      const baseTitle =
        block.contextType === 'lesson'
          ? block.contextName || 'Clases de tenis'
          : block.contextName
            ? `Bloqueo · ${block.contextName}`
            : 'Bloqueo de pistas';
      const subtitle = appliesToAllCourts
        ? 'Aplica a todas las pistas'
        : blockCourts.length
          ? `Pistas: ${blockCourts.join(', ')}`
          : 'Pistas por confirmar';

      events.push({
        id: block.id,
        type: 'block',
        startsAt,
        endsAt,
        title: baseTitle,
        subtitle,
        notes: block.notes || '',
        courtLabel: appliesToAllCourts
          ? 'Todas las pistas'
          : blockCourts.length
            ? blockCourts.join(', ')
            : courtLabel,
        appliesToAllCourts,
        courts: blockCourts,
        contextType: block.contextType || '',
        contextName: block.contextName || '',
      });
    });
  });

  return events;
}

function renderPlayerCourtCalendar() {
  if (!playerCourtCalendarContainer) {
    return;
  }

  const reference =
    state.courtAvailabilityDate instanceof Date
      ? new Date(state.courtAvailabilityDate)
      : new Date();
  if (Number.isNaN(reference.getTime())) {
    return;
  }

  const normalizedReference = startOfDay(reference);
  state.playerCourtCalendarDate = normalizedReference;

  if (playerCourtCalendarDateInput) {
    playerCourtCalendarDateInput.value = formatDateInput(normalizedReference);
  }
  if (playerCourtCalendarLabel) {
    playerCourtCalendarLabel.textContent = formatDayLabel(normalizedReference);
  }

  const availability = Array.isArray(state.courtAvailability) ? state.courtAvailability : [];

  playerCourtCalendarContainer.innerHTML = '';

  if (!availability.length) {
    const empty = document.createElement('p');
    empty.className = 'empty-state';
    empty.textContent = 'No hay reservas registradas para la fecha seleccionada.';
    playerCourtCalendarContainer.appendChild(empty);
    return;
  }

  const events = buildPlayerCourtCalendarEvents(availability);

  const previousDate = state.courtCalendarDate;
  const previousViewMode = state.courtCalendarViewMode;

  state.courtCalendarDate = normalizedReference;
  state.courtCalendarViewMode = 'day';

  const schedule = createCourtCalendarDaySchedule(normalizedReference, events);
  playerCourtCalendarContainer.appendChild(schedule);

  state.courtCalendarDate = previousDate;
  state.courtCalendarViewMode = previousViewMode;
}

function renderCourtReservations() {
  if (!courtReservationList) {
    return;
  }

  const reservations = Array.isArray(state.courtReservations) ? state.courtReservations.slice() : [];
  reservations.sort((a, b) => new Date(a.startsAt) - new Date(b.startsAt));

  courtReservationList.innerHTML = '';

  if (!reservations.length) {
    if (courtReservationEmpty) {
      courtReservationEmpty.hidden = false;
    }
    return;
  }

  if (courtReservationEmpty) {
    courtReservationEmpty.hidden = true;
  }

  reservations.forEach((reservation) => {
    const item = document.createElement('li');
    item.className = 'court-reservation-item';
    if (reservation.status === 'cancelada') {
      item.classList.add('court-reservation-item--cancelled');
    }
    if (reservation.status === 'pre_reservada') {
      item.classList.add('court-reservation-item--pending');
    }

    const reservationId = reservation._id || reservation.id;
    if (reservationId) {
      item.dataset.reservationId = reservationId;
    }

    const title = document.createElement('strong');
    title.textContent = reservation.court ? `Pista ${reservation.court}` : 'Pista por confirmar';
    item.appendChild(title);

    const scheduleRow = document.createElement('div');
    scheduleRow.className = 'meta';
    scheduleRow.appendChild(document.createElement('span')).textContent = formatDate(reservation.startsAt);
    scheduleRow.appendChild(document.createElement('span')).textContent = formatTimeRangeLabel(
      reservation.startsAt,
      reservation.endsAt
    );
    const contextTag = document.createElement('span');
    contextTag.className = 'tag';
    contextTag.textContent = getReservationContextLabel(reservation);
    scheduleRow.appendChild(contextTag);
    if (reservation.status === 'pre_reservada') {
      const pendingTag = document.createElement('span');
      pendingTag.className = 'tag';
      pendingTag.textContent = 'Pre-reserva';
      scheduleRow.appendChild(pendingTag);
    }
    if (reservation.status === 'cancelada') {
      const cancelledTag = document.createElement('span');
      cancelledTag.className = 'tag danger';
      cancelledTag.textContent = 'Cancelada';
      scheduleRow.appendChild(cancelledTag);
    }
    item.appendChild(scheduleRow);

    const participants = getReservationParticipants(reservation);
    if (participants.length) {
      const participantsRow = document.createElement('div');
      participantsRow.className = 'meta';
      participantsRow.appendChild(document.createElement('span')).textContent = 'Jugadores:';
      participants.forEach((participant) => {
        participantsRow.appendChild(document.createElement('span')).textContent = getPlayerDisplayName(participant);
      });
      item.appendChild(participantsRow);
    }

    if (reservation.notes && getReservationContext(reservation) === 'private') {
      const notesRow = document.createElement('p');
      notesRow.className = 'reservation-notes';
      notesRow.textContent = reservation.notes;
      item.appendChild(notesRow);
    }

    const hasOfficialMatch = Boolean(getReservationMatch(reservation));
    const canCancel = reservation.status === 'reservada' && !hasOfficialMatch;
    if (canCancel && reservationId) {
      const actions = document.createElement('div');
      actions.className = 'reservation-actions';
      const cancelButton = document.createElement('button');
      cancelButton.type = 'button';
      cancelButton.className = 'secondary';
      cancelButton.dataset.action = 'cancel-reservation';
      cancelButton.dataset.reservationId = reservationId;
      cancelButton.textContent = 'Cancelar';
      actions.appendChild(cancelButton);
      item.appendChild(actions);
    }

    courtReservationList.appendChild(item);
  });
}

function renderCourtAvailability() {
  if (courtAvailabilityDateInput) {
    courtAvailabilityDateInput.value = formatDateInput(state.courtAvailabilityDate);
  }
  if (!courtAvailabilityList) {
    return;
  }

  const availability = Array.isArray(state.courtAvailability) ? state.courtAvailability : [];
  courtAvailabilityList.innerHTML = '';

  if (!availability.length) {
    if (courtAvailabilityEmpty) {
      courtAvailabilityEmpty.hidden = false;
    }
    return;
  }

  if (courtAvailabilityEmpty) {
    courtAvailabilityEmpty.hidden = true;
  }

  availability.forEach((entry) => {
    const item = document.createElement('li');
    item.className = 'court-availability-item';
    const title = document.createElement('strong');
    title.textContent = entry.court || 'Pista por definir';
    item.appendChild(title);

    const reservations = Array.isArray(entry.reservations) ? entry.reservations : [];
    const blocks = Array.isArray(entry.blocks) ? entry.blocks : [];

    if (!reservations.length && !blocks.length) {
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = 'Disponible todo el día';
      item.appendChild(meta);
    } else {
      blocks.forEach((block) => {
        const blockRow = document.createElement('div');
        blockRow.className = 'meta court-availability-block';
        const timeLabel = formatTimeRangeLabel(block.startsAt, block.endsAt);
        blockRow.appendChild(document.createElement('span')).textContent = `${timeLabel}`;
        const labelParts = [];
        if (block.contextName) {
          labelParts.push(block.contextName);
        }
        if (block.appliesToAllCourts) {
          labelParts.push('Todas las pistas');
        }
        labelParts.push('Bloqueo oficial');
        blockRow.appendChild(document.createElement('span')).textContent = labelParts.join(' · ');
        if (block.notes) {
          blockRow.appendChild(document.createElement('span')).textContent = block.notes;
        }
        item.appendChild(blockRow);
      });

      reservations.forEach((reservation) => {
        const slot = document.createElement('div');
        slot.className = 'meta court-availability-slot';
        slot.appendChild(document.createElement('span')).textContent = formatTimeRangeLabel(
          reservation.startsAt,
          reservation.endsAt
        );
        const participants = getReservationParticipants(reservation);
        if (participants.length) {
          slot.appendChild(document.createElement('span')).textContent = participants
            .map((participant) => getPlayerDisplayName(participant))
            .join(' · ');
        }
        const contextLabel = getReservationContextLabel(reservation);
        if (contextLabel) {
          const tag = document.createElement('span');
          tag.className = 'tag';
          tag.textContent = contextLabel;
          slot.appendChild(tag);
        }
        if (reservation.status === 'pre_reservada') {
          slot.classList.add('court-availability-slot--pending');
          const pendingTag = document.createElement('span');
          pendingTag.className = 'tag';
          pendingTag.textContent = 'Pre-reserva';
          slot.appendChild(pendingTag);
        }
        if (reservation.createdBy && getReservationContext(reservation) === 'private') {
          slot.appendChild(document.createElement('span')).textContent = `Reserva de ${getPlayerDisplayName(
            reservation.createdBy
          )}`;
        }
        item.appendChild(slot);
      });
    }

    courtAvailabilityList.appendChild(item);
  });
}

function renderCourtAdminSchedule() {
  if (courtAdminDateInput) {
    courtAdminDateInput.value = formatDateInput(state.courtAdminDate);
  }
  if (!courtAdminSchedule) {
    return;
  }

  courtAdminSchedule.innerHTML = '';
  const availability = Array.isArray(state.courtAdminSchedule) ? state.courtAdminSchedule : [];

  if (!availability.length) {
    if (courtAdminEmpty) {
      courtAdminEmpty.hidden = false;
    }
    return;
  }

  if (courtAdminEmpty) {
    courtAdminEmpty.hidden = true;
  }

  availability.forEach((entry) => {
    const block = document.createElement('div');
    block.className = 'court-schedule';
    const heading = document.createElement('h4');
    heading.textContent = entry.court || 'Pista';
    block.appendChild(heading);

    const reservations = Array.isArray(entry.reservations) ? entry.reservations : [];
    const blocks = Array.isArray(entry.blocks) ? entry.blocks : [];
    const timeline = [];

    reservations.forEach((reservation) => {
      timeline.push({
        type: 'reservation',
        startsAt: reservation.startsAt,
        endsAt: reservation.endsAt,
        reservation,
      });
    });

    blocks.forEach((blockEntry) => {
      timeline.push({
        type: 'block',
        startsAt: blockEntry.startsAt,
        endsAt: blockEntry.endsAt,
        block: blockEntry,
      });
    });

    timeline.sort((a, b) => new Date(a.startsAt) - new Date(b.startsAt));

    if (!timeline.length) {
      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.textContent = 'Sin reservas registradas para este día.';
      block.appendChild(meta);
    } else {
      timeline.forEach((timelineEntry) => {
        if (timelineEntry.type === 'block') {
          const { block: blockEntry } = timelineEntry;
          if (!blockEntry) {
            return;
          }

          const row = document.createElement('div');
          row.className = 'court-schedule-row court-schedule-row--block';

          const info = document.createElement('div');
          info.className = 'court-schedule-info';
          info.appendChild(document.createElement('span')).textContent = formatTimeRangeLabel(
            blockEntry.startsAt,
            blockEntry.endsAt
          );

          const details = [];
          if (blockEntry.contextName) {
            details.push(blockEntry.contextName);
          }
          if (blockEntry.appliesToAllCourts) {
            details.push('Todas las pistas');
          } else if (Array.isArray(blockEntry.courts) && blockEntry.courts.length) {
            details.push(`Pistas: ${blockEntry.courts.join(', ')}`);
          }
          details.push('Bloqueo oficial');
          info.appendChild(document.createElement('span')).textContent = details.join(' · ');

          if (blockEntry.notes) {
            info.appendChild(document.createElement('span')).textContent = blockEntry.notes;
          }

          row.appendChild(info);

          if (hasCourtManagementAccess() && blockEntry.id) {
            const actions = document.createElement('div');
            actions.className = 'court-schedule-actions';
            const deleteButton = document.createElement('button');
            deleteButton.type = 'button';
            deleteButton.className = 'ghost danger';
            deleteButton.dataset.action = 'delete-block';
            deleteButton.dataset.blockId = blockEntry.id;
            deleteButton.textContent = 'Eliminar bloqueo';
            actions.appendChild(deleteButton);
            row.appendChild(actions);
          }

          block.appendChild(row);
          return;
        }

        const reservation = timelineEntry.reservation;
        const row = document.createElement('div');
        row.className = 'court-schedule-row';

        const info = document.createElement('div');
        info.className = 'court-schedule-info';
        info.appendChild(document.createElement('span')).textContent = formatTimeRangeLabel(
          reservation.startsAt,
          reservation.endsAt
        );
        const participants = getReservationParticipants(reservation);
        if (participants.length) {
          info.appendChild(document.createElement('span')).textContent = participants
            .map((participant) => getPlayerDisplayName(participant))
            .join(' · ');
        }
        const context = getReservationContext(reservation);
        info.appendChild(document.createElement('span')).textContent = getReservationContextLabel(reservation);
        if (context === 'private' && reservation.createdBy) {
          info.appendChild(document.createElement('span')).textContent = `Reserva de ${getPlayerDisplayName(
            reservation.createdBy
          )}`;
        }
        if (reservation.status === 'pre_reservada') {
          info.appendChild(document.createElement('span')).textContent = 'Pre-reserva pendiente de confirmación';
        }
        if (reservation.notes && context === 'private') {
          info.appendChild(document.createElement('span')).textContent = reservation.notes;
        }
        row.appendChild(info);

        const actions = document.createElement('div');
        actions.className = 'court-schedule-actions';
        const reservationId = reservation._id || reservation.id;
        if (reservationId && reservation.status === 'reservada' && context === 'private') {
          const cancelButton = document.createElement('button');
          cancelButton.type = 'button';
          cancelButton.className = 'ghost';
          cancelButton.dataset.action = 'cancel-reservation';
          cancelButton.dataset.reservationId = reservationId;
          cancelButton.textContent = 'Cancelar';
          actions.appendChild(cancelButton);
        }
        if (actions.childElementCount) {
          row.appendChild(actions);
        }

        block.appendChild(row);
      });
    }

    courtAdminSchedule.appendChild(block);
  });
}

function isAllDaySegment(start, end) {
  if (!start || !end) {
    return false;
  }
  const startDate = new Date(start);
  const endDate = new Date(end);
  if (Number.isNaN(startDate.getTime()) || Number.isNaN(endDate.getTime())) {
    return false;
  }
  const dayStart = startOfDay(startDate).getTime();
  const nextDayStart = addDays(startOfDay(startDate), 1).getTime();
  return startDate.getTime() === dayStart && endDate.getTime() === nextDayStart;
}

function buildCourtCalendarDayMap(events = []) {
  const grouped = new Map();
  events.forEach((event) => {
    if (!event || !event.startsAt || !event.endsAt) {
      return;
    }
    const start = new Date(event.startsAt);
    const end = new Date(event.endsAt);
    if (Number.isNaN(start.getTime()) || Number.isNaN(end.getTime())) {
      return;
    }

    const safeEnd = end > start ? end : new Date(start.getTime() + 30 * 60 * 1000);
    let cursor = startOfDay(start);
    const finalDay = startOfDay(new Date(safeEnd.getTime() - 1));

    while (cursor.getTime() <= finalDay.getTime()) {
      const dayKey = cursor.getTime();
      if (!grouped.has(dayKey)) {
        grouped.set(dayKey, []);
      }

      const dayStart = cursor;
      const dayEnd = addDays(cursor, 1);
      const displayStartsAt = start > dayStart ? start : dayStart;
      const displayEndsAt = safeEnd < dayEnd ? safeEnd : dayEnd;
      const spansMultipleDays = finalDay.getTime() !== startOfDay(start).getTime();

      grouped.get(dayKey).push({
        ...event,
        displayStartsAt,
        displayEndsAt,
        spansMultipleDays,
      });

      cursor = addDays(cursor, 1);
    }
  });

  grouped.forEach((list) => {
    list.sort((a, b) => {
      const first = new Date(a.displayStartsAt || a.startsAt);
      const second = new Date(b.displayStartsAt || b.startsAt);
      return first - second;
    });
  });

  return grouped;
}

function createCourtCalendarEvent(event) {
  const container = document.createElement('div');
  const type = event.type || 'reservation';
  container.className = `calendar-event calendar-event--${type}`;
  if (event.status === 'pre_reservada' || event.preReserved) {
    container.classList.add('calendar-event--pre-reservation');
  }
  if (event.spansMultipleDays) {
    container.classList.add('calendar-event--spanning');
  }

  const title = document.createElement('strong');
  title.textContent = event.title || 'Reserva de pista';
  container.appendChild(title);

  const displayStart = event.displayStartsAt || event.startsAt;
  const displayEnd = event.displayEndsAt || event.endsAt;
  const timeLabel = isAllDaySegment(displayStart, displayEnd)
    ? 'Todo el día'
    : formatTimeRangeLabel(displayStart, displayEnd);

  const meta = document.createElement('div');
  meta.className = 'meta';
  const courtLabel = event.courtLabel || event.court || 'Pista por confirmar';
  meta.textContent = `${timeLabel} · ${courtLabel}`;
  container.appendChild(meta);

  if (event.subtitle) {
    const subtitle = document.createElement('div');
    subtitle.className = 'meta calendar-event-subtitle';
    subtitle.textContent = event.subtitle;
    container.appendChild(subtitle);
  }

  if (event.notes) {
    const notes = document.createElement('div');
    notes.className = 'meta calendar-event-notes';
    notes.textContent = event.notes;
    container.appendChild(notes);
  }

  if (type === 'match' && event.matchId) {
    bindCalendarEvent(container, event.matchId);
  } else if (type === 'tournament-match' && event.tournamentMatchId) {
    container.dataset.tournamentMatchId = event.tournamentMatchId;
    if (event.tournamentId) {
      container.dataset.tournamentId = event.tournamentId;
    }
    if (event.categoryId) {
      container.dataset.categoryId = event.categoryId;
    }
    container.classList.add('calendar-event--actionable');
    container.tabIndex = 0;
    container.setAttribute('role', 'button');
    const openTournamentMatch = () => {
      openTournamentMatchScheduleModal(event.tournamentMatchId, {
        tournamentId: event.tournamentId,
        categoryId: event.categoryId,
      });
    };
    container.addEventListener('click', openTournamentMatch);
    container.addEventListener('keydown', (keyboardEvent) => {
      if (keyboardEvent.key === 'Enter' || keyboardEvent.key === ' ') {
        keyboardEvent.preventDefault();
        openTournamentMatch();
      }
    });
  } else if (type === 'reservation') {
    container.dataset.calendarAction = 'open-reservation';
    container.dataset.startsAt = event.startsAt ? new Date(event.startsAt).toISOString() : '';
    container.dataset.court = event.court || '';
    container.classList.add('calendar-event--actionable');
    container.tabIndex = 0;
    container.setAttribute('role', 'button');
    container.addEventListener('click', () => {
      openReservationEditorFromCalendar(event);
    });
    container.addEventListener('keydown', (keyboardEvent) => {
      if (keyboardEvent.key === 'Enter' || keyboardEvent.key === ' ') {
        keyboardEvent.preventDefault();
        openReservationEditorFromCalendar(event);
      }
    });
  }

  return container;
}

function getCourtCalendarEventBounds(event) {
  if (!event) {
    return { start: null, end: null };
  }

  const start = parseDateSafe(event.displayStartsAt || event.startsAt);
  if (!start) {
    return { start: null, end: null };
  }

  const rawEnd = parseDateSafe(event.displayEndsAt || event.endsAt);
  const end = rawEnd && rawEnd > start ? rawEnd : addMinutes(start, COURT_RESERVATION_DEFAULT_DURATION);

  return { start, end };
}

function getCourtCalendarCourts(events = []) {
  const seen = new Set();
  const courts = [];

  const register = (rawName) => {
    if (!rawName) {
      return;
    }
    const name = String(rawName).trim();
    if (!name) {
      return;
    }
    const key = normalizeCourtKey(name);
    if (!key || seen.has(key)) {
      return;
    }
    seen.add(key);
    courts.push({
      key,
      name,
      label: formatCourtDisplay(name) || name,
    });
  };

  getClubCourtNames().forEach(register);

  events.forEach((event) => {
    if (!event) {
      return;
    }
    if (event.type === 'block') {
      const blockCourts = Array.isArray(event.courts) ? event.courts : [];
      blockCourts.forEach(register);
    } else if (event.court) {
      register(event.court);
    }
  });

  return courts;
}

function isCourtCalendarEventForCourt(event, courtName) {
  if (!event || !courtName) {
    return false;
  }

  if (event.type === 'block') {
    if (event.appliesToAllCourts) {
      return true;
    }
    const courts = Array.isArray(event.courts) ? event.courts : [];
    const normalizedCourt = normalizeCourtKey(courtName);
    return courts.some((name) => normalizeCourtKey(name) === normalizedCourt);
  }

  if (!event.court) {
    return false;
  }

  return normalizeCourtKey(event.court) === normalizeCourtKey(courtName);
}

function doesCourtCalendarEventOverlapSlot(entry, slotStart, slotEnd) {
  if (!entry || !entry.start || !entry.end) {
    return false;
  }

  return entry.start < slotEnd && entry.end > slotStart;
}

function createCourtCalendarDayBlock(date, events = [], { interactive = true } = {}) {
  const day = startOfDay(date instanceof Date ? date : new Date(date));
  const container = document.createElement('div');
  container.className = 'calendar-day';

  const formattedDate = formatDateInput(day);
  if (formattedDate) {
    container.dataset.calendarDate = formattedDate;
    const selectedValue = formatDateInput(state.courtCalendarDate);
    if (selectedValue && selectedValue === formattedDate) {
      container.classList.add('calendar-day--selected');
      container.setAttribute('aria-current', 'date');
    }
    const todayValue = formatDateInput(new Date());
    if (todayValue && todayValue === formattedDate) {
      container.classList.add('calendar-day--today');
    }
  }

  if (interactive) {
    container.classList.add('calendar-day--actionable');
    container.tabIndex = 0;
    container.setAttribute('role', 'button');
    container.setAttribute('aria-label', `Agenda del ${formatDateOnly(day)}`);
  }

  const header = document.createElement('div');
  header.className = 'calendar-day-header';
  header.innerHTML = `<strong>${day.getDate()}</strong><span>${new Intl.DateTimeFormat('es-ES', {
    weekday: 'short',
  }).format(day)}</span>`;
  container.appendChild(header);

  if (!events.length) {
    const empty = document.createElement('div');
    empty.className = 'calendar-empty';
    empty.textContent = '—';
    container.appendChild(empty);
    return container;
  }

  events.forEach((event) => {
    container.appendChild(createCourtCalendarEvent(event));
  });

  return container;
}

function createCourtCalendarDaySchedule(date, events = []) {
  const dayReference = startOfDay(date instanceof Date ? date : new Date(date));
  const formattedDate = formatDateInput(dayReference);

  const normalizedEvents = events
    .map((event) => {
      const bounds = getCourtCalendarEventBounds(event);
      if (!bounds.start || !bounds.end) {
        return null;
      }
      return { event, start: bounds.start, end: bounds.end };
    })
    .filter(Boolean);

  const courts = getCourtCalendarCourts(events);

  if (!courts.length) {
    return createCourtCalendarDayBlock(dayReference, events, { interactive: false });
  }

  const container = document.createElement('div');
  container.className = 'calendar-day calendar-day--schedule';
  if (formattedDate) {
    container.dataset.calendarDate = formattedDate;
    const selectedValue = formatDateInput(state.courtCalendarDate);
    if (selectedValue && selectedValue === formattedDate) {
      container.classList.add('calendar-day--selected');
      container.setAttribute('aria-current', 'date');
    }
    const todayValue = formatDateInput(new Date());
    if (todayValue && todayValue === formattedDate) {
      container.classList.add('calendar-day--today');
    }
  }
  container.setAttribute('aria-label', `Agenda detallada del ${formatDateOnly(dayReference)}`);

  const header = document.createElement('div');
  header.className = 'calendar-day-header calendar-day-schedule__header';
  const dayLabel = formatDayLabel(dayReference);
  const [weekdayLabel, ...restParts] = dayLabel.split(', ');
  const headerTitle = document.createElement('strong');
  headerTitle.textContent = weekdayLabel || dayLabel;
  header.appendChild(headerTitle);
  const restLabel = restParts.join(', ');
  if (restLabel) {
    const headerDetail = document.createElement('span');
    headerDetail.textContent = restLabel;
    header.appendChild(headerDetail);
  }
  container.appendChild(header);

  const scroller = document.createElement('div');
  scroller.className = 'calendar-day-schedule';
  container.appendChild(scroller);

  const grid = document.createElement('div');
  grid.className = 'calendar-day-schedule__grid';
  grid.style.setProperty('--calendar-schedule-court-count', courts.length);
  scroller.appendChild(grid);

  const headerRow = document.createElement('div');
  headerRow.className = 'calendar-day-schedule__row calendar-day-schedule__row--header';
  headerRow.style.setProperty('--calendar-schedule-court-count', courts.length);
  const timeHeaderCell = document.createElement('div');
  timeHeaderCell.className = 'calendar-day-schedule__cell calendar-day-schedule__cell--time';
  timeHeaderCell.textContent = 'Horario';
  headerRow.appendChild(timeHeaderCell);
  courts.forEach((court, index) => {
    const courtCell = document.createElement('div');
    courtCell.className =
      'calendar-day-schedule__cell calendar-day-schedule__cell--court calendar-day-schedule__cell--header';
    courtCell.textContent = court.label;
    if (index === courts.length - 1) {
      courtCell.classList.add('calendar-day-schedule__cell--last-column');
    }
    headerRow.appendChild(courtCell);
  });
  grid.appendChild(headerRow);

  const slots = getReservationSlotStartsForDate(dayReference);

  slots.forEach((slotStart, slotIndex) => {
    const slotStartDate = new Date(slotStart);
    const slotEndDate = getReservationSlotEnd(slotStartDate);

    const row = document.createElement('div');
    row.className = 'calendar-day-schedule__row calendar-day-schedule__row--body';
    row.style.setProperty('--calendar-schedule-court-count', courts.length);

    const timeCell = document.createElement('div');
    timeCell.className = 'calendar-day-schedule__cell calendar-day-schedule__cell--time';
    timeCell.textContent = formatReservationSlotLabel(slotStartDate);
    if (slotIndex === slots.length - 1) {
      timeCell.classList.add('calendar-day-schedule__cell--last-row');
    }
    row.appendChild(timeCell);

    courts.forEach((court, courtIndex) => {
      const cell = document.createElement('div');
      cell.className = 'calendar-day-schedule__cell calendar-day-schedule__cell--court';
      if (slotIndex === slots.length - 1) {
        cell.classList.add('calendar-day-schedule__cell--last-row');
      }
      if (courtIndex === courts.length - 1) {
        cell.classList.add('calendar-day-schedule__cell--last-column');
      }

      const slotEvents = normalizedEvents.filter(
        (entry) =>
          isCourtCalendarEventForCourt(entry.event, court.name) &&
          doesCourtCalendarEventOverlapSlot(entry, slotStartDate, slotEndDate)
      );

      if (!slotEvents.length) {
        const button = document.createElement('button');
        button.type = 'button';
        button.className = 'calendar-day-schedule__slot-button';
        button.textContent = 'Reservar';
        button.setAttribute('aria-label', `Reservar ${court.label} · ${formatReservationSlotLabel(slotStartDate)}`);
        button.addEventListener('click', (event) => {
          event.stopPropagation();
          openReservationEditorFromCalendar({
            startsAt: slotStartDate,
            endsAt: slotEndDate,
            court: court.name,
          });
        });
        cell.appendChild(button);
      } else {
        cell.classList.add('calendar-day-schedule__cell--busy');
        slotEvents
          .sort((a, b) => a.start - b.start)
          .forEach((entry) => {
            const eventElement = createCourtCalendarEvent(entry.event);
            eventElement.classList.add('calendar-schedule-event');
            cell.appendChild(eventElement);
          });
      }

      row.appendChild(cell);
    });

    grid.appendChild(row);
  });

  const unassignedSeen = new Set();
  const unassignedEvents = events.filter((event) => {
    if (!event) {
      return false;
    }
    if (event.type === 'block') {
      if (event.appliesToAllCourts) {
        return false;
      }
      const courtsList = Array.isArray(event.courts) ? event.courts.filter(Boolean) : [];
      if (courtsList.length) {
        return false;
      }
    } else if (event.court) {
      return false;
    }

    const key = event.id || `${event.type}:${event.startsAt}`;
    if (unassignedSeen.has(key)) {
      return false;
    }
    unassignedSeen.add(key);
    return true;
  });

  if (unassignedEvents.length) {
    const unassignedSection = document.createElement('div');
    unassignedSection.className = 'calendar-day-schedule__unassigned';
    const title = document.createElement('p');
    title.className = 'calendar-day-schedule__unassigned-title';
    title.textContent = 'Eventos sin pista asignada';
    unassignedSection.appendChild(title);
    const list = document.createElement('div');
    list.className = 'calendar-day-schedule__unassigned-list';
    unassignedEvents.forEach((event) => {
      const eventElement = createCourtCalendarEvent(event);
      eventElement.classList.add('calendar-schedule-event');
      list.appendChild(eventElement);
    });
    unassignedSection.appendChild(list);
    container.appendChild(unassignedSection);
  }

  return container;
}

function renderCourtCalendar() {
  if (!courtCalendarContainer) {
    return;
  }

  const reference = state.courtCalendarDate instanceof Date ? new Date(state.courtCalendarDate) : new Date();
  const normalizedReference = startOfDay(reference);
  state.courtCalendarDate = normalizedReference;

  const viewMode = state.courtCalendarViewMode === 'day' ? 'day' : 'month';
  setCalendarViewButtonState(courtCalendarViewButtons, viewMode);

  const events = Array.isArray(state.courtCalendarEvents) ? state.courtCalendarEvents : [];
  const grouped = buildCourtCalendarDayMap(events);

  courtCalendarContainer.innerHTML = '';

  if (viewMode === 'day') {
    if (courtCalendarLabel) {
      courtCalendarLabel.textContent = formatDayLabel(normalizedReference);
    }
    const key = normalizedReference.getTime();
    const dayEvents = grouped.get(key) || [];
    courtCalendarContainer.appendChild(createCourtCalendarDaySchedule(normalizedReference, dayEvents));
    return;
  }

  const monthStart = startOfMonth(normalizedReference);
  if (courtCalendarLabel) {
    courtCalendarLabel.textContent = formatMonthLabel(monthStart);
  }

  const monthEnd = endOfMonth(monthStart);
  const dayList = document.createElement('div');
  dayList.className = 'calendar-day-list';

  for (let cursor = new Date(monthStart); cursor < monthEnd; cursor = addDays(cursor, 1)) {
    const dayKey = startOfDay(cursor).getTime();
    const dayEvents = grouped.get(dayKey) || [];
    dayList.appendChild(createCourtCalendarDayBlock(cursor, dayEvents));
  }

  courtCalendarContainer.appendChild(dayList);
}

function setCourtCalendarViewMode(view) {
  const normalized = view === 'day' ? 'day' : 'month';
  state.courtCalendarViewMode = normalized;
  setCalendarViewButtonState(courtCalendarViewButtons, normalized);
  renderCourtCalendar();
}

function resetCourtCalendarView() {
  if (courtCalendarContainer) {
    courtCalendarContainer.innerHTML =
      '<p class="empty-state">Selecciona un periodo para ver las reservas y bloqueos de pistas.</p>';
  }
  if (courtCalendarLabel) {
    const reference = state.courtCalendarDate instanceof Date ? state.courtCalendarDate : new Date();
    const normalizedReference = startOfDay(reference);
    courtCalendarLabel.textContent =
      state.courtCalendarViewMode === 'day'
        ? formatDayLabel(normalizedReference)
        : formatMonthLabel(startOfMonth(normalizedReference));
  }
  setCalendarViewButtonState(courtCalendarViewButtons, state.courtCalendarViewMode === 'day' ? 'day' : 'month');
  if (courtBlocksEmpty) {
    courtBlocksEmpty.hidden = false;
  }
}

function renderCourtBlocksList() {
  if (!courtBlocksList) {
    return;
  }

  const blocks = Array.isArray(state.courtBlocks) ? state.courtBlocks.slice() : [];
  blocks.sort((a, b) => new Date(a.startsAt) - new Date(b.startsAt));

  courtBlocksList.innerHTML = '';

  if (!blocks.length) {
    if (courtBlocksEmpty) {
      courtBlocksEmpty.hidden = false;
      courtBlocksEmpty.textContent = 'No hay bloqueos registrados para el mes seleccionado.';
      courtBlocksList.appendChild(courtBlocksEmpty);
    } else {
      const emptyItem = document.createElement('li');
      emptyItem.className = 'empty-state';
      emptyItem.textContent = 'No hay bloqueos registrados para el mes seleccionado.';
      courtBlocksList.appendChild(emptyItem);
    }
    return;
  }

  if (courtBlocksEmpty) {
    courtBlocksEmpty.hidden = true;
  }

  blocks.forEach((block) => {
    const item = document.createElement('li');
    item.className = 'court-block-item';

    const header = document.createElement('div');
    header.className = 'court-block-item__header';

    const title = document.createElement('strong');
    title.textContent = block.contextName || 'Bloqueo programado';
    header.appendChild(title);

    const badge = document.createElement('span');
    badge.className = 'tag tag--block';
    let badgeLabel = 'Bloqueo';
    switch (block.contextType) {
      case 'league':
        badgeLabel = 'Liga';
        break;
      case 'tournament':
        badgeLabel = 'Torneo';
        break;
      case 'lesson':
        badgeLabel = 'Clases';
        break;
      default:
        badgeLabel = 'Bloqueo';
    }
    badge.textContent = badgeLabel;
    header.appendChild(badge);

    item.appendChild(header);

    const courts = Array.isArray(block.courts) ? block.courts : [];
    const rangeLabel = formatDateRangeLabel(block.startsAt, block.endsAt);
    const schedule = document.createElement('div');
    schedule.className = 'meta court-block-item__schedule';
    schedule.textContent = `${rangeLabel} · ${formatTimeRangeLabel(block.startsAt, block.endsAt)}`;
    item.appendChild(schedule);

    const courtLabel = document.createElement('div');
    courtLabel.className = 'meta court-block-item__courts';
    courtLabel.textContent = block.appliesToAllCourts
      ? 'Todas las pistas del club'
      : `Pistas: ${courts.join(', ')}`;
    item.appendChild(courtLabel);

    if (block.notes) {
      const notes = document.createElement('div');
      notes.className = 'meta court-block-item__notes';
      notes.textContent = block.notes;
      item.appendChild(notes);
    }

    if (hasCourtManagementAccess() && block.id) {
      const actions = document.createElement('div');
      actions.className = 'court-block-item__actions';
      const deleteButton = document.createElement('button');
      deleteButton.type = 'button';
      deleteButton.className = 'ghost danger';
      deleteButton.dataset.action = 'delete-block';
      deleteButton.dataset.blockId = block.id;
      deleteButton.textContent = 'Eliminar bloqueo';
      actions.appendChild(deleteButton);
      item.appendChild(actions);
    }

    courtBlocksList.appendChild(item);
  });
}

async function loadCourtCalendarData() {
  if (!hasCourtManagementAccess()) {
    state.courtCalendarEvents = [];
    state.courtBlocks = [];
    resetCourtCalendarView();
    renderCourtBlocksList();
    return;
  }

  const reference = state.courtCalendarDate instanceof Date ? new Date(state.courtCalendarDate) : new Date();
  const normalizedReference = startOfDay(reference);
  const monthStart = startOfMonth(normalizedReference);
  const monthEnd = endOfMonth(monthStart);
  state.courtCalendarDate = normalizedReference;

  if (courtCalendarStatus) {
    setStatusMessage(courtCalendarStatus, 'info', 'Cargando calendario de pistas...');
  }

  const startParam = encodeURIComponent(monthStart.toISOString());
  const endParam = encodeURIComponent(monthEnd.toISOString());

  try {
    const [reservationsResponse, blocksResponse] = await Promise.all([
      request(`/courts/reservations?start=${startParam}&end=${endParam}`),
      request(`/courts/blocks?start=${startParam}&end=${endParam}`),
    ]);

    const reservations = Array.isArray(reservationsResponse) ? reservationsResponse : [];
    const blocks = Array.isArray(blocksResponse) ? blocksResponse : [];

    const events = [];

    reservations.forEach((reservation) => {
      const startsAt = reservation.startsAt ? new Date(reservation.startsAt) : null;
      const endsAt = reservation.endsAt ? new Date(reservation.endsAt) : null;
      if (!startsAt || !endsAt || Number.isNaN(startsAt.getTime()) || Number.isNaN(endsAt.getTime())) {
        return;
      }

      const participantsLabel = formatReservationParticipantsLabel(reservation);
      const courtLabel = reservation.court || 'Pista por definir';
      const match = getReservationMatch(reservation);

      if (match) {
        const players = Array.isArray(match.players)
          ? match.players.map((player) => getPlayerDisplayName(player)).join(' vs ')
          : participantsLabel || 'Partido programado';
        const subtitleParts = [getReservationContextLabel(reservation)];
        const isPreReserved = reservation.status === 'pre_reservada';
        if (isPreReserved) {
          subtitleParts.push('Pre-reserva pendiente de confirmación');
        }
        if (reservation.tournamentMatch) {
          if (match.tournament?.name) {
            subtitleParts.push(match.tournament.name);
          }
          if (match.category?.name) {
            subtitleParts.push(match.category.name);
          }
        } else {
          if (match.league?.name) {
            subtitleParts.push(match.league.name);
          }
          if (match.tournament?.name) {
            subtitleParts.push(match.tournament.name);
          }
        }

        const isTournament = Boolean(reservation.tournamentMatch);
        const eventPayload = {
          id: reservation._id || reservation.id,
          type: isTournament ? 'tournament-match' : 'match',
          startsAt,
          endsAt,
          title: players,
          subtitle: subtitleParts.join(' · '),
          court: reservation.court,
          courtLabel,
          status: reservation.status || 'reservada',
          preReserved: isPreReserved,
        };

        if (isTournament) {
          eventPayload.tournamentMatchId = match._id || match.id;
          eventPayload.tournamentId = normalizeId(match.tournament);
          eventPayload.categoryId = normalizeId(match.category);
        } else {
          eventPayload.matchId = match._id || match.id;
        }

        events.push(eventPayload);
        return;
      }

      const contextLabel = getReservationContextLabel(reservation);
      const ownerLabel = reservation.createdBy ? getPlayerDisplayName(reservation.createdBy) : '';
      const subtitleParts = [];
      if (ownerLabel) {
        subtitleParts.push(`Reserva de ${ownerLabel}`);
      }
      if (participantsLabel) {
        subtitleParts.push(`Jugadores: ${participantsLabel}`);
      }

      events.push({
        id: reservation._id || reservation.id,
        type: 'reservation',
        startsAt,
        endsAt,
        title: contextLabel,
        subtitle: subtitleParts.join(' · '),
        notes: reservation.notes || '',
        court: reservation.court,
        courtLabel,
        reservationId: reservation._id || reservation.id,
        status: reservation.status || 'reservada',
      });
    });

    const normalizedBlocks = blocks.map((block) => {
      const startsAt = block.startsAt ? new Date(block.startsAt) : null;
      const endsAt = block.endsAt ? new Date(block.endsAt) : null;
      return {
        ...block,
        startsAt,
        endsAt,
      };
    });

    normalizedBlocks.forEach((block) => {
      if (!block.startsAt || !block.endsAt || Number.isNaN(block.startsAt.getTime()) || Number.isNaN(block.endsAt.getTime())) {
        return;
      }
      const courts = Array.isArray(block.courts) ? block.courts : [];
      const appliesToAllCourts = Boolean(block.appliesToAllCourts);
      const contextType = block.contextType || '';
      const baseTitle =
        contextType === 'lesson'
          ? block.contextName || 'Clases de tenis'
          : block.contextName
            ? `Bloqueo · ${block.contextName}`
            : 'Bloqueo de pistas';
      const subtitle = appliesToAllCourts
        ? 'Aplica a todas las pistas'
        : courts.length
          ? `Pistas: ${courts.join(', ')}`
          : 'Pistas por confirmar';

      events.push({
        id: block.id,
        type: 'block',
        startsAt: block.startsAt,
        endsAt: block.endsAt,
        title: baseTitle,
        subtitle,
        notes: block.notes || '',
        courtLabel: appliesToAllCourts
          ? 'Todas las pistas'
          : courts.length
            ? courts.join(', ')
            : 'Pistas por confirmar',
        appliesToAllCourts,
        courts,
        contextType,
        contextName: block.contextName || '',
      });
    });

    state.courtCalendarEvents = events;
    state.courtBlocks = normalizedBlocks;

    renderCourtCalendar();
    renderCourtBlocksList();
    ensureCourtBlockRangeDefaults(monthStart);
    if (courtCalendarStatus) {
      setStatusMessage(courtCalendarStatus, '', '');
    }
  } catch (error) {
    state.courtCalendarEvents = [];
    state.courtBlocks = [];
    resetCourtCalendarView();
    renderCourtBlocksList();
    if (courtCalendarStatus) {
      setStatusMessage(courtCalendarStatus, 'error', error.message);
    }
  }
}

async function deleteCourtBlock(blockId, { button } = {}) {
  if (!blockId) {
    return false;
  }

  const confirmed = window.confirm('¿Seguro que deseas eliminar este bloqueo de pistas?');
  if (!confirmed) {
    return false;
  }

  if (button) {
    button.disabled = true;
  }

  try {
    await request(`/courts/blocks/${blockId}`, { method: 'DELETE' });
    showGlobalMessage('Bloqueo eliminado correctamente.', 'success');
    await Promise.all([loadAdminCourtData(), loadCourtCalendarData()]);
    return true;
  } catch (error) {
    showGlobalMessage(error.message, 'error');
    return false;
  } finally {
    if (button) {
      button.disabled = false;
    }
  }
}

async function handleCourtCalendarDaySelection(dateValue) {
  if (!dateValue) {
    return;
  }

  const nextDate = new Date(`${dateValue}T00:00:00`);
  if (Number.isNaN(nextDate.getTime())) {
    return;
  }

  state.courtAdminDate = nextDate;
  if (courtAdminDateInput) {
    courtAdminDateInput.value = formatDateInput(nextDate);
  }
  state.courtCalendarDate = startOfDay(nextDate);
  renderCourtCalendar();
  showSection('section-court-admin');
  ensureCourtBlockRangeDefaults(nextDate);
  await refreshCourtAvailability('admin');
}

async function openReservationEditorFromCalendar(eventData = {}) {
  if (!state.token) {
    showGlobalMessage('Debes iniciar sesión para reservar una pista.', 'error');
    return;
  }

  let defaultStart = eventData.startsAt ? new Date(eventData.startsAt) : null;
  if (!defaultStart || Number.isNaN(defaultStart.getTime())) {
    defaultStart = roundDateUpToInterval(new Date(), CALENDAR_TIME_SLOT_MINUTES);
  }
  const defaultTimeValue = formatTimeInputValue(defaultStart);
  const defaultDateValue = formatDateInput(defaultStart);
  const defaultCourt = typeof eventData.court === 'string' ? eventData.court : '';

  try {
    await ensureReservationPlayersLoaded();
  } catch (error) {
    showGlobalMessage(error.message, 'error');
    return;
  }

  const selectablePlayers = getSelectableReservationPlayers();
  const courtNames = getClubCourtNames();
  const defaultGameType = eventData.gameType === 'dobles' ? 'dobles' : 'individual';

  const form = document.createElement('form');
  form.className = 'form reservation-modal-form';

  const scheduleGrid = document.createElement('div');
  scheduleGrid.className = 'form-grid';

  const dateField = document.createElement('label');
  dateField.className = 'inline-field';
  dateField.appendChild(document.createTextNode('Fecha'));
  const dateInput = document.createElement('input');
  dateInput.type = 'date';
  dateInput.required = true;
  if (defaultDateValue) {
    dateInput.value = defaultDateValue;
  }
  dateField.appendChild(dateInput);
  scheduleGrid.appendChild(dateField);

  const timeField = document.createElement('label');
  timeField.className = 'inline-field';
  timeField.appendChild(document.createTextNode('Hora'));
  const timeSelect = document.createElement('select');
  timeSelect.required = true;
  timeField.appendChild(timeSelect);
  scheduleGrid.appendChild(timeField);

  const courtField = document.createElement('label');
  courtField.className = 'inline-field';
  courtField.appendChild(document.createTextNode('Pista'));
  const courtSelect = document.createElement('select');
  courtSelect.required = true;
  courtField.appendChild(courtSelect);
  scheduleGrid.appendChild(courtField);

  form.appendChild(scheduleGrid);

  const gameTypeFieldset = document.createElement('fieldset');
  gameTypeFieldset.className = 'inline-field';
  const gameTypeLegend = document.createElement('legend');
  gameTypeLegend.textContent = 'Formato';
  gameTypeFieldset.appendChild(gameTypeLegend);
  const gameTypeOptions = document.createElement('div');
  gameTypeOptions.className = 'reservation-game-type-options';
  gameTypeFieldset.appendChild(gameTypeOptions);

  const participantsFieldset = document.createElement('fieldset');
  const participantsLegend = document.createElement('legend');
  participantsLegend.textContent = 'Jugadores invitados';
  participantsFieldset.appendChild(participantsLegend);
  const participantsContainer = document.createElement('div');
  participantsContainer.className = 'reservation-participants-grid';
  participantsFieldset.appendChild(participantsContainer);
  const participantsHint = document.createElement('p');
  participantsHint.className = 'reservation-form-hint';
  participantsFieldset.appendChild(participantsHint);

  form.appendChild(gameTypeFieldset);
  form.appendChild(participantsFieldset);

  const notesField = document.createElement('label');
  notesField.className = 'inline-field';
  notesField.appendChild(document.createTextNode('Notas (opcional)'));
  const notesInput = document.createElement('textarea');
  notesInput.rows = 2;
  notesInput.maxLength = 500;
  notesInput.placeholder = 'Añade información relevante para el rival o el club';
  notesField.appendChild(notesInput);
  form.appendChild(notesField);

  const status = document.createElement('p');
  status.className = 'status-message';
  form.appendChild(status);

  const actions = document.createElement('div');
  actions.className = 'form-actions';
  const cancelButton = document.createElement('button');
  cancelButton.type = 'button';
  cancelButton.className = 'secondary';
  cancelButton.textContent = 'Cancelar';
  const submitButton = document.createElement('button');
  submitButton.type = 'submit';
  submitButton.className = 'primary';
  submitButton.textContent = 'Guardar reserva';
  actions.appendChild(cancelButton);
  actions.appendChild(submitButton);
  form.appendChild(actions);

  const gameTypeOptionsData = [
    { value: 'individual', label: 'Partido individual' },
    { value: 'dobles', label: 'Partido de dobles' },
  ];

  gameTypeOptionsData.forEach((option) => {
    const wrapper = document.createElement('label');
    wrapper.className = 'reservation-game-type-option';
    const input = document.createElement('input');
    input.type = 'radio';
    input.name = 'reservation-game-type';
    input.value = option.value;
    input.checked = option.value === defaultGameType;
    wrapper.appendChild(input);
    const text = document.createElement('span');
    text.textContent = option.label;
    wrapper.appendChild(text);
    gameTypeOptions.appendChild(wrapper);
  });

  const gameTypeInputs = Array.from(
    gameTypeOptions.querySelectorAll('input[name="reservation-game-type"]')
  );

  const populateTimeOptions = (baseDate, selectedValue) => {
    timeSelect.innerHTML = '';
    const slots = getReservationSlotStartsForDate(baseDate);
    if (!slots.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Sin horarios disponibles';
      placeholder.disabled = true;
      placeholder.selected = true;
      timeSelect.appendChild(placeholder);
      timeSelect.disabled = true;
      return;
    }

    timeSelect.disabled = false;
    const fragment = document.createDocumentFragment();
    slots.forEach((slot) => {
      const option = document.createElement('option');
      option.value = formatTimeInputValue(slot);
      option.textContent = formatReservationSlotLabel(slot);
      if (selectedValue && option.value === selectedValue) {
        option.selected = true;
      }
      fragment.appendChild(option);
    });
    timeSelect.appendChild(fragment);
    if (!timeSelect.value && timeSelect.options.length) {
      timeSelect.selectedIndex = 0;
    }
  };

  const populateCourtOptions = () => {
    courtSelect.innerHTML = '';
    if (!courtNames.length) {
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'No hay pistas disponibles';
      placeholder.disabled = true;
      placeholder.selected = true;
      courtSelect.appendChild(placeholder);
      courtSelect.disabled = true;
      return;
    }

    courtSelect.disabled = false;
    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Selecciona una pista';
    placeholder.disabled = true;
    placeholder.selected = true;
    courtSelect.appendChild(placeholder);

    courtNames.forEach((courtName) => {
      const option = document.createElement('option');
      option.value = courtName;
      option.textContent = formatCourtDisplay(courtName) || courtName;
      courtSelect.appendChild(option);
    });

    if (defaultCourt) {
      const exists = courtNames.some((name) => name === defaultCourt);
      if (exists) {
        courtSelect.value = defaultCourt;
      }
    }
  };

  const getSelectedGameType = () => {
    const checked = form.querySelector('input[name="reservation-game-type"]:checked');
    return checked?.value === 'dobles' ? 'dobles' : 'individual';
  };

  const getRequiredParticipantCount = () => (getSelectedGameType() === 'dobles' ? 3 : 1);

  let isSubmittingReservation = false;

  const updateSubmitState = () => {
    if (isSubmittingReservation) {
      return;
    }

    const requiredParticipants = getRequiredParticipantCount();
    const hasEnoughPlayers = selectablePlayers.length >= requiredParticipants;
    const hasCourts = courtNames.length > 0;

    submitButton.disabled = !hasCourts || !hasEnoughPlayers;

    if (!hasCourts) {
      setStatusMessage(status, 'error', 'No hay pistas configuradas para realizar reservas.');
    } else if (!hasEnoughPlayers) {
      setStatusMessage(
        status,
        'error',
        requiredParticipants === 3
          ? 'No hay suficientes jugadores disponibles para crear una reserva de dobles.'
          : 'Todavía no hay otro jugador disponible para completar la reserva.'
      );
    } else {
      setStatusMessage(status, '', '');
    }
  };

  const renderParticipantInputs = () => {
    const requiredParticipants = getRequiredParticipantCount();
    participantsContainer.innerHTML = '';
    participantsContainer.classList.toggle(
      'reservation-participants-grid--doubles',
      requiredParticipants > 1
    );

    if (!selectablePlayers.length) {
      participantsHint.textContent =
        'Todavía no hay otros jugadores disponibles para añadir a la reserva.';
      updateSubmitState();
      return;
    }

    if (requiredParticipants === 3 && selectablePlayers.length < 3) {
      participantsHint.textContent =
        'Necesitas tres jugadores adicionales para una reserva de dobles. Añade más jugadores al club o elige un formato individual.';
    } else if (requiredParticipants === 1) {
      participantsHint.textContent = 'Añade al segundo jugador para completar la reserva individual.';
    } else {
      participantsHint.textContent = 'Añade a los otros tres jugadores para completar la reserva de dobles.';
    }

    for (let index = 0; index < requiredParticipants; index += 1) {
      const field = document.createElement('label');
      field.className = 'reservation-participant-field';
      field.appendChild(document.createTextNode(`Jugador ${index + 2}`));
      const select = document.createElement('select');
      select.required = true;
      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Selecciona un jugador';
      select.appendChild(placeholder);

      selectablePlayers.forEach((player) => {
        const playerId = normalizeId(player);
        if (!playerId) {
          return;
        }
        const option = document.createElement('option');
        option.value = playerId;
        option.textContent = formatReservationPlayerOptionLabel(player);
        select.appendChild(option);
      });

      field.appendChild(select);
      participantsContainer.appendChild(field);
    }

    updateSubmitState();
  };

  populateTimeOptions(defaultStart, defaultTimeValue);
  populateCourtOptions();
  renderParticipantInputs();

  dateInput.addEventListener('change', () => {
    const value = dateInput.value;
    const nextDate = value ? new Date(`${value}T00:00:00`) : null;
    const baseDate = nextDate && !Number.isNaN(nextDate.getTime()) ? nextDate : new Date();
    populateTimeOptions(baseDate, timeSelect.value);
  });

  gameTypeInputs.forEach((input) => {
    input.addEventListener('change', () => {
      renderParticipantInputs();
    });
  });

  cancelButton.addEventListener('click', () => {
    closeModal();
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();

    if (submitButton.disabled) {
      return;
    }

    const dateValue = dateInput.value;
    const timeValue = timeSelect.value;
    const startsAt = combineDateAndTime(dateValue, timeValue);

    if (!startsAt) {
      setStatusMessage(status, 'error', 'Selecciona una fecha y hora válidas.');
      return;
    }

    if (!isValidReservationSlotStart(startsAt)) {
      setStatusMessage(
        status,
        'error',
        'Selecciona un horario válido de 75 minutos entre las 08:30 y las 22:15.'
      );
      return;
    }

    const courtValue = courtSelect.value;
    if (!courtValue) {
      setStatusMessage(status, 'error', 'Selecciona una pista disponible.');
      return;
    }

    const participantSelects = Array.from(participantsContainer.querySelectorAll('select'));
    const participantIds = participantSelects.map((select) => select.value).filter(Boolean);
    if (participantIds.length !== participantSelects.length) {
      setStatusMessage(status, 'error', 'Selecciona todos los jugadores requeridos para la reserva.');
      return;
    }

    const uniqueParticipants = new Set(participantIds);
    if (uniqueParticipants.size !== participantIds.length) {
      setStatusMessage(status, 'error', 'Cada jugador solo puede aparecer una vez en la reserva.');
      return;
    }

    const gameType = getSelectedGameType();
    const requiredParticipants = getRequiredParticipantCount();
    if (participantIds.length < requiredParticipants) {
      setStatusMessage(status, 'error', 'Añade a todos los jugadores necesarios para la reserva.');
      return;
    }

    const payload = {
      court: courtValue,
      startsAt: startsAt.toISOString(),
      durationMinutes: COURT_RESERVATION_DEFAULT_DURATION,
      gameType,
      participants: participantIds,
    };

    const notes = notesInput.value?.trim();
    if (notes) {
      payload.notes = notes;
    }

    isSubmittingReservation = true;
    submitButton.disabled = true;
    setStatusMessage(status, 'info', 'Creando reserva...');

    try {
      await request('/courts/reservations', { method: 'POST', body: payload });
      await loadPlayerCourtData();
      if (hasCourtManagementAccess()) {
        await Promise.all([loadAdminCourtData(), loadCourtCalendarData()]);
      }
      closeModal();
      showGlobalMessage('Reserva creada correctamente.', 'success');
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    } finally {
      isSubmittingReservation = false;
      submitButton.disabled = false;
      updateSubmitState();
    }
  });

  openModal({
    title: 'Reservar pista',
    content: (body) => {
      body.appendChild(form);
    },
    onClose: () => {
      isSubmittingReservation = false;
      setStatusMessage(status, '', '');
    },
  });

  updateSubmitState();
}

async function cancelCourtReservation(reservationId, { button } = {}) {
  if (!reservationId) {
    return false;
  }

  const confirmed = window.confirm('¿Seguro que deseas cancelar la reserva?');
  if (!confirmed) {
    return false;
  }

  if (button) {
    button.disabled = true;
  }

  try {
    await request(`/courts/reservations/${reservationId}`, { method: 'DELETE' });
    showGlobalMessage('Reserva cancelada correctamente.', 'success');
    await loadPlayerCourtData();
    if (hasCourtManagementAccess()) {
      await Promise.all([loadAdminCourtData(), loadCourtCalendarData()]);
    }
    return true;
  } catch (error) {
    showGlobalMessage(error.message, 'error');
    return false;
  } finally {
    if (button) {
      button.disabled = false;
    }
  }
}

function filterMatchesByCategory(matches = []) {
  return Array.isArray(matches) ? matches : [];
}

function getMatchCategoryKey(match) {
  const normalized = normalizeId(match?.category);
  return normalized || UNCATEGORIZED_CATEGORY_KEY;
}

function getMatchCategoryMetadata(categoryKey, match) {
  if (match?.category && typeof match.category === 'object') {
    return {
      name: match.category.name || UNCATEGORIZED_CATEGORY_LABEL,
      color: getCategoryColor(match.category),
    };
  }

  const fallback = state.categories.find((category) => normalizeId(category) === categoryKey);
  if (fallback) {
    return {
      name: fallback.name || UNCATEGORIZED_CATEGORY_LABEL,
      color: getCategoryColor(fallback),
    };
  }

  if (categoryKey === UNCATEGORIZED_CATEGORY_KEY) {
    return {
      name: UNCATEGORIZED_CATEGORY_LABEL,
      color: '',
    };
  }

  return {
    name: 'Categoría',
    color: '',
  };
}

function getMatchPaginationStore(listKey) {
  if (!state.matchPagination[listKey]) {
    state.matchPagination[listKey] = {};
  }
  return state.matchPagination[listKey];
}

function getMatchPaginationPage(listKey, categoryKey) {
  const store = getMatchPaginationStore(listKey);
  const key = categoryKey || UNCATEGORIZED_CATEGORY_KEY;
  const value = Number(store[key]);
  return Number.isFinite(value) && value > 0 ? value : 1;
}

function setMatchPaginationPage(listKey, categoryKey, page) {
  const store = getMatchPaginationStore(listKey);
  const key = categoryKey || UNCATEGORIZED_CATEGORY_KEY;
  const numeric = Number(page);
  store[key] = Number.isFinite(numeric) && numeric > 0 ? Math.floor(numeric) : 1;
}

function resetMatchPaginationState(listKey) {
  if (state.matchPagination[listKey]) {
    state.matchPagination[listKey] = {};
  }
}

function resetAllMatchPagination() {
  resetMatchPaginationState('upcoming');
  resetMatchPaginationState('pending');
  resetMatchPaginationState('completed');
}

function closeProposalForm() {
  if (activeProposalForm?._schedulePicker && typeof activeProposalForm._schedulePicker.destroy === 'function') {
    activeProposalForm._schedulePicker.destroy();
  }
  if (activeProposalForm) {
    activeProposalForm.remove();
  }
  activeProposalForm = null;
  activeProposalMatchId = null;
}

function openProposalForm(matchId, triggerButton) {
  if (!matchId) {
    return;
  }

  if (activeProposalForm && activeProposalMatchId === matchId) {
    closeProposalForm();
    return;
  }

  closeProposalForm();

  const listItem = triggerButton?.closest('li[data-match-id]');
  if (!listItem) {
    showGlobalMessage('No se pudo abrir el formulario de propuesta.', 'error');
    return;
  }

  const form = document.createElement('form');
  form.className = 'proposal-form';

  const dateInputId = `proposal-${matchId}-datetime`;
  const dayInputId = `${dateInputId}-day`;
  const messageInputId = `proposal-${matchId}-message`;

  const scheduleTemplates = getClubMatchScheduleTemplates();
  const scheduleFieldMarkup = `
    <div class="proposal-form__field">
      <label for="${dayInputId}">Día del partido</label>
      <input type="date" id="${dayInputId}" name="proposedDay" required />
    </div>
    <input type="hidden" name="proposedAt" />
    <input type="hidden" name="proposedCourt" />
    <div class="proposal-form__field proposal-form__field--slots">
      <div class="match-schedule-picker" data-proposal-schedule-picker></div>
      <span class="form-hint">Selecciona una franja disponible.</span>
    </div>
  `;

  form.innerHTML = `
    <h4>Proponer fecha y hora</h4>
    ${scheduleFieldMarkup}
    <div class="proposal-form__field">
      <label for="${messageInputId}">Mensaje (opcional)</label>
      <textarea id="${messageInputId}" name="message" rows="3" placeholder="Mensaje para tu oponente"></textarea>
    </div>
    <p class="proposal-form__error" hidden></p>
    <div class="proposal-form__actions">
      <button type="submit" class="primary">Enviar propuesta</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  const proposedDayInput = form.querySelector('input[name="proposedDay"]');
  const proposedAtField = form.querySelector('input[name="proposedAt"]');
  const proposedCourtField = form.querySelector('input[name="proposedCourt"]');
  const schedulePickerContainer = form.querySelector('[data-proposal-schedule-picker]');
  const messageInput = form.querySelector('textarea[name="message"]');
  const cancelButton = form.querySelector('button[data-action="cancel"]');
  const submitButton = form.querySelector('button[type="submit"]');
  const errorMessage = form.querySelector('.proposal-form__error');

  const updateError = (message = '') => {
    if (!errorMessage) return;
    errorMessage.textContent = message;
    errorMessage.hidden = !message;
  };

  const now = new Date();
  const minDateValue = roundDateUpToInterval(now, CALENDAR_TIME_SLOT_MINUTES);
  const defaultDateValue = roundDateUpToInterval(
    new Date(minDateValue.getTime() + 2 * 60 * 60 * 1000),
    CALENDAR_TIME_SLOT_MINUTES
  );
  const defaultDateString = !Number.isNaN(defaultDateValue.getTime())
    ? formatDateInput(defaultDateValue)
    : '';
  const minDateString = !Number.isNaN(minDateValue.getTime()) ? formatDateInput(minDateValue) : '';
  const defaultTimeValue = !Number.isNaN(defaultDateValue.getTime())
    ? formatTimeInputValue(defaultDateValue)
    : '';
  const defaultSelectionValue = defaultDateString && defaultTimeValue
    ? `${defaultDateString}T${defaultTimeValue}`
    : '';

  if (proposedDayInput) {
    if (minDateString) {
      proposedDayInput.min = minDateString;
    }
    if (defaultDateString) {
      proposedDayInput.value = defaultDateString;
    }
  }

  if (schedulePickerContainer && proposedDayInput && proposedAtField) {
    const schedulePicker = createMatchScheduleSlotPicker({
      container: schedulePickerContainer,
      dateField: proposedDayInput,
      scheduledField: proposedAtField,
      courtField: proposedCourtField,
      templates: scheduleTemplates,
      scope: 'player',
      existingValue: defaultSelectionValue,
      ignoreMatchId: matchId,
      onChange: () => {
        updateError();
      },
    });
    form._schedulePicker = schedulePicker;

    if (defaultSelectionValue) {
      schedulePicker.setSelection({ scheduledAt: defaultSelectionValue });
    }
  }

  cancelButton?.addEventListener('click', (event) => {
    event.preventDefault();
    closeProposalForm();
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    updateError();

    let proposedDate = null;
    let selectedCourt = '';

    const schedulePicker = form._schedulePicker;

    const dayValue = proposedDayInput?.value || '';
    if (!dayValue) {
      updateError('Selecciona el día del partido.');
      proposedDayInput?.focus();
      return;
    }

    const scheduledAtValue = schedulePicker?.getSelection().scheduledAt || proposedAtField?.value || '';
    if (!scheduledAtValue) {
      updateError('Selecciona una franja horaria.');
      schedulePickerContainer?.scrollIntoView({ block: 'center', behavior: 'smooth' });
      return;
    }

    proposedDate = new Date(scheduledAtValue);
    if (!(proposedDate instanceof Date) || Number.isNaN(proposedDate.getTime())) {
      updateError('La combinación de día y franja no es válida.');
      schedulePickerContainer?.scrollIntoView({ block: 'center', behavior: 'smooth' });
      return;
    }

    selectedCourt = schedulePicker?.getSelection().court || proposedCourtField?.value || '';

    if (proposedDate && !Number.isNaN(minDateValue.getTime()) && proposedDate < minDateValue) {
      updateError('Selecciona una fecha futura.');
      proposedDayInput?.focus();
      return;
    }

    if (!isValidReservationSlotStart(proposedDate)) {
      updateError('Selecciona un horario válido entre las 08:30 y las 22:15.');
      schedulePickerContainer?.scrollIntoView({ block: 'center', behavior: 'smooth' });
      return;
    }

    const messageValue = messageInput?.value.trim();

    if (submitButton) submitButton.disabled = true;
    if (cancelButton) cancelButton.disabled = true;

    try {
      await request(`/matches/${matchId}/propose`, {
        method: 'POST',
        body: {
          proposedFor: proposedDate.toISOString(),
          court: selectedCourt || undefined,
          message: messageValue ? messageValue : undefined,
        },
      });
      showGlobalMessage('Se envió la propuesta de partido.', 'info');
      closeProposalForm();
      await loadAllData();
    } catch (error) {
      showGlobalMessage(error.message, 'error');
    } finally {
      if (submitButton) submitButton.disabled = false;
      if (cancelButton) cancelButton.disabled = false;
    }
  });

  form.addEventListener('input', () => {
    updateError();
  });

  activeProposalForm = form;
  activeProposalMatchId = matchId;

  listItem.appendChild(form);
  (proposedDayInput || schedulePickerContainer)?.focus();
}

function renderMyMatches(matches = []) {
  const hadActiveProposalForm = Boolean(activeProposalForm);
  let proposalFormAttached = false;

  const pendingCount = Array.isArray(matches)
    ? matches.filter((match) => match?.status === 'pendiente').length
    : 0;
  updateMatchesMenuBadge(pendingCount);

  myMatchesList.innerHTML = '';

  if (!matches.length) {
    myMatchesList.innerHTML = '<li class="empty-state">No tienes partidos asignados.</li>';
    if (hadActiveProposalForm) {
      closeProposalForm();
    }
    return;
  }

  const currentUserId = state.user?.id || state.user?._id || '';

  matches.forEach((match) => {
    const matchId = match._id || match.id;
    const item = document.createElement('li');
    item.dataset.matchId = matchId;
    const categoryColor = match.category ? getCategoryColor(match.category) : '';

    const title = document.createElement('strong');
    const players = Array.isArray(match.players)
      ? match.players.map((player) => player.fullName || 'Jugador').join(' vs ')
      : 'Jugadores por definir';
    title.textContent = players;
    if (categoryColor) {
      const indicator = createCategoryColorIndicator(categoryColor, match.category?.name);
      if (indicator) {
        title.classList.add('with-category-color');
        title.prepend(indicator);
      }
    }
    item.appendChild(title);

    const statusRow = document.createElement('div');
    statusRow.className = 'meta';
    const statusTag = document.createElement('span');
    statusTag.className = `tag status-${match.status}`;
    statusTag.textContent = STATUS_LABELS[match.status] || match.status;
    statusRow.appendChild(statusTag);
    if (match.category?.name) {
      const categoryTag = document.createElement('span');
      categoryTag.className = 'tag match-category-tag';
      categoryTag.textContent = match.category.name;
      applyCategoryTagColor(categoryTag, categoryColor);
      statusRow.appendChild(categoryTag);
    }
    item.appendChild(statusRow);

    if (categoryColor) {
      applyCategoryColorStyles(item, categoryColor, { shadowAlpha: 0.18 });
    }

    const detailRow = document.createElement('div');
    detailRow.className = 'meta';

    const resultStatus = match.result?.status || '';
    const isExpired = match.status === 'caducado';

    if (match.status === 'programado') {
      detailRow.appendChild(document.createElement('span')).textContent = formatDate(match.scheduledAt);
      if (match.court) {
        detailRow.appendChild(document.createElement('span')).textContent = `Pista ${match.court}`;
      }
    } else if (match.status === 'propuesto' && match.proposal) {
      const proposer = match.proposal.requestedBy?.fullName || 'Un jugador';
      detailRow.appendChild(document.createElement('span')).textContent = `${proposer} propuso ${formatDate(
        match.proposal.proposedFor
      )}`;
      if (match.court) {
        detailRow.appendChild(document.createElement('span')).textContent = `Pista sugerida: ${match.court}`;
      }
    } else if (match.status === 'pendiente') {
      detailRow.appendChild(document.createElement('span')).textContent =
        'A la espera de que alguien proponga fecha y hora.';
    } else if (match.status === 'caducado') {
      detailRow.appendChild(document.createElement('span')).textContent =
        'El plazo de 15 días expiró y el partido no otorgó puntos.';
    } else if (match.status === 'revision' || resultStatus === 'en_revision') {
      detailRow.appendChild(document.createElement('span')).textContent =
        'Resultado pendiente de confirmación.';
    } else if (match.status === 'completado' || resultStatus === 'confirmado') {
      detailRow.appendChild(document.createElement('span')).textContent = 'Resultado registrado.';
    }

    if (match.proposal?.message) {
      const proposalMessage = document.createElement('p');
      proposalMessage.className = 'proposal-message';
      proposalMessage.textContent = `Mensaje: ${match.proposal.message}`;
      item.appendChild(proposalMessage);
    }

    if (detailRow.childNodes.length) {
      item.appendChild(detailRow);
    }

    if (!isExpired && (match.status === 'pendiente' || match.status === 'propuesto')) {
      const warningMessage = getExpirationWarningMessage(match);
      if (warningMessage) {
        const warning = document.createElement('p');
        warning.className = 'deadline-warning';
        warning.textContent = warningMessage;
        item.appendChild(warning);
      }
    } else if (isExpired) {
      const deadlineDate = getMatchExpirationDate(match);
      const deadlineLabel = formatExpirationDeadline(deadlineDate);
      const warning = document.createElement('p');
      warning.className = 'deadline-warning deadline-warning--expired';
      warning.textContent = deadlineLabel
        ? `El plazo para disputar el partido venció el ${deadlineLabel}. El partido caducó sin puntos.`
        : 'El plazo para disputar el partido venció. El partido caducó sin puntos.';
      item.appendChild(warning);
    }

    if (resultStatus === 'confirmado' || match.status === 'completado') {
      const resultSummary = document.createElement('div');
      resultSummary.className = 'meta result-meta';
      const winner = match.result?.winner;
      let winnerName = '';
      if (winner) {
        if (typeof winner === 'object') {
          winnerName = winner.fullName || winner.email || 'Ganador';
        } else if (typeof winner === 'string') {
          const participant = Array.isArray(match.players)
            ? match.players.find((player) => normalizeId(player) === winner)
            : null;
          winnerName = participant?.fullName || participant?.email || 'Ganador';
        }
      }

      if (winnerName) {
        resultSummary.appendChild(document.createElement('span')).textContent = `Ganador: ${winnerName}`;
      }

      const scoreboard = createResultScoreboard(match);
      const scoreLabel = formatMatchScore(match);

      if (!scoreboard && scoreLabel) {
        resultSummary.appendChild(document.createElement('span')).textContent = scoreLabel;
      }

      if (resultSummary.childNodes.length) {
        item.appendChild(resultSummary);
      }

      if (scoreboard) {
        item.appendChild(scoreboard);
      }
    } else if (resultStatus === 'rechazado') {
      const rejected = document.createElement('div');
      rejected.className = 'meta warning';
      rejected.textContent = 'El resultado enviado fue rechazado. Vuelve a registrarlo.';
      item.appendChild(rejected);
    }

    const actions = document.createElement('div');
    actions.className = 'actions';

    const canPropose = !isExpired && match.status === 'pendiente';
    if (canPropose) {
      const proposeButton = document.createElement('button');
      proposeButton.type = 'button';
      proposeButton.className = 'primary';
      proposeButton.dataset.action = 'propose';
      proposeButton.dataset.matchId = matchId;
      proposeButton.textContent = 'Proponer fecha';
      actions.appendChild(proposeButton);
    } else if (match.status === 'propuesto' && match.proposal) {
      if (match.proposal.requestedTo?._id === currentUserId || match.proposal.requestedTo === currentUserId) {
        const acceptButton = document.createElement('button');
        acceptButton.type = 'button';
        acceptButton.className = 'primary';
        acceptButton.dataset.action = 'respond';
        acceptButton.dataset.decision = 'accept';
        acceptButton.dataset.matchId = matchId;
        acceptButton.textContent = 'Aceptar propuesta';
        actions.appendChild(acceptButton);

        const rejectButton = document.createElement('button');
        rejectButton.type = 'button';
        rejectButton.className = 'ghost';
        rejectButton.dataset.action = 'respond';
        rejectButton.dataset.decision = 'reject';
        rejectButton.dataset.matchId = matchId;
        rejectButton.textContent = 'Rechazar';
        actions.appendChild(rejectButton);
      } else if (
        match.proposal.requestedBy?._id === currentUserId ||
        match.proposal.requestedBy === currentUserId
      ) {
        const waiting = document.createElement('p');
        waiting.className = 'meta';
        const opponentName = match.proposal.requestedTo?.fullName || 'el o la oponente';
        waiting.textContent = `Esperando confirmación de ${opponentName}.`;
        item.appendChild(waiting);
      }
    }

    const confirmation = getResultConfirmation(match, currentUserId);
    const needsConfirmation = resultStatus === 'en_revision' && confirmation?.status !== 'aprobado';
    const canReportResult = match.status !== 'completado' && !isExpired;

    if (canReportResult) {
      const reportButton = document.createElement('button');
      reportButton.type = 'button';
      reportButton.className = needsConfirmation ? 'secondary' : 'primary';
      reportButton.dataset.action = 'report-result';
      reportButton.dataset.matchId = matchId;
      reportButton.textContent = needsConfirmation ? 'Actualizar resultado' : 'Reportar resultado';
      actions.appendChild(reportButton);
    }

    if (needsConfirmation) {
      const approveButton = document.createElement('button');
      approveButton.type = 'button';
      approveButton.className = 'primary';
      approveButton.dataset.action = 'confirm-result';
      approveButton.dataset.matchId = matchId;
      approveButton.textContent = 'Confirmar resultado';
      actions.appendChild(approveButton);

      const rejectButton = document.createElement('button');
      rejectButton.type = 'button';
      rejectButton.className = 'ghost';
      rejectButton.dataset.action = 'reject-result';
      rejectButton.dataset.matchId = matchId;
      rejectButton.textContent = 'Rechazar';
      actions.appendChild(rejectButton);
    }

    if (isAdmin()) {
      const editButton = document.createElement('button');
      editButton.type = 'button';
      editButton.className = 'secondary';
      editButton.dataset.action = 'edit-match';
      editButton.dataset.matchId = matchId;
      editButton.textContent = 'Editar';
      actions.appendChild(editButton);

      if (match.status !== 'completado') {
        const deleteButton = document.createElement('button');
        deleteButton.type = 'button';
        deleteButton.className = 'danger';
        deleteButton.dataset.action = 'delete-match';
        deleteButton.dataset.matchId = matchId;
        deleteButton.textContent = 'Eliminar';
        actions.appendChild(deleteButton);
      }
    }

    if (actions.childNodes.length) {
      item.appendChild(actions);
    }

    if (activeProposalForm && activeProposalMatchId === matchId) {
      item.appendChild(activeProposalForm);
      proposalFormAttached = true;
    }

    myMatchesList.appendChild(item);
  });

  if (hadActiveProposalForm && !proposalFormAttached) {
    closeProposalForm();
  }
}

function renderNotifications(notifications = []) {
  const baseList = Array.isArray(notifications) ? [...notifications] : [];
  state.notificationBase = baseList;
  const combined = combineNotificationsWithEnrollmentRequests(baseList);
  state.notifications = combined;

  updateNotificationCounts(combined);
  notificationsList.innerHTML = '';
  if (!combined.length) {
    notificationsList.innerHTML = '<li class="empty-state">No tienes notificaciones pendientes.</li>';
    return;
  }

  combined.forEach((notification) => {
    const item = document.createElement('li');
    const title = document.createElement('strong');
    const isLeagueEnrollment = notification.type === 'enrollment-request';
    const isTournamentEnrollment = notification.type === 'tournament-enrollment-request';
    const isEnrollmentAlert = isLeagueEnrollment || isTournamentEnrollment;

    title.textContent = isEnrollmentAlert
      ? notification.title || `Solicitudes de inscripción · ${notification.categoryName || 'Categoría'}`
      : notification.title;
    item.appendChild(title);

    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.appendChild(document.createElement('span')).textContent = formatDate(notification.scheduledFor);
    const channelLabel = (() => {
      if (isTournamentEnrollment) return 'TORNEOS';
      if (isLeagueEnrollment) return 'SOLICITUDES';
      return (notification.channel || 'app').toUpperCase();
    })();
    meta.appendChild(document.createElement('span')).textContent = channelLabel;
    if (isEnrollmentAlert && Number(notification.pendingCount) > 0) {
      meta.appendChild(document.createElement('span')).textContent = `Pendientes: ${notification.pendingCount}`;
    }
    item.appendChild(meta);

    const messageText = notification.message;
    if (messageText) {
      const message = document.createElement('p');
      message.textContent = messageText;
      item.appendChild(message);
    }

    if (!isEnrollmentAlert && notification.match?.scheduledAt) {
      const info = document.createElement('div');
      info.className = 'meta';
      info.textContent = `Partido: ${formatDate(notification.match.scheduledAt)} · Pista ${
        notification.match.court || 'por confirmar'
      }`;
      item.appendChild(info);
    }

    if (isEnrollmentAlert) {
      const actions = document.createElement('div');
      actions.className = 'actions';
      const reviewButton = document.createElement('button');
      reviewButton.type = 'button';
      reviewButton.className = 'primary';
      let hasTarget = false;
      if (isTournamentEnrollment && notification.tournamentId) {
        reviewButton.dataset.reviewTournament = notification.tournamentId;
        if (notification.categoryId) {
          reviewButton.dataset.reviewTournamentCategory = notification.categoryId;
        }
        hasTarget = true;
      } else if (notification.categoryId) {
        reviewButton.dataset.reviewCategory = notification.categoryId;
        hasTarget = true;
      }

      if (hasTarget) {
        reviewButton.textContent =
          Number(notification.pendingCount) === 1 ? 'Revisar solicitud' : 'Revisar solicitudes';
        actions.appendChild(reviewButton);
        item.appendChild(actions);
      }
      notificationsList.appendChild(item);
      return;
    }

    const notificationId = normalizeId(notification);
    if (notificationId) {
      const actions = document.createElement('div');
      actions.className = 'actions';
      const dismiss = document.createElement('button');
      dismiss.type = 'button';
      dismiss.className = 'secondary';
      dismiss.dataset.notificationId = notificationId;
      dismiss.textContent = 'Marcar como leída';
      actions.appendChild(dismiss);
      item.appendChild(actions);
    }

    notificationsList.appendChild(item);
  });
}

function normalizeWebsiteUrl(value) {
  if (typeof value !== 'string') return '';
  const trimmed = value.trim();
  if (!trimmed) return '';
  try {
    const url = new URL(trimmed.startsWith('http') ? trimmed : `https://${trimmed}`);
    return url.toString();
  } catch (error) {
    return trimmed;
  }
}

function normalizeDayLabel(label) {
  if (typeof label !== 'string') return '';
  return label
    .trim()
    .toLowerCase()
    .normalize('NFD')
    .replace(/[\u0300-\u036f]/g, '');
}

const WEEKDAY_VALUE_BY_LABEL = WEEKDAY_OPTIONS.reduce((map, option) => {
  map[normalizeDayLabel(option.label)] = option.value;
  return map;
}, {});

function getDayValueFromLabel(label) {
  const normalized = normalizeDayLabel(label);
  return WEEKDAY_VALUE_BY_LABEL[normalized] || '';
}

function normalizeScheduleForEditor(entry = {}) {
  const label = typeof entry.label === 'string' ? entry.label.trim() : '';
  const opensAt = typeof entry.opensAt === 'string' ? entry.opensAt.trim() : '';
  const closesAt = typeof entry.closesAt === 'string' ? entry.closesAt.trim() : '';
  const dayValue = getDayValueFromLabel(label);

  if (dayValue) {
    return {
      dayValue,
      customLabel: '',
      opensAt,
      closesAt,
    };
  }

  return {
    dayValue: label ? 'custom' : '',
    customLabel: label,
    opensAt,
    closesAt,
  };
}

function createSchedulesEditor(initialSchedules = []) {
  const wrapper = document.createElement('div');
  wrapper.className = 'club-editor';

  const list = document.createElement('div');
  list.className = 'club-editor__list';

  const emptyState = document.createElement('p');
  emptyState.className = 'club-editor__empty';
  emptyState.textContent = 'No hay franjas horarias configuradas.';

  const footer = document.createElement('div');
  footer.className = 'club-editor__footer';

  const addButton = document.createElement('button');
  addButton.type = 'button';
  addButton.className = 'secondary';
  addButton.textContent = 'Añadir franja horaria';
  footer.appendChild(addButton);

  wrapper.append(list, emptyState, footer);

  function updateEmptyState() {
    emptyState.hidden = list.children.length > 0;
  }

  function createScheduleItem(data = {}) {
    const item = document.createElement('div');
    item.className = 'club-editor__item';

    const firstRow = document.createElement('div');
    firstRow.className = 'form-grid';

    const dayLabel = document.createElement('label');
    dayLabel.textContent = 'Día';
    const daySelect = document.createElement('select');
    daySelect.className = 'club-schedule-day';
    daySelect.innerHTML = '<option value="">Selecciona un día</option>';
    WEEKDAY_OPTIONS.forEach((option) => {
      const opt = document.createElement('option');
      opt.value = option.value;
      opt.textContent = option.label;
      daySelect.appendChild(opt);
    });
    const customOption = document.createElement('option');
    customOption.value = 'custom';
    customOption.textContent = 'Personalizado';
    daySelect.appendChild(customOption);
    dayLabel.appendChild(daySelect);

    const customLabel = document.createElement('label');
    customLabel.className = 'club-schedule-custom';
    customLabel.textContent = 'Nombre de la franja';
    const customInput = document.createElement('input');
    customInput.type = 'text';
    customInput.className = 'club-schedule-label';
    customInput.placeholder = 'Ej. Torneo interno';
    customLabel.appendChild(customInput);

    firstRow.append(dayLabel, customLabel);

    const secondRow = document.createElement('div');
    secondRow.className = 'form-grid';

    const opensLabel = document.createElement('label');
    opensLabel.textContent = 'Hora de apertura';
    const opensInput = document.createElement('input');
    opensInput.type = 'time';
    opensInput.className = 'club-schedule-opens';
    opensLabel.appendChild(opensInput);

    const closesLabel = document.createElement('label');
    closesLabel.textContent = 'Hora de cierre';
    const closesInput = document.createElement('input');
    closesInput.type = 'time';
    closesInput.className = 'club-schedule-closes';
    closesLabel.appendChild(closesInput);

    secondRow.append(opensLabel, closesLabel);

    const actions = document.createElement('div');
    actions.className = 'form-actions form-actions--inline';
    const removeButton = document.createElement('button');
    removeButton.type = 'button';
    removeButton.className = 'ghost';
    removeButton.textContent = 'Eliminar franja';
    removeButton.addEventListener('click', () => {
      list.removeChild(item);
      if (!list.children.length) {
        addSchedule({ dayValue: '', customLabel: '', opensAt: '', closesAt: '' });
      } else {
        updateEmptyState();
      }
    });
    actions.appendChild(removeButton);

    item.append(firstRow, secondRow, actions);
    list.appendChild(item);

    if (data.dayValue) {
      daySelect.value = data.dayValue;
    }
    if (data.customLabel) {
      customInput.value = data.customLabel;
    }
    if (data.opensAt) {
      opensInput.value = data.opensAt;
    }
    if (data.closesAt) {
      closesInput.value = data.closesAt;
    }

    function syncCustomField() {
      const isCustom = daySelect.value === 'custom' || !daySelect.value;
      customLabel.hidden = !isCustom;
      if (!isCustom) {
        customInput.placeholder = `Ej. ${WEEKDAY_LABEL_BY_VALUE[daySelect.value] || 'Horario'}`;
      } else {
        customInput.placeholder = 'Nombre de la franja';
      }
    }

    daySelect.addEventListener('change', syncCustomField);
    syncCustomField();

    updateEmptyState();
  }

  function addSchedule(data) {
    createScheduleItem(data);
  }

  addButton.addEventListener('click', () => {
    addSchedule({ dayValue: '', customLabel: '', opensAt: '', closesAt: '' });
  });

  const normalized = Array.isArray(initialSchedules) ? initialSchedules.map(normalizeScheduleForEditor) : [];
  if (normalized.length) {
    normalized.forEach((entry) => addSchedule(entry));
  }

  if (!list.children.length) {
    addSchedule({ dayValue: '', customLabel: '', opensAt: '', closesAt: '' });
  }

  updateEmptyState();

  function getValue() {
    return Array.from(list.querySelectorAll('.club-editor__item'))
      .map((item) => {
        const daySelect = item.querySelector('.club-schedule-day');
        const customInput = item.querySelector('.club-schedule-label');
        const opensInput = item.querySelector('.club-schedule-opens');
        const closesInput = item.querySelector('.club-schedule-closes');

        const dayValue = daySelect?.value || '';
        const opensAt = opensInput?.value?.trim() || '';
        const closesAt = closesInput?.value?.trim() || '';
        let label = '';

        if (dayValue && dayValue !== 'custom') {
          label = WEEKDAY_LABEL_BY_VALUE[dayValue] || '';
        } else {
          label = customInput?.value?.trim() || '';
        }

        if (!label) {
          return null;
        }

        return {
          label,
          opensAt,
          closesAt,
        };
      })
      .filter(Boolean);
  }

  return {
    element: wrapper,
    getValue,
    addSchedule,
  };
}

function normalizeCourtForEditor(entry = {}) {
  return {
    name: typeof entry.name === 'string' ? entry.name.trim() : '',
    surface: typeof entry.surface === 'string' ? entry.surface.trim() : '',
    indoor: Boolean(entry.indoor),
    lights: entry.lights === undefined ? true : Boolean(entry.lights),
    notes: typeof entry.notes === 'string' ? entry.notes.trim() : '',
  };
}

function createCourtsEditor(initialCourts = []) {
  const wrapper = document.createElement('div');
  wrapper.className = 'club-editor';

  const list = document.createElement('div');
  list.className = 'club-editor__list';

  const emptyState = document.createElement('p');
  emptyState.className = 'club-editor__empty';
  emptyState.textContent = 'No hay pistas añadidas.';

  const footer = document.createElement('div');
  footer.className = 'club-editor__footer';

  const addButton = document.createElement('button');
  addButton.type = 'button';
  addButton.className = 'secondary';
  addButton.textContent = 'Añadir pista';
  footer.appendChild(addButton);

  wrapper.append(list, emptyState, footer);

  function updateEmptyState() {
    emptyState.hidden = list.children.length > 0;
  }

  function createCourtItem(data = {}) {
    const item = document.createElement('div');
    item.className = 'club-editor__item';

    const firstRow = document.createElement('div');
    firstRow.className = 'form-grid';

    const nameLabel = document.createElement('label');
    nameLabel.textContent = 'Nombre de la pista';
    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.className = 'club-court-name';
    nameInput.placeholder = 'Ej. Pista Central';
    nameLabel.appendChild(nameInput);

    const surfaceLabel = document.createElement('label');
    surfaceLabel.textContent = 'Superficie';
    const surfaceInput = document.createElement('input');
    surfaceInput.type = 'text';
    surfaceInput.className = 'club-court-surface';
    surfaceInput.placeholder = 'Ej. Dura, Arcilla';
    surfaceLabel.appendChild(surfaceInput);

    firstRow.append(nameLabel, surfaceLabel);

    const secondRow = document.createElement('div');
    secondRow.className = 'form-grid';

    const indoorLabel = document.createElement('label');
    indoorLabel.textContent = 'Tipo de pista';
    const indoorSelect = document.createElement('select');
    indoorSelect.className = 'club-court-indoor';
    indoorSelect.innerHTML = `
      <option value="outdoor">Exterior</option>
      <option value="indoor">Interior</option>
    `;
    indoorLabel.appendChild(indoorSelect);

    const lightsLabel = document.createElement('label');
    lightsLabel.textContent = 'Iluminación';
    const lightsSelect = document.createElement('select');
    lightsSelect.className = 'club-court-lights';
    lightsSelect.innerHTML = `
      <option value="true">Con iluminación</option>
      <option value="false">Sin iluminación</option>
    `;
    lightsLabel.appendChild(lightsSelect);

    secondRow.append(indoorLabel, lightsLabel);

    const notesLabel = document.createElement('label');
    notesLabel.textContent = 'Notas';
    const notesInput = document.createElement('textarea');
    notesInput.className = 'club-court-notes';
    notesInput.rows = 2;
    notesInput.placeholder = 'Detalles adicionales u observaciones';
    notesLabel.appendChild(notesInput);

    const actions = document.createElement('div');
    actions.className = 'form-actions form-actions--inline';
    const removeButton = document.createElement('button');
    removeButton.type = 'button';
    removeButton.className = 'ghost';
    removeButton.textContent = 'Eliminar pista';
    removeButton.addEventListener('click', () => {
      list.removeChild(item);
      if (!list.children.length) {
        addCourt({ name: '', surface: '', indoor: false, lights: true, notes: '' });
      } else {
        updateEmptyState();
      }
    });
    actions.appendChild(removeButton);

    item.append(firstRow, secondRow, notesLabel, actions);
    list.appendChild(item);

    nameInput.value = data.name || '';
    surfaceInput.value = data.surface || '';
    indoorSelect.value = data.indoor ? 'indoor' : 'outdoor';
    lightsSelect.value = data.lights === false ? 'false' : 'true';
    notesInput.value = data.notes || '';

    updateEmptyState();
  }

  function addCourt(data) {
    createCourtItem(data);
  }

  addButton.addEventListener('click', () => {
    addCourt({ name: '', surface: '', indoor: false, lights: true, notes: '' });
  });

  const normalized = Array.isArray(initialCourts) ? initialCourts.map(normalizeCourtForEditor) : [];
  if (normalized.length) {
    normalized.forEach((entry) => addCourt(entry));
  }

  if (!list.children.length) {
    addCourt({ name: '', surface: '', indoor: false, lights: true, notes: '' });
  }

  updateEmptyState();

  function getValue() {
    return Array.from(list.querySelectorAll('.club-editor__item'))
      .map((item) => {
        const nameInput = item.querySelector('.club-court-name');
        const surfaceInput = item.querySelector('.club-court-surface');
        const indoorSelect = item.querySelector('.club-court-indoor');
        const lightsSelect = item.querySelector('.club-court-lights');
        const notesInput = item.querySelector('.club-court-notes');

        const name = nameInput?.value?.trim();
        if (!name) {
          return null;
        }

        return {
          name,
          surface: surfaceInput?.value?.trim() || '',
          indoor: indoorSelect?.value === 'indoor',
          lights: lightsSelect?.value !== 'false',
          notes: notesInput?.value?.trim() || '',
        };
      })
      .filter(Boolean);
  }

  return {
    element: wrapper,
    getValue,
    addCourt,
  };
}

function createRegulationEditor(
  initialContent = '',
  placeholder = 'Describe el reglamento del club con formato enriquecido'
) {
  const container = document.createElement('div');
  container.className = 'chat-editor chat-editor--regulation';

  const toolbar = document.createElement('div');
  toolbar.className = 'chat-toolbar';
  toolbar.setAttribute('role', 'toolbar');
  toolbar.setAttribute('aria-label', 'Formato del reglamento');

  const buttons = [
    { command: 'bold', label: 'Negrita', content: 'B' },
    { command: 'italic', label: 'Cursiva', content: 'I' },
    { command: 'underline', label: 'Subrayado', content: 'U' },
    { command: 'heading', label: 'Encabezado nivel 1', content: 'H1', level: '1' },
    { command: 'heading', label: 'Encabezado nivel 2', content: 'H2', level: '2' },
    { command: 'list', label: 'Lista con viñetas', content: '•', list: 'unordered' },
    { command: 'list', label: 'Lista numerada', content: '1.', list: 'ordered' },
    { command: 'quote', label: 'Cita', content: '“ ”' },
    { command: 'link', label: 'Insertar enlace', content: '🔗' },
    { command: 'clear', label: 'Limpiar formato', content: '⌫' },
  ];

  buttons.forEach((config) => {
    const button = document.createElement('button');
    button.type = 'button';
    button.className = 'chat-toolbar-button';
    button.dataset.command = config.command;
    if (config.level) {
      button.dataset.level = config.level;
    }
    if (config.list) {
      button.dataset.list = config.list;
    }
    button.setAttribute('aria-label', config.label);
    button.textContent = config.content;
    toolbar.appendChild(button);
  });

  const editor = document.createElement('div');
  editor.className = 'chat-editor-content';
  editor.contentEditable = 'true';
  editor.setAttribute('role', 'textbox');
  editor.setAttribute('aria-multiline', 'true');
  editor.dataset.placeholder = placeholder;

  const sanitizedInitial = sanitizeNoticeHtml(initialContent) || '';
  if (sanitizedInitial) {
    editor.innerHTML = sanitizedInitial;
  }

  toolbar.addEventListener('click', (event) => {
    const button = event.target.closest('button[data-command]');
    if (!button || button.disabled) {
      return;
    }
    const { command } = button.dataset;
    if (!command) {
      return;
    }
    applyRichTextCommand(editor, command, {
      level: button.dataset.level,
      list: button.dataset.list,
    });
  });

  container.append(toolbar, editor);

  function getValue() {
    const rawHtml = editor.innerHTML || '';
    return sanitizeNoticeHtml(rawHtml);
  }

  return {
    element: container,
    getValue,
  };
}

function parseFacilitiesInput(rawValue) {
  if (typeof rawValue !== 'string') return [];
  return rawValue
    .split('\n')
    .map((line) => line.trim())
    .filter(Boolean);
}

function renderClubProfile(club = {}) {
  state.club = club || {};
  const name = typeof club.name === 'string' && club.name.trim() ? club.name.trim() : APP_BRAND_NAME;
  const slogan =
    typeof club.slogan === 'string' && club.slogan.trim() ? club.slogan.trim() : APP_BRAND_SLOGAN;

  if (clubNameHeading) {
    clubNameHeading.textContent = name;
  }
  if (clubSloganHeading) {
    clubSloganHeading.textContent = slogan;
  }
  if (clubNameDisplay) {
    clubNameDisplay.textContent = name;
  }
  if (clubSloganDisplay) {
    clubSloganDisplay.textContent = slogan;
  }
  if (mobileTopbarTitle) {
    mobileTopbarTitle.textContent = name;
  }

  if (clubDescription) {
    clubDescription.textContent = club.description?.trim() || 'Actualiza la descripción del club para compartir la filosofía y servicios disponibles.';
  }

  const contactBits = [];
  if (club.contactPhone) {
    contactBits.push(`Tel: ${club.contactPhone}`);
  }
  if (club.contactEmail) {
    contactBits.push(`Email: ${club.contactEmail}`);
  }

  if (clubAddress) {
    clubAddress.textContent = club.address?.trim() || '—';
  }
  if (clubContact) {
    clubContact.textContent = contactBits.length ? contactBits.join(' · ') : '—';
  }
  if (clubWebsite) {
    clubWebsite.textContent = '';
    const normalized = normalizeWebsiteUrl(club.website);
    if (normalized) {
      const link = document.createElement('a');
      link.href = normalized;
      link.target = '_blank';
      link.rel = 'noopener noreferrer';
      link.textContent = normalized.replace(/^https?:\/\//i, '');
      clubWebsite.appendChild(link);
    } else {
      clubWebsite.textContent = '—';
    }
  }

  if (topbarLogo) {
    if (club.logo) {
      topbarLogo.src = club.logo;
    } else {
      topbarLogo.src = 'assets/club-logo.svg';
    }
  }

  if (mobileTopbarLogo) {
    if (club.logo) {
      mobileTopbarLogo.src = club.logo;
    } else {
      mobileTopbarLogo.src = 'assets/club-logo.svg';
    }
  }

  if (clubLogoDisplay) {
    if (club.logo) {
      clubLogoDisplay.style.backgroundImage = `url(${club.logo})`;
      clubLogoDisplay.textContent = '';
    } else {
      clubLogoDisplay.style.backgroundImage = '';
      clubLogoDisplay.textContent = name.charAt(0).toUpperCase();
    }
  }

  const schedules = Array.isArray(club.schedules) ? club.schedules : [];
  if (clubScheduleList) {
    clubScheduleList.innerHTML = '';
    schedules.forEach((entry) => {
      const item = document.createElement('li');
      const rangeParts = [];
      if (entry.opensAt) {
        rangeParts.push(entry.opensAt);
      }
      if (entry.closesAt) {
        rangeParts.push(entry.closesAt);
      }
      const range = rangeParts.length ? ` · ${rangeParts.join(' – ')}` : '';
      item.textContent = `${entry.label}${range}`;
      clubScheduleList.appendChild(item);
    });
    clubScheduleList.hidden = !schedules.length;
  }
  if (clubScheduleEmpty) {
    clubScheduleEmpty.hidden = Boolean(schedules.length);
  }

  const courts = Array.isArray(club.courts) ? club.courts : [];
  if (clubCourtsList) {
    clubCourtsList.innerHTML = '';
    courts.forEach((court) => {
      const item = document.createElement('li');
      const details = [];
      if (court.surface) {
        details.push(court.surface);
      }
      details.push(court.indoor ? 'Interior' : 'Exterior');
      details.push(court.lights ? 'Con iluminación' : 'Sin iluminación');
      if (court.notes) {
        details.push(court.notes);
      }
      item.textContent = `${court.name} · ${details.join(' · ')}`;
      clubCourtsList.appendChild(item);
    });
    clubCourtsList.hidden = !courts.length;
  }
  if (clubCourtsEmpty) {
    clubCourtsEmpty.hidden = Boolean(courts.length);
  }

  const facilities = Array.isArray(club.facilities) ? club.facilities : [];
  if (clubFacilitiesList) {
    clubFacilitiesList.innerHTML = '';
    facilities.forEach((facility) => {
      const item = document.createElement('li');
      item.textContent = facility;
      clubFacilitiesList.appendChild(item);
    });
    clubFacilitiesList.hidden = !facilities.length;
  }
  if (clubFacilitiesEmpty) {
    clubFacilitiesEmpty.hidden = Boolean(facilities.length);
  }

  populateCourtReservationCourts();
  populateCourtBlockCourts();
  populateCourtBlockEntities();
  populateAdminMatchCourtOptions();
  const currentScheduledValue = adminMatchDate?.value || '';
  const currentSlot = currentScheduledValue.includes('T')
    ? currentScheduledValue.split('T')[1]
    : '';
  updateAdminMatchScheduleVisibility({
    selectedTime: currentSlot,
    selectedCourt: adminMatchCourt?.value || '',
  });

  renderRules();

  if (clubStatus) {
    setStatusMessage(clubStatus, '', '');
  }
}

function formatChatTimestamp(value) {
  if (!value) return '';
  try {
    return new Intl.DateTimeFormat('es-ES', {
      day: '2-digit',
      month: '2-digit',
      hour: '2-digit',
      minute: '2-digit',
    }).format(new Date(value));
  } catch (error) {
    return '';
  }
}

const NOTICE_ALLOWED_SCHEMES = new Set(['http:', 'https:', 'mailto:', 'tel:']);
const NOTICE_ALLOWED_IMAGE_SCHEMES = new Set(['http:', 'https:']);
const NOTICE_ALLOWED_TAGS = new Set([
  'P',
  'BR',
  'STRONG',
  'B',
  'EM',
  'I',
  'U',
  'OL',
  'UL',
  'LI',
  'BLOCKQUOTE',
  'A',
  'H1',
  'H2',
  'H3',
  'H4',
  'IMG',
]);

function sanitizeNoticeHtml(html) {
  if (typeof html !== 'string' || !html.trim()) {
    return '';
  }

  const template = document.createElement('template');
  template.innerHTML = html;

  const cleanNode = (node) => {
    const children = Array.from(node.childNodes);
    for (const child of children) {
      if (child.nodeType === Node.ELEMENT_NODE) {
        if (child.tagName === 'SPAN') {
          const style = child.getAttribute('style') || '';
          if (/text-decoration\s*:\s*underline/i.test(style)) {
            const underline = document.createElement('u');
            while (child.firstChild) {
              underline.appendChild(child.firstChild);
            }
            child.replaceWith(underline);
            cleanNode(underline);
            continue;
          }
        }

        if (!NOTICE_ALLOWED_TAGS.has(child.tagName)) {
          const fragment = document.createDocumentFragment();
          while (child.firstChild) {
            fragment.appendChild(child.firstChild);
          }
          child.replaceWith(fragment);
          cleanNode(fragment);
          continue;
        }

        if (child.tagName === 'IMG') {
          const attributes = Array.from(child.attributes);
          let hasValidSource = false;
          for (const attribute of attributes) {
            const name = attribute.name.toLowerCase();
            if (name === 'src') {
              const value = attribute.value.trim();
              if (NOTICE_INLINE_IMAGE_DATA_URL_PATTERN.test(value)) {
                child.setAttribute('src', value);
                hasValidSource = true;
              } else if (value) {
                try {
                  const url = new URL(value, window.location.origin);
                  if (NOTICE_ALLOWED_IMAGE_SCHEMES.has(url.protocol)) {
                    child.setAttribute('src', url.toString());
                    hasValidSource = true;
                  } else {
                    child.removeAttribute(attribute.name);
                  }
                } catch (error) {
                  child.removeAttribute(attribute.name);
                }
              } else {
                child.removeAttribute(attribute.name);
              }
              continue;
            }
            if (name === 'alt') {
              const altText = attribute.value.trim().slice(0, 240);
              child.setAttribute('alt', altText);
              continue;
            }
            child.removeAttribute(attribute.name);
          }
          if (!hasValidSource) {
            child.remove();
            continue;
          }
          if (!child.hasAttribute('alt')) {
            child.setAttribute('alt', '');
          }
          continue;
        }

        const attributes = Array.from(child.attributes);
        for (const attribute of attributes) {
          const name = attribute.name.toLowerCase();
          if (child.tagName === 'A') {
            if (name === 'href') {
              let href = attribute.value.trim();
              if (href && !/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(href)) {
                href = `https://${href}`;
              }
              try {
                const url = new URL(href);
                if (!NOTICE_ALLOWED_SCHEMES.has(url.protocol)) {
                  child.removeAttribute(attribute.name);
                  continue;
                }
                child.setAttribute('href', url.toString());
                child.setAttribute('rel', 'noopener noreferrer');
                child.setAttribute('target', '_blank');
              } catch (error) {
                child.removeAttribute(attribute.name);
              }
              continue;
            }
            if (name === 'title') {
              continue;
            }
            if (name === 'rel') {
              child.setAttribute('rel', 'noopener noreferrer');
              continue;
            }
            if (name === 'target') {
              child.setAttribute('target', '_blank');
              continue;
            }
          }
          child.removeAttribute(attribute.name);
        }

        cleanNode(child);
      } else if (child.nodeType === Node.COMMENT_NODE) {
        child.remove();
      } else if (child.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        cleanNode(child);
      }
    }
  };

  cleanNode(template.content);
  return template.innerHTML.trim();
}

function extractPlainTextFromHtml(html) {
  if (!html) {
    return '';
  }
  const template = document.createElement('template');
  template.innerHTML = html;
  const text = template.content.textContent || '';
  return text.replace(/\s+/g, ' ').trim();
}

function formatFileSize(bytes) {
  if (!Number.isFinite(bytes) || bytes <= 0) {
    return '';
  }
  if (bytes >= 1024 * 1024) {
    const value = (bytes / (1024 * 1024)).toFixed(1);
    const normalized = value.endsWith('.0') ? value.slice(0, -2) : value;
    return `${normalized} MB`;
  }
  if (bytes >= 1024) {
    return `${Math.round(bytes / 1024)} KB`;
  }
  return `${bytes} B`;
}

function estimateDataUrlPayloadSize(dataUrl) {
  if (typeof dataUrl !== 'string') {
    return 0;
  }
  const commaIndex = dataUrl.indexOf(',');
  if (commaIndex === -1) {
    return 0;
  }
  const base64 = dataUrl.slice(commaIndex + 1).replace(/\s+/g, '');
  if (!base64) {
    return 0;
  }
  return Math.floor((base64.length * 3) / 4);
}

function extractInlineImageSources(html) {
  if (typeof html !== 'string' || !html) {
    return [];
  }
  const sources = [];
  NOTICE_INLINE_IMAGE_SRC_REGEX.lastIndex = 0;
  let match;
  while ((match = NOTICE_INLINE_IMAGE_SRC_REGEX.exec(html))) {
    if (match[1]) {
      sources.push(match[1]);
    }
  }
  NOTICE_INLINE_IMAGE_SRC_REGEX.lastIndex = 0;
  return sources;
}

function deriveAltTextFromFilename(filename) {
  if (typeof filename !== 'string') {
    return '';
  }
  const withoutExtension = filename.replace(/\.[^/.]+$/, '');
  return withoutExtension.replace(/[-_]+/g, ' ').trim();
}

function insertImageIntoNoticeEditor(source, { alt } = {}) {
  if (!generalChatEditor || !source) {
    return;
  }

  generalChatEditor.focus();
  const selection = window.getSelection();
  const image = document.createElement('img');
  image.src = source;
  image.alt = alt || '';

  let range = selection && selection.rangeCount ? selection.getRangeAt(0) : null;
  if (!range || !generalChatEditor.contains(range.commonAncestorContainer)) {
    generalChatEditor.appendChild(image);
  } else {
    range.deleteContents();
    range.insertNode(image);
  }

  const spacer = document.createElement('p');
  spacer.appendChild(document.createElement('br'));
  image.insertAdjacentElement('afterend', spacer);

  if (selection) {
    selection.removeAllRanges();
    range = document.createRange();
    range.setStart(spacer, 0);
    range.collapse(true);
    selection.addRange(range);
  }
}

function renderNoticeAttachmentsDraft() {
  if (!generalChatAttachments || !generalChatAttachmentsList) {
    return;
  }
  generalChatAttachmentsList.innerHTML = '';
  if (!noticeDraftAttachments.length) {
    generalChatAttachments.hidden = true;
    return;
  }

  generalChatAttachments.hidden = false;
  noticeDraftAttachments.forEach((attachment) => {
    const item = document.createElement('li');
    item.className = 'chat-attachment';
    item.dataset.attachmentId = attachment.id;

    if (attachment.type === 'image' && attachment.dataUrl) {
      const preview = document.createElement('img');
      preview.className = 'chat-attachment-preview';
      preview.src = attachment.dataUrl;
      preview.alt = attachment.name || 'Imagen adjunta';
      item.appendChild(preview);
    }

    const info = document.createElement('div');
    info.className = 'chat-attachment-info';

    const title = document.createElement('p');
    title.className = 'chat-attachment-name';
    title.textContent = attachment.name || 'Adjunto';
    info.appendChild(title);

    const meta = document.createElement('p');
    meta.className = 'chat-attachment-meta';
    meta.textContent = [attachment.contentType, formatFileSize(attachment.size)]
      .filter(Boolean)
      .join(' · ');
    info.appendChild(meta);

    item.appendChild(info);

    const actions = document.createElement('div');
    actions.className = 'chat-attachment-actions';
    const removeButton = document.createElement('button');
    removeButton.type = 'button';
    removeButton.className = 'chat-attachment-remove';
    removeButton.dataset.attachmentRemove = attachment.id;
    removeButton.textContent = 'Eliminar';
    actions.appendChild(removeButton);
    item.appendChild(actions);

    generalChatAttachmentsList.appendChild(item);
  });
}

function setNoticeFormBusy(isBusy) {
  if (generalChatToolbar) {
    generalChatToolbar.querySelectorAll('button').forEach((button) => {
      button.disabled = isBusy;
    });
  }
  if (generalChatEditor) {
    generalChatEditor.setAttribute('contenteditable', isBusy ? 'false' : 'true');
    if (!isBusy) {
      generalChatEditor.focus();
    }
  }
  if (generalChatAttachmentInput) {
    generalChatAttachmentInput.disabled = isBusy;
  }
  if (generalChatImageInput) {
    generalChatImageInput.disabled = isBusy;
  }
  const submitButton = generalChatForm?.querySelector('button[type="submit"]');
  if (submitButton) {
    submitButton.disabled = isBusy;
  }
}

function resetNoticeComposer() {
  if (generalChatEditor) {
    generalChatEditor.innerHTML = '';
  }
  if (generalChatInput) {
    generalChatInput.value = '';
  }
  if (generalChatAttachmentInput) {
    generalChatAttachmentInput.value = '';
  }
  if (generalChatImageInput) {
    generalChatImageInput.value = '';
  }
  noticeDraftAttachments = [];
  renderNoticeAttachmentsDraft();
}

function applyRichTextCommand(editor, command, { level, list, onAttachment, onImage } = {}) {
  if (!editor || !command) {
    return;
  }

  editor.focus();

  switch (command) {
    case 'bold':
    case 'italic':
    case 'underline':
      document.execCommand(command);
      break;
    case 'heading': {
      const headingLevel = level || '2';
      document.execCommand('formatBlock', false, `H${headingLevel}`);
      break;
    }
    case 'list':
      if (list === 'ordered') {
        document.execCommand('insertOrderedList');
      } else {
        document.execCommand('insertUnorderedList');
      }
      break;
    case 'quote':
      document.execCommand('formatBlock', false, 'blockquote');
      break;
    case 'link': {
      const url = window.prompt('Introduce la URL del enlace (incluye https://)');
      if (!url) {
        break;
      }
      let sanitizedUrl = url.trim();
      if (sanitizedUrl && !/^[a-zA-Z][a-zA-Z0-9+.-]*:/.test(sanitizedUrl)) {
        sanitizedUrl = `https://${sanitizedUrl}`;
      }
      try {
        const parsed = new URL(sanitizedUrl);
        if (!NOTICE_ALLOWED_SCHEMES.has(parsed.protocol)) {
          showGlobalMessage(
            'Introduce un enlace con un protocolo permitido (http, https, mailto o tel).',
            'error'
          );
          break;
        }
        document.execCommand('createLink', false, parsed.toString());
      } catch (error) {
        showGlobalMessage('No se pudo crear el enlace. Revisa la URL e inténtalo de nuevo.', 'error');
      }
      break;
    }
    case 'clear':
      document.execCommand('removeFormat');
      document.execCommand('formatBlock', false, 'p');
      break;
    case 'attachment':
      if (typeof onAttachment === 'function') {
        onAttachment();
      }
      break;
    case 'image':
      if (typeof onImage === 'function') {
        onImage();
      }
      break;
    default:
      break;
  }
}

function handleNoticeToolbarClick(event) {
  const button = event.target.closest('button[data-command]');
  if (!button || button.disabled) {
    return;
  }
  const command = button.dataset.command;
  if (!command) {
    return;
  }
  if (!generalChatEditor) {
    return;
  }

  event.preventDefault();
  applyRichTextCommand(generalChatEditor, command, {
    level: button.dataset.level,
    list: button.dataset.list,
    onAttachment: () => generalChatAttachmentInput?.click(),
    onImage: () => generalChatImageInput?.click(),
  });
}

function removeNoticeAttachment(attachmentId) {
  if (!attachmentId) return;
  noticeDraftAttachments = noticeDraftAttachments.filter((item) => item.id !== attachmentId);
  renderNoticeAttachmentsDraft();
}

async function handleNoticeAttachmentChange(event) {
  const fileList = Array.from(event.target.files || []);
  if (!fileList.length) {
    return;
  }

  const availableSlots = MAX_NOTICE_ATTACHMENTS - noticeDraftAttachments.length;
  if (availableSlots <= 0) {
    showGlobalMessage('Has alcanzado el número máximo de adjuntos por aviso (5).', 'error');
    event.target.value = '';
    return;
  }

  const selectedFiles = fileList.slice(0, availableSlots);
  const newAttachments = [];

  for (const file of selectedFiles) {
    if (file.size > MAX_NOTICE_ATTACHMENT_SIZE) {
      showGlobalMessage(
        `El archivo "${file.name}" supera el tamaño máximo permitido (3 MB).`,
        'error'
      );
      continue;
    }

    try {
      const dataUrl = await readFileAsDataUrl(file);
      newAttachments.push({
        id: `${Date.now()}-${Math.random().toString(16).slice(2)}`,
        name: file.name,
        size: file.size,
        contentType: file.type,
        dataUrl,
        type: file.type && file.type.toLowerCase().startsWith('image/') ? 'image' : 'file',
      });
    } catch (error) {
      showGlobalMessage(error.message, 'error');
    }
  }

  if (newAttachments.length) {
    noticeDraftAttachments = noticeDraftAttachments
      .concat(newAttachments)
      .slice(0, MAX_NOTICE_ATTACHMENTS);
    renderNoticeAttachmentsDraft();
  }

  event.target.value = '';
}

async function handleNoticeImageSelection(event) {
  const input = event.target;
  const [file] = Array.from(input.files || []);
  input.value = '';

  if (!file) {
    return;
  }

  const mime = (file.type || '').toLowerCase();
  const isImageFile = mime.startsWith('image/') || /\.(png|jpe?g|gif|webp|bmp|svg)$/i.test(file.name || '');
  if (!isImageFile) {
    showGlobalMessage('Selecciona un archivo de imagen válido.', 'error');
    return;
  }

  if (file.size > MAX_INLINE_NOTICE_IMAGE_SIZE) {
    showGlobalMessage(
      `La imagen supera el tamaño máximo permitido (${formatFileSize(MAX_INLINE_NOTICE_IMAGE_SIZE)}).`,
      'error'
    );
    return;
  }

  try {
    const dataUrl = await readFileAsDataUrl(file);
    insertImageIntoNoticeEditor(dataUrl, { alt: deriveAltTextFromFilename(file.name) });
  } catch (error) {
    showGlobalMessage(error.message, 'error');
  }
}

function renderChatMessages(messages = [], container, emptyMessage) {
  if (!container) return;
  container.innerHTML = '';
  if (!messages.length) {
    container.innerHTML = `<li class="empty-state">${emptyMessage}</li>`;
    return;
  }

  const currentUserId = normalizeId(state.user);

  messages.forEach((message) => {
    const item = document.createElement('li');
    item.className = 'chat-message';
    const senderId = normalizeId(message.sender);
    if (senderId && senderId === currentUserId) {
      item.classList.add('mine');
    }

    const header = document.createElement('div');
    header.className = 'chat-message-header';
    const name = document.createElement('strong');
    name.textContent = message.sender?.fullName || message.sender?.email || 'Participante';
    header.appendChild(name);

    const senderRoles = message.sender?.roles || message.sender?.role;
    if (senderRoles) {
      const role = document.createElement('span');
      role.className = 'tag';
      role.textContent = formatRoles(senderRoles);
      header.appendChild(role);
    }

    const timestamp = document.createElement('time');
    timestamp.dateTime = message.createdAt || '';
    timestamp.textContent = formatChatTimestamp(message.createdAt);
    header.appendChild(timestamp);

    const body = document.createElement('div');
    const sanitizedRich = sanitizeNoticeHtml(message.richContent || '');
    const plainContent = (message.content || '').trim();

    if (sanitizedRich) {
      const richContainer = document.createElement('div');
      richContainer.className = 'chat-message-rich';
      richContainer.innerHTML = sanitizedRich;
      body.appendChild(richContainer);
    } else if (plainContent) {
      const paragraph = document.createElement('p');
      paragraph.textContent = plainContent;
      body.appendChild(paragraph);
    }

    if (Array.isArray(message.attachments) && message.attachments.length) {
      const attachmentsWrapper = document.createElement('div');
      attachmentsWrapper.className = 'chat-message-attachments';

      message.attachments.forEach((attachment) => {
        if (!attachment) return;
        const attachmentBlock = document.createElement('div');
        attachmentBlock.className = 'chat-message-attachment';
        const source = attachment.dataUrl || attachment.url;
        const filename = attachment.filename || attachment.description || 'Adjunto';
        const attachmentType = (attachment.type || '').toLowerCase();
        const isImage =
          attachmentType === 'image' || (attachment.contentType || '').toLowerCase().startsWith('image/');

        if (isImage && source) {
          const img = document.createElement('img');
          img.src = source;
          img.alt = filename;
          attachmentBlock.appendChild(img);
        }

        if (source) {
          const link = document.createElement('a');
          link.href = source;
          link.textContent = filename;
          link.target = '_blank';
          link.rel = 'noopener noreferrer';
          if (attachment.filename) {
            link.download = attachment.filename;
          }
          attachmentBlock.appendChild(link);
        } else if (!attachmentBlock.childElementCount) {
          const label = document.createElement('span');
          label.textContent = filename;
          attachmentBlock.appendChild(label);
        }

        attachmentsWrapper.appendChild(attachmentBlock);
      });

      if (attachmentsWrapper.childElementCount) {
        body.appendChild(attachmentsWrapper);
      }
    }

    item.appendChild(header);
    if (body.childElementCount) {
      item.appendChild(body);
    }

    container.appendChild(item);
  });
}

function renderGeneralChat() {
  renderChatMessages(
    Array.isArray(state.generalChatMessages) ? state.generalChatMessages : [],
    generalChatMessagesList,
    'Todavía no hay avisos publicados.'
  );
}

function renderDirectChat() {}

function populateChatParticipants() {}

function renderRules() {
  const renderSection = (element, regulation, emptyMessage) => {
    if (!element) return;

    const html = getRegulationHtml(regulation);
    const sanitized = typeof html === 'string' ? html.trim() : '';

    if (!sanitized) {
      element.innerHTML = `<p class="empty-state">${emptyMessage}</p>`;
      return;
    }

    element.innerHTML = sanitized;
  };

  renderSection(
    leagueRulesContent,
    state.club?.regulation,
    'Aún no se ha configurado el reglamento de la liga.'
  );
  renderSection(
    tournamentRulesContent,
    state.club?.tournamentRegulation,
    'Aún no se ha configurado el reglamento de torneos.'
  );
}

renderRules();

function setRankingStatusMessage(type, message) {
  if (!rankingStatus) {
    return;
  }
  setStatusMessage(rankingStatus, type, message);
}

function getCategoryById(categoryId) {
  if (!categoryId) return null;
  const categories = Array.isArray(state.categories) ? state.categories : [];
  return (
    categories.find((category) => {
      const id = normalizeId(category);
      return id && id === categoryId;
    }) || null
  );
}

function renderRankingSections() {
  if (!rankingCategoryList) return;

  const categories = Array.isArray(state.categories) ? state.categories.slice() : [];
  const filters = ensureRankingFilters();
  const leagueFilter = filters.league || '';
  const filteredCategories = leagueFilter
    ? categories.filter((category) => normalizeId(category?.league) === leagueFilter)
    : categories;
  rankingCategoryList.innerHTML = '';

  if (!categories.length) {
    rankingEmpty.hidden = false;
    rankingEmpty.textContent = isAdmin()
      ? 'Crea una categoría para ver el ranking.'
      : 'Aún no hay categorías registradas.';
    setRankingStatusMessage('', '');
    state.selectedCategoryId = null;
    return;
  }

  if (!filteredCategories.length) {
    rankingEmpty.hidden = false;
    rankingEmpty.textContent = 'No hay categorías con ranking para la liga seleccionada.';
    setRankingStatusMessage('', '');
    state.selectedCategoryId = null;
    return;
  }

  rankingEmpty.hidden = true;

  let anyLoading = false;
  let anyError = false;

  const sortedCategories = filteredCategories
    .slice()
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'));

  const availableIds = sortedCategories
    .map((category) => normalizeId(category))
    .filter(Boolean);

  if (!availableIds.includes(state.selectedCategoryId)) {
    state.selectedCategoryId = availableIds[0] || null;
  }

  sortedCategories.forEach((category) => {
      const categoryId = normalizeId(category);
      if (!categoryId) {
        return;
      }

      const record = state.rankingsByCategory.get(categoryId);
      const isLoading = record ? record.loading : state.rankingsLoading;
      const rankingData = record?.data || null;
      const errorMessage = record?.error || null;

      if (isLoading) {
        anyLoading = true;
      }
      if (errorMessage) {
        anyError = true;
      }

      const section = document.createElement('section');
      section.className = 'ranking-category';
      section.dataset.categoryId = categoryId;

      const header = document.createElement('div');
      header.className = 'ranking-category__header';

      const title = document.createElement('div');
      title.className = 'ranking-category__title';
      const categoryColor = getCategoryColor(category);
      if (categoryColor) {
        const indicator = createCategoryColorIndicator(categoryColor, category.name);
        if (indicator) {
          title.appendChild(indicator);
        }
      }
      const nameSpan = document.createElement('span');
      nameSpan.textContent = category.name || 'Categoría';
      title.appendChild(nameSpan);
      header.appendChild(title);

      const meta = document.createElement('div');
      meta.className = 'ranking-category__meta';

      const genderLabel = translateGender(category.gender);
      if (genderLabel) {
        meta.appendChild(document.createElement('span')).textContent = genderLabel;
      }

      if (category.skillLevel) {
        meta.appendChild(document.createElement('span')).textContent =
          formatSkillLevelLabel(category.skillLevel);
      }

      const statusValue = category.status || 'inscripcion';
      const statusLabel = CATEGORY_STATUS_LABELS[statusValue] || '';
      if (statusLabel) {
        meta.appendChild(document.createElement('span')).textContent = statusLabel;
      }

      const league = resolveLeague(category.league);
      if (league?.name) {
        const leagueParts = [league.name];
        if (league.year) {
          leagueParts.push(String(league.year));
        }
        meta.appendChild(document.createElement('span')).textContent = leagueParts.join(' · ');
      }

      const participantCount = rankingData?.ranking?.length ?? Number(category.enrollmentCount || 0);
      meta.appendChild(document.createElement('span')).textContent = `Participantes: ${participantCount}`;

      header.appendChild(meta);
      section.appendChild(header);

      if (isLoading) {
        const loadingMessage = document.createElement('p');
        loadingMessage.className = 'ranking-category__empty';
        loadingMessage.textContent = 'Cargando ranking...';
        section.appendChild(loadingMessage);
        rankingCategoryList.appendChild(section);
        return;
      }

      if (errorMessage) {
        const errorParagraph = document.createElement('p');
        errorParagraph.className = 'ranking-category__empty';
        errorParagraph.textContent = errorMessage;
        section.appendChild(errorParagraph);
        rankingCategoryList.appendChild(section);
        return;
      }

      const rankingEntries = Array.isArray(rankingData?.ranking) ? rankingData.ranking : [];
      if (!rankingEntries.length) {
        const emptyParagraph = document.createElement('p');
        emptyParagraph.className = 'ranking-category__empty';
        emptyParagraph.textContent = 'Aún no hay resultados para esta categoría.';
        section.appendChild(emptyParagraph);
        rankingCategoryList.appendChild(section);
        return;
      }

      const tableWrapper = document.createElement('div');
      tableWrapper.className = 'ranking-category__table';

      const scrollContainer = document.createElement('div');
      scrollContainer.className = 'ranking-category__table-scroll table-scroll';

      const table = document.createElement('table');
      table.className = 'table';

      const thead = document.createElement('thead');
      thead.innerHTML = `
        <tr>
          <th scope="col">Pos.</th>
          <th scope="col">Jugador</th>
          <th scope="col">Puntos</th>
          <th scope="col">PJ</th>
          <th scope="col">G</th>
          <th scope="col">P</th>
          <th scope="col">Juegos</th>
        </tr>
      `;
      table.appendChild(thead);

      const tbody = document.createElement('tbody');
      rankingEntries.forEach((entry, index) => {
        const row = document.createElement('tr');

        const positionCell = document.createElement('td');
        const podiumEmoji = getPodiumEmoji(index);
        positionCell.textContent = podiumEmoji ? `${index + 1} ${podiumEmoji}` : index + 1;
        row.appendChild(positionCell);

        const playerCell = document.createElement('td');
        const playerElement = buildPlayerCell(entry.player, { size: 'sm' });
        const infoContainer = playerElement?.querySelector('.player-cell__info');
        const movementBadge = createMovementBadge(entry);
        if (movementBadge && infoContainer) {
          movementBadge.classList.add('movement-badge--inline');
          infoContainer.appendChild(movementBadge);
        } else if (movementBadge) {
          playerElement.appendChild(movementBadge);
        }
        playerCell.appendChild(playerElement);
        row.appendChild(playerCell);

        row.appendChild(document.createElement('td')).textContent = entry.points ?? 0;
        row.appendChild(document.createElement('td')).textContent = entry.matchesPlayed ?? 0;
        row.appendChild(document.createElement('td')).textContent = entry.wins ?? 0;
        row.appendChild(document.createElement('td')).textContent = entry.losses ?? 0;
        row.appendChild(document.createElement('td')).textContent = entry.gamesWon ?? 0;

        tbody.appendChild(row);
      });

      table.appendChild(tbody);
      scrollContainer.appendChild(table);
      tableWrapper.appendChild(scrollContainer);
      section.appendChild(tableWrapper);

      rankingCategoryList.appendChild(section);
    });

  if (anyLoading) {
    setRankingStatusMessage('info', 'Actualizando rankings...');
  } else if (anyError) {
    setRankingStatusMessage(
      'error',
      'No fue posible cargar algunos rankings. Intenta de nuevo más tarde.'
    );
  } else {
    setRankingStatusMessage('', '');
  }
}

async function fetchCategoryRanking(categoryId, { forceReload = false, suppressError = false } = {}) {
  const normalizedId = typeof categoryId === 'string' ? categoryId : normalizeId(categoryId);
  if (!normalizedId) {
    return null;
  }

  const currentRecord = state.rankingsByCategory.get(normalizedId);
  if (!forceReload && currentRecord && currentRecord.data && !currentRecord.error) {
    return currentRecord.data;
  }

  state.rankingsByCategory.set(normalizedId, {
    loading: true,
    data: currentRecord?.data || null,
    error: null,
  });
  renderRankingSections();

  try {
    const response = await request(`/categories/${normalizedId}/ranking`);
    state.rankingsByCategory.set(normalizedId, {
      loading: false,
      data: response,
      error: null,
    });
    renderRankingSections();
    return response;
  } catch (error) {
    const message = error.message || 'No fue posible cargar el ranking.';
    state.rankingsByCategory.set(normalizedId, {
      loading: false,
      data: null,
      error: message,
    });
    renderRankingSections();
    if (suppressError) {
      return null;
    }
    throw error;
  }
}

async function refreshAllRankings({ forceReload = false } = {}) {
  if (!rankingCategoryList) return;

  const categories = Array.isArray(state.categories) ? state.categories : [];
  const categoryMap = new Map();
  const categoryIds = categories
    .map((category) => {
      const id = normalizeId(category);
      if (id) {
        categoryMap.set(id, category);
      }
      return id;
    })
    .filter(Boolean);

  Array.from(state.rankingsByCategory.keys()).forEach((storedId) => {
    if (!categoryIds.includes(storedId)) {
      state.rankingsByCategory.delete(storedId);
    }
  });

  if (!categoryIds.length) {
    state.rankingsLoading = false;
    rankingCategoryList.innerHTML = '';
    rankingEmpty.hidden = false;
    rankingEmpty.textContent = isAdmin()
      ? 'Crea una categoría para ver el ranking.'
      : 'Aún no hay categorías registradas.';
    setRankingStatusMessage('', '');
    state.selectedCategoryId = null;
    return;
  }

  const filters = ensureRankingFilters();
  const leagueFilter = filters.league || '';
  const filteredCategoryIds = leagueFilter
    ? categoryIds.filter((categoryId) => {
        const category = categoryMap.get(categoryId);
        return normalizeId(category?.league) === leagueFilter;
      })
    : categoryIds;

  if (filteredCategoryIds.length) {
    if (!state.selectedCategoryId || !filteredCategoryIds.includes(state.selectedCategoryId)) {
      state.selectedCategoryId = filteredCategoryIds[0] || null;
    }
  } else if (leagueFilter) {
    state.selectedCategoryId = null;
  } else if (!state.selectedCategoryId || !categoryIds.includes(state.selectedCategoryId)) {
    state.selectedCategoryId = categoryIds[0] || null;
  }

  const fetchTargets = categoryIds.filter((categoryId) => {
    if (forceReload) {
      return true;
    }
    const record = state.rankingsByCategory.get(categoryId);
    return !(record && record.data && Array.isArray(record.data.ranking));
  });

  if (!fetchTargets.length) {
    state.rankingsLoading = false;
    renderRankingSections();
    setRankingStatusMessage('', '');
    return;
  }

  state.rankingsLoading = true;
  renderRankingSections();
  setRankingStatusMessage('info', 'Actualizando rankings...');

  for (const categoryId of fetchTargets) {
    await fetchCategoryRanking(categoryId, { forceReload, suppressError: true });
  }

  state.rankingsLoading = false;
  renderRankingSections();

  const hasErrors = fetchTargets.some((categoryId) => {
    const record = state.rankingsByCategory.get(categoryId);
    return Boolean(record?.error);
  });

  if (hasErrors) {
    setRankingStatusMessage(
      'error',
      'No fue posible cargar algunos rankings. Intenta de nuevo más tarde.'
    );
  } else {
    setRankingStatusMessage('', '');
  }
}

async function printRankingSheet(categoryId) {
  const normalizedId = typeof categoryId === 'string' ? categoryId : normalizeId(categoryId);
  const targetId = normalizedId || state.selectedCategoryId;

  if (!targetId) {
    throw new Error('Selecciona una categoría con ranking disponible.');
  }

  let record = state.rankingsByCategory.get(targetId);
  if (!record || !record.data || !Array.isArray(record.data.ranking)) {
    try {
      const data = await fetchCategoryRanking(targetId, { forceReload: false });
      record = { data };
    } catch (error) {
      throw new Error(error.message || 'No fue posible cargar el ranking.');
    }
  }

  const rankingData = record?.data;
  const rankingEntries = Array.isArray(rankingData?.ranking) ? rankingData.ranking : [];
  if (!rankingEntries.length) {
    throw new Error('Esta categoría no tiene ranking disponible.');
  }

  const category = rankingData.category || getCategoryById(targetId);
  const categoryName = category?.name || 'Ranking de la liga';

  const printWindow = window.open('', '_blank', 'width=1024,height=768');
  if (!printWindow) {
    throw new Error('No fue posible abrir la vista de impresión. Permite las ventanas emergentes.');
  }

  const now = new Date();
  const formattedDate = new Intl.DateTimeFormat('es-ES', {
    dateStyle: 'full',
    timeStyle: 'short',
  }).format(now);

  const rows = rankingEntries
    .map((entry, index) => {
      const playerMarkup = buildPlayerCellMarkup(entry.player);
      const podiumEmoji = getPodiumEmoji(index);
      const positionLabel = podiumEmoji ? `${index + 1} ${podiumEmoji}` : index + 1;

      return `
        <tr>
          <td>${positionLabel}</td>
          <td>${playerMarkup}</td>
          <td>${entry.points ?? 0}</td>
          <td>${entry.matchesPlayed ?? 0}</td>
          <td>${entry.wins ?? 0}</td>
          <td>${entry.losses ?? 0}</td>
          <td>${entry.gamesWon ?? 0}</td>
        </tr>
      `;
    })
    .join('');

  printWindow.document.write(`<!DOCTYPE html>
  <html lang="es">
    <head>
      <meta charset="utf-8" />
      <title>Ranking ${escapeHtml(categoryName)}</title>
      <style>
        body { font-family: 'Segoe UI', Roboto, sans-serif; margin: 32px; background: #f7f8fb; color: #1f2933; }
        h1 { margin: 0 0 8px; font-size: 28px; }
        p.subtitle { margin: 0 0 24px; color: #52606d; }
        table { width: 100%; border-collapse: collapse; background: #fff; border-radius: 16px; overflow: hidden; box-shadow: 0 24px 48px rgba(15, 23, 42, 0.12); }
        thead th { text-align: left; padding: 16px; background: linear-gradient(90deg, #59a4ff, #7ac8ff); color: #fff; font-weight: 600; font-size: 14px; letter-spacing: 0.08em; text-transform: uppercase; }
        tbody td { padding: 14px 16px; border-bottom: 1px solid #e4ecf7; font-size: 15px; vertical-align: middle; }
        tbody tr:nth-child(even) { background: #f9fbff; }
        tbody tr:last-child td { border-bottom: none; }
        .player-cell { display: flex; align-items: center; gap: 14px; }
        .player-avatar { width: 48px; height: 48px; border-radius: 50%; background: #e2e8f0; color: #1f2937; display: flex; align-items: center; justify-content: center; font-weight: 600; font-size: 18px; text-transform: uppercase; overflow: hidden; }
        .player-avatar img { width: 100%; height: 100%; object-fit: cover; }
        .player-avatar--placeholder { background: #cbd5f5; color: #1e293b; }
        .player-cell__info { display: flex; flex-direction: column; gap: 4px; }
        .player-cell__name { font-weight: 600; font-size: 16px; }
        .player-cell__meta { color: #64748b; font-size: 13px; }
        @media print { body { margin: 16px; } table { box-shadow: none; } }
      </style>
    </head>
    <body>
      <h1>Ranking · ${escapeHtml(categoryName)}</h1>
      <p class="subtitle">Actualizado el ${escapeHtml(formattedDate)}</p>
      <table>
        <thead>
          <tr>
            <th>Nº Ranking</th>
            <th>Jugador</th>
            <th>Puntos</th>
            <th>Jugados</th>
            <th>Victorias</th>
            <th>Derrotas</th>
            <th>Juegos ganados</th>
          </tr>
        </thead>
        <tbody>
          ${rows}
        </tbody>
      </table>
      <script>window.addEventListener('load', () => { window.print(); });</script>
    </body>
  </html>`);
  printWindow.document.close();
}

async function openRankingPrintModal(defaultCategoryId = state.selectedCategoryId) {
  if (!rankingCategoryList) return;

  const categories = Array.isArray(state.categories) ? state.categories : [];
  const leagues = Array.isArray(state.leagues) ? state.leagues.slice() : [];

  if (!leagues.length) {
    showGlobalMessage('No hay ligas disponibles para imprimir.', 'info');
    return;
  }

  if (!categories.length) {
    showGlobalMessage('No hay categorías disponibles para imprimir.', 'info');
    return;
  }

  const rankingFilters = ensureRankingFilters();
  const normalizedDefaultCategoryId = defaultCategoryId ? normalizeId(defaultCategoryId) : '';
  const defaultLeagueFromCategory = normalizedDefaultCategoryId
    ? getLeagueIdForCategory(normalizedDefaultCategoryId)
    : '';

  const form = document.createElement('form');
  form.className = 'form';

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const leagueLabel = document.createElement('label');
  leagueLabel.textContent = 'Liga';
  const leagueSelect = document.createElement('select');
  leagueSelect.name = 'leagueId';
  leagueSelect.required = true;

  const categoryLabel = document.createElement('label');
  categoryLabel.textContent = 'Categoría';
  const categorySelect = document.createElement('select');
  categorySelect.name = 'categoryId';
  categorySelect.required = true;

  let submitButton = null;

  const updateCategoryOptions = (leagueId, { preserveSelection = false } = {}) => {
    const previousValue = preserveSelection ? categorySelect.value : '';
    categorySelect.innerHTML = '<option value="">Selecciona una categoría</option>';

    const options = getLeagueCategories(leagueId)
      .slice()
      .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'));

    const availableIds = new Set();
    options.forEach((category) => {
      const categoryId = normalizeId(category);
      if (!categoryId || availableIds.has(categoryId)) {
        return;
      }
      availableIds.add(categoryId);
      const option = document.createElement('option');
      option.value = categoryId;
      option.textContent = category.name || 'Categoría';
      categorySelect.appendChild(option);
    });

    let nextValue = '';
    if (preserveSelection && previousValue && availableIds.has(previousValue)) {
      nextValue = previousValue;
    } else if (normalizedDefaultCategoryId && availableIds.has(normalizedDefaultCategoryId)) {
      nextValue = normalizedDefaultCategoryId;
    } else if (availableIds.size) {
      nextValue = availableIds.values().next().value;
    }

    if (nextValue) {
      categorySelect.value = nextValue;
    } else {
      categorySelect.value = '';
    }

    const hasOptions = Boolean(availableIds.size);
    categorySelect.disabled = !hasOptions;

    if (submitButton) {
      submitButton.disabled = !hasOptions;
    }

    if (!hasOptions) {
      setStatusMessage(status, 'info', 'Esta liga no tiene categorías disponibles.');
    } else {
      setStatusMessage(status, '', '');
    }

    return { hasOptions, nextValue };
  };

  leagueSelect.innerHTML = '<option value="">Selecciona una liga</option>';

  const toChronoTimestamp = (value) => {
    if (!value) {
      return Number.POSITIVE_INFINITY;
    }
    const date = value instanceof Date ? value : new Date(value);
    const time = date.getTime();
    return Number.isFinite(time) ? time : Number.POSITIVE_INFINITY;
  };

  const getLeagueChronoValue = (league) => {
    if (!league || typeof league !== 'object') {
      return Number.POSITIVE_INFINITY;
    }

    const startTimestamp = toChronoTimestamp(league.startDate);
    if (Number.isFinite(startTimestamp)) {
      return startTimestamp;
    }

    const numericYear = Number(league.year);
    if (Number.isFinite(numericYear)) {
      const normalizedYear = Math.trunc(numericYear);
      const yearDate = new Date(normalizedYear, 0, 1);
      const yearTimestamp = yearDate.getTime();
      if (Number.isFinite(yearTimestamp)) {
        return yearTimestamp;
      }
    }

    const createdTimestamp = toChronoTimestamp(league.createdAt);
    if (Number.isFinite(createdTimestamp)) {
      return createdTimestamp;
    }

    return Number.POSITIVE_INFINITY;
  };

  leagues.sort((a, b) => {
    const chronoDiff = getLeagueChronoValue(a) - getLeagueChronoValue(b);
    if (chronoDiff !== 0) {
      return chronoDiff;
    }
    return formatLeagueOptionLabel(a).localeCompare(formatLeagueOptionLabel(b), 'es', {
      sensitivity: 'base',
    });
  });

  const availableLeagueIds = new Set();
  leagues.forEach((league) => {
    const leagueId = normalizeId(league);
    if (!leagueId || availableLeagueIds.has(leagueId)) {
      return;
    }
    availableLeagueIds.add(leagueId);
    const option = document.createElement('option');
    option.value = leagueId;
    option.textContent = formatLeagueOptionLabel(league);
    leagueSelect.appendChild(option);
  });

  let initialLeagueId = defaultLeagueFromCategory || rankingFilters.league || '';
  if (!initialLeagueId || !availableLeagueIds.has(initialLeagueId)) {
    initialLeagueId = availableLeagueIds.values().next()?.value || '';
  }

  if (initialLeagueId) {
    leagueSelect.value = initialLeagueId;
    rankingFilters.league = initialLeagueId;
  }

  leagueLabel.appendChild(leagueSelect);
  form.appendChild(leagueLabel);

  categoryLabel.appendChild(categorySelect);
  form.appendChild(categoryLabel);

  const actions = document.createElement('div');
  actions.className = 'form-actions';

  submitButton = document.createElement('button');
  submitButton.type = 'submit';
  submitButton.className = 'primary';
  submitButton.textContent = 'Imprimir';
  actions.appendChild(submitButton);

  const cancelButton = document.createElement('button');
  cancelButton.type = 'button';
  cancelButton.className = 'ghost';
  cancelButton.dataset.action = 'cancel';
  cancelButton.textContent = 'Cancelar';
  actions.appendChild(cancelButton);

  form.appendChild(actions);

  const { hasOptions } = updateCategoryOptions(initialLeagueId);
  submitButton.disabled = !hasOptions;

  leagueSelect.addEventListener('change', () => {
    const filters = ensureRankingFilters();
    filters.league = leagueSelect.value || '';
    updateCategoryOptions(leagueSelect.value);
  });

  categorySelect.addEventListener('change', () => {
    if (submitButton) {
      submitButton.disabled = !categorySelect.value;
    }
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const leagueId = leagueSelect.value;
    if (!leagueId) {
      setStatusMessage(status, 'error', 'Selecciona una liga.');
      return;
    }

    const categoryId = categorySelect.value;
    if (!categoryId) {
      setStatusMessage(status, 'error', 'Selecciona una categoría.');
      return;
    }

    submitButton.disabled = true;
    setStatusMessage(status, 'info', 'Preparando vista de impresión...');
    try {
      const filters = ensureRankingFilters();
      filters.league = leagueId;
      await printRankingSheet(categoryId);
      closeModal();
      setStatusMessage(status, '', '');
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    } finally {
      submitButton.disabled = !categorySelect.value;
    }
  });

  cancelButton.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  openModal({
    title: 'Imprimir ranking',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}


function populateAdminSelects() {
  if (!isAdmin()) return;

  const categories = Array.isArray(state.categories) ? state.categories : [];
  const players = Array.isArray(state.players) ? state.players : [];
  const playerOptions = players.filter((player) => entityHasRole(player, 'player'));

  const buildCategoryOptions = (select, placeholder = 'Selecciona una categoría') => {
    if (!select) return;
    const previous = select.value;
    select.innerHTML = placeholder ? `<option value="">${placeholder}</option>` : '';
    categories.forEach((category) => {
      const option = document.createElement('option');
      option.value = category._id || category.id;
      const league = resolveLeague(category.league);
      const leagueLabel = league
        ? ` · ${league.name}${league.year ? ` · ${league.year}` : ''}`
        : '';
      option.textContent = `${category.name} (${translateGender(category.gender)})${leagueLabel}`;
      select.appendChild(option);
    });
    if (previous) {
      select.value = previous;
    }
  };

  buildCategoryOptions(adminEnrollmentCategory, 'Selecciona una categoría');
  buildCategoryOptions(adminMatchCategory, '');
  buildCategoryOptions(playerDirectoryCategory, 'Todas las categorías');

  if (adminEnrollmentPlayer) {
    const previous = adminEnrollmentPlayer.value;
    adminEnrollmentPlayer.innerHTML = '<option value="">Selecciona un jugador</option>';
    playerOptions.forEach((player) => {
      const option = document.createElement('option');
      option.value = player._id || player.id;
      option.textContent = player.fullName;
      adminEnrollmentPlayer.appendChild(option);
    });
    if (
      previous &&
      Array.from(adminEnrollmentPlayer.options).some((option) => option.value === previous)
    ) {
      adminEnrollmentPlayer.value = previous;
    }
  }

  const populateMatchPlayers = (select) => {
    if (!select) return;
    const previous = select.value;
    select.innerHTML = '<option value="">Selecciona un jugador</option>';
    playerOptions.forEach((player) => {
      const option = document.createElement('option');
      option.value = player._id || player.id;
      option.textContent = player.fullName;
      select.appendChild(option);
    });
    if (previous) {
      select.value = previous;
    }
  };

  populateMatchPlayers(adminMatchPlayer1);
  populateMatchPlayers(adminMatchPlayer2);

  if (adminEnrollmentList) {
    const selectedCategory = adminEnrollmentCategory?.value || '';
    renderEnrollmentList(selectedCategory);
  }
}

function renderAdminCategoryList() {
  if (!adminCategoryList) return;
  adminCategoryList.innerHTML = '';

  if (!state.categories.length) {
    adminCategoryList.innerHTML = '<li class="empty-state">Aún no hay categorías.</li>';
    return;
  }

  state.categories
    .slice()
    .sort((a, b) => a.name.localeCompare(b.name, 'es'))
    .forEach((category) => {
      const item = document.createElement('li');
      const categoryColor = getCategoryColor(category);
      if (categoryColor) {
        applyCategoryColorStyles(item, categoryColor, { backgroundAlpha: 0.14, borderAlpha: 0.3 });
      }
      const title = document.createElement('strong');
      title.textContent = category.name;
      if (categoryColor) {
        const indicator = createCategoryColorIndicator(categoryColor, category.name);
        if (indicator) {
          title.classList.add('with-category-color');
          title.prepend(indicator);
        }
      }
      item.appendChild(title);

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.appendChild(document.createElement('span')).textContent = translateGender(category.gender);
      if (category.skillLevel) {
        meta.appendChild(document.createElement('span')).textContent = category.skillLevel;
      }
      item.appendChild(meta);

      const minimumAgeValue = Number(category.minimumAge);
      if (Number.isFinite(minimumAgeValue) && minimumAgeValue > 0) {
        const ageMeta = document.createElement('div');
        ageMeta.className = 'meta';
        const parts = [`Edad mínima: ${minimumAgeValue} años`];
        if (category.minimumAgeReferenceYear) {
          parts.push(`Referencia: ${category.minimumAgeReferenceYear}`);
        }
        ageMeta.textContent = parts.join(' · ');
        item.appendChild(ageMeta);
      }

      const categoryLeague = resolveLeague(category.league);
      if (categoryLeague) {
        const leagueMeta = document.createElement('div');
        leagueMeta.className = 'meta meta-league-link';
        leagueMeta.appendChild(document.createElement('span')).textContent = 'Liga';
        const leagueTag = document.createElement('span');
        leagueTag.className = 'tag league-tag';
        leagueTag.textContent = categoryLeague.year
          ? `${categoryLeague.name} · ${categoryLeague.year}`
          : categoryLeague.name || 'Liga';
        if (categoryLeague.status === 'cerrada') {
          leagueTag.classList.add('league-tag--closed');
        }
        leagueMeta.appendChild(leagueTag);
        item.appendChild(leagueMeta);
      }

      const dates = [];
      if (category.startDate) {
        dates.push(`Inicio: ${formatDateInput(category.startDate)}`);
      }
      if (category.endDate) {
        dates.push(`Fin: ${formatDateInput(category.endDate)}`);
      }
      if (dates.length) {
        const dateMeta = document.createElement('div');
        dateMeta.className = 'meta';
        dateMeta.textContent = dates.join(' · ');
        item.appendChild(dateMeta);
      }

      const actions = document.createElement('div');
      actions.className = 'actions';
      const editButton = document.createElement('button');
      editButton.type = 'button';
      editButton.className = 'secondary';
      editButton.textContent = 'Editar';
      editButton.dataset.categoryId = category._id || category.id;
      editButton.dataset.action = 'edit';
      actions.appendChild(editButton);

      const deleteButton = document.createElement('button');
      deleteButton.type = 'button';
      deleteButton.className = 'danger';
      deleteButton.textContent = 'Eliminar';
      deleteButton.dataset.categoryId = category._id || category.id;
      deleteButton.dataset.action = 'delete';
      actions.appendChild(deleteButton);
      item.appendChild(actions);

      adminCategoryList.appendChild(item);
    });
}

function renderAdminPlayerList() {
  if (!adminPlayerList) return;
  adminPlayerList.innerHTML = '';

  if (!state.players.length) {
    adminPlayerList.innerHTML = '<li class="empty-state">No hay usuarios registrados.</li>';
    return;
  }

  state.players
    .slice()
    .sort((a, b) => (a.fullName || '').localeCompare(b.fullName || '', 'es'))
    .forEach((player) => {
      const item = document.createElement('li');
      const header = buildPlayerCell(player, { size: 'sm' });
      item.appendChild(header);

      const meta = document.createElement('div');
      meta.className = 'meta';
      meta.appendChild(document.createElement('span')).textContent = player.email;
      meta.appendChild(document.createElement('span')).textContent = formatRoles(player.roles || player.role);
      if (player.phone) {
        meta.appendChild(document.createElement('span')).textContent = player.phone;
      }
      if (player.birthDate) {
        meta.appendChild(document.createElement('span')).textContent = `Nacimiento: ${formatShortDate(
          player.birthDate
        )}`;
      }
      item.appendChild(meta);

      const actions = document.createElement('div');
      actions.className = 'actions';
      const editButton = document.createElement('button');
      editButton.type = 'button';
      editButton.className = 'secondary';
      editButton.textContent = 'Editar';
      editButton.dataset.playerId = player._id || player.id;
      actions.appendChild(editButton);
      item.appendChild(actions);

      adminPlayerList.appendChild(item);
    });
}

function renderAdminMatchList(matches = []) {
  if (!adminMatchList) return;
  adminMatchList.innerHTML = '';

  const sorted = Array.isArray(matches)
    ? [...matches].sort((a, b) => {
        const dateA = a.scheduledAt ? new Date(a.scheduledAt).getTime() : Infinity;
        const dateB = b.scheduledAt ? new Date(b.scheduledAt).getTime() : Infinity;
        return dateA - dateB;
      })
    : [];

  if (adminMatchSelect) {
    const current = adminMatchSelect.value;
    adminMatchSelect.innerHTML = '<option value="">Elige un partido pendiente o programado</option>';
    sorted.forEach((match) => {
      const option = document.createElement('option');
      option.value = match._id || match.id;
      const players = Array.isArray(match.players)
        ? match.players.map((player) => player.fullName || 'Jugador').join(' vs ')
        : 'Partido';
      const dateLabel = match.scheduledAt ? formatDate(match.scheduledAt) : 'Sin fecha';
      option.textContent = `${players} · ${dateLabel}`;
      adminMatchSelect.appendChild(option);
    });
    if (current) {
      adminMatchSelect.value = current;
    }
  }

  if (!sorted.length) {
    adminMatchList.innerHTML = '<li class="empty-state">No hay partidos activos.</li>';
    return;
  }

  sorted.forEach((match) => {
    const item = document.createElement('li');
    const categoryColor = match.category ? getCategoryColor(match.category) : '';
    const title = document.createElement('strong');
    const players = Array.isArray(match.players)
      ? match.players.map((player) => player.fullName || 'Jugador').join(' vs ')
      : 'Partido';
    title.textContent = players;
    if (categoryColor) {
      const indicator = createCategoryColorIndicator(categoryColor, match.category?.name);
      if (indicator) {
        title.classList.add('with-category-color');
        title.prepend(indicator);
      }
    }
    item.appendChild(title);

    const meta = document.createElement('div');
    meta.className = 'meta';
    meta.appendChild(document.createElement('span')).textContent = formatDate(match.scheduledAt);
    if (match.category?.name) {
      const categoryTag = document.createElement('span');
      categoryTag.className = 'tag match-category-tag';
      categoryTag.textContent = match.category.name;
      applyCategoryTagColor(categoryTag, categoryColor);
      meta.appendChild(categoryTag);
    }
    const statusTag = document.createElement('span');
    statusTag.className = `tag status-${match.status}`;
    statusTag.textContent = STATUS_LABELS[match.status] || match.status;
    meta.appendChild(statusTag);
    item.appendChild(meta);

    if (categoryColor) {
      applyCategoryColorStyles(item, categoryColor, { shadowAlpha: 0.18 });
    }

    const actions = document.createElement('div');
    actions.className = 'actions';
    const editButton = document.createElement('button');
    editButton.type = 'button';
    editButton.className = 'secondary';
    editButton.textContent = 'Editar';
    editButton.dataset.matchId = match._id || match.id;
    actions.appendChild(editButton);

    if (match.status !== 'completado') {
      const deleteButton = document.createElement('button');
      deleteButton.type = 'button';
      deleteButton.className = 'danger';
      deleteButton.textContent = 'Eliminar';
      deleteButton.dataset.matchId = match._id || match.id;
      deleteButton.dataset.action = 'delete';
      actions.appendChild(deleteButton);
    }
    item.appendChild(actions);

    adminMatchList.appendChild(item);
  });
}

function buildPlayerCategoryIndex() {
  const index = new Map();
  const categories = Array.isArray(state.categories) ? state.categories : [];

  state.enrollments.forEach((enrollments, categoryId) => {
    const normalizedId = String(categoryId);
    const category = categories.find((item) => (item._id || item.id) === normalizedId);
    const categoryName = category?.name || 'Sin asignar';
    const items = Array.isArray(enrollments) ? enrollments : [];

    items.forEach((enrollment) => {
      const userRef = enrollment.user;
      const userId =
        (typeof userRef === 'object' && userRef !== null
          ? userRef._id || userRef.id
          : userRef) || null;
      if (!userId) return;

      const bucket = index.get(userId) || [];
      if (!bucket.some((entry) => entry.id === normalizedId)) {
        bucket.push({ id: normalizedId, name: categoryName });
      }
      index.set(userId, bucket);
    });
  });

  return index;
}

function renderPlayerDirectory() {
  if (!playerDirectoryList) return;

  if (!isAdmin()) {
    playerDirectoryList.innerHTML = '';
    if (playerDirectoryEmpty) {
      playerDirectoryEmpty.hidden = false;
      playerDirectoryEmpty.textContent = 'Disponible solo para administradores.';
    }
    if (playerDirectoryCount) {
      playerDirectoryCount.textContent = '0';
    }
    return;
  }

  const filters = state.playerDirectoryFilters || {};
  const searchTerm = (filters.search || '').toLowerCase();
  const genderFilter = filters.gender || '';
  const roleFilter = filters.role || '';
  const categoryFilter = filters.category || '';
  const players = Array.isArray(state.players) ? state.players : [];
  const categoryIndex = buildPlayerCategoryIndex();

  const filtered = players.filter((player) => {
    if (genderFilter && player.gender !== genderFilter) {
      return false;
    }
    if (roleFilter && !entityHasRole(player, roleFilter)) {
      return false;
    }
    if (searchTerm) {
      const haystack = `${player.fullName || ''} ${player.email || ''} ${player.phone || ''}`.toLowerCase();
      if (!haystack.includes(searchTerm)) {
        return false;
      }
    }
    if (categoryFilter) {
      const categories = categoryIndex.get(player._id || player.id) || [];
      if (!categories.some((entry) => entry.id === categoryFilter)) {
        return false;
      }
    }
    return true;
  });

  const sorted = filtered.slice().sort((a, b) => {
    const nameA = (a.fullName || '').toLocaleLowerCase('es');
    const nameB = (b.fullName || '').toLocaleLowerCase('es');
    return nameA.localeCompare(nameB, 'es');
  });

  playerDirectoryList.innerHTML = '';

  if (playerDirectoryCount) {
    playerDirectoryCount.textContent = String(sorted.length);
  }

  if (!sorted.length) {
    if (playerDirectoryEmpty) {
      playerDirectoryEmpty.hidden = false;
      playerDirectoryEmpty.textContent = 'Aún no hay usuarios que coincidan con el filtro seleccionado.';
    }
    return;
  }

  if (playerDirectoryEmpty) {
    playerDirectoryEmpty.hidden = true;
  }

  sorted.forEach((player) => {
    const playerId = player._id || player.id;
    const item = document.createElement('li');
    const header = buildPlayerCell(player, { includeSchedule: true });
    item.appendChild(header);

    const contact = document.createElement('div');
    contact.className = 'meta';
    if (player.email) {
      contact.appendChild(document.createElement('span')).textContent = player.email;
    }
    if (player.phone) {
      contact.appendChild(document.createElement('span')).textContent = player.phone;
    }
    const roleTag = document.createElement('span');
    roleTag.className = 'tag';
    roleTag.textContent = formatRoles(player.roles || player.role);
    contact.appendChild(roleTag);
    item.appendChild(contact);

    const details = document.createElement('div');
    details.className = 'meta';
    details.appendChild(document.createElement('span')).textContent = `Género: ${translateGender(
      player.gender
    )}`;
    details.appendChild(document.createElement('span')).textContent = `Horario: ${translateSchedule(
      player.preferredSchedule
    )}`;
    if (player.birthDate) {
      details.appendChild(document.createElement('span')).textContent = `Nacimiento: ${formatShortDate(
        player.birthDate
      )}`;
    }
    const categories = categoryIndex.get(playerId) || [];
    const categoryLabel = categories.length
      ? categories
          .map((entry) => entry.name)
          .filter(Boolean)
          .sort((a, b) => a.localeCompare(b, 'es'))
          .join(', ')
      : 'Sin asignar';
    details.appendChild(document.createElement('span')).textContent = `Categorías: ${categoryLabel}`;
    item.appendChild(details);

    const membershipMeta = document.createElement('div');
    membershipMeta.className = 'meta';
    if (player.isMember) {
      membershipMeta.appendChild(document.createElement('span')).textContent = player.membershipNumber
        ? `Nº socio: ${player.membershipNumber}`
        : 'Socio sin número registrado';
      const verificationTag = document.createElement('span');
      verificationTag.className = player.membershipNumberVerified ? 'tag tag--success' : 'tag tag--pending';
      verificationTag.textContent = player.membershipNumberVerified
        ? 'Nº de socio validado'
        : 'Validación pendiente';
      membershipMeta.appendChild(verificationTag);
    } else {
      membershipMeta.appendChild(document.createElement('span')).textContent = 'No es socio del club';
    }
    item.appendChild(membershipMeta);

    if (player.notes) {
      const notes = document.createElement('div');
      notes.className = 'meta';
      notes.appendChild(document.createElement('span')).textContent = `Notas: ${player.notes}`;
      item.appendChild(notes);
    }

    const actions = document.createElement('div');
    actions.className = 'actions';
    const editButton = document.createElement('button');
    editButton.type = 'button';
    editButton.className = 'secondary';
    editButton.textContent = 'Editar';
    editButton.dataset.playerId = playerId;
    actions.appendChild(editButton);
    item.appendChild(actions);

    playerDirectoryList.appendChild(item);
  });
}

function resetAdminCategoryForm() {
  if (!adminCategoryForm) return;
  adminCategoryForm.reset();
  state.adminCategoryEditingId = null;
  const submit = adminCategoryForm.querySelector('.primary');
  if (submit) {
    submit.textContent = 'Guardar categoría';
  }
  if (adminCategoryCancel) {
    adminCategoryCancel.hidden = true;
  }
  if (adminCategoryForm.elements?.leagueId) {
    adminCategoryForm.elements.leagueId.value = '';
  }
  if (adminCategoryForm.elements?.color) {
    adminCategoryForm.elements.color.value = DEFAULT_CATEGORY_COLOR;
  }
}

function setAdminCategoryEditing(categoryId) {
  if (!adminCategoryForm) return;
  const category = state.categories.find((item) => (item._id || item.id) === categoryId);
  if (!category) return;

  state.adminCategoryEditingId = categoryId;
  adminCategoryForm.elements.name.value = category.name || '';
  adminCategoryForm.elements.description.value = category.description || '';
  adminCategoryForm.elements.gender.value = category.gender || 'masculino';
  adminCategoryForm.elements.skillLevel.value = category.skillLevel || '';
  if (adminCategoryForm.elements.startDate) {
    adminCategoryForm.elements.startDate.value = formatDateInput(category.startDate);
  }
  if (adminCategoryForm.elements.endDate) {
    adminCategoryForm.elements.endDate.value = formatDateInput(category.endDate);
  }
  if (adminCategoryForm.elements.leagueId) {
    adminCategoryForm.elements.leagueId.value = normalizeId(category.league) || '';
  }
  if (adminCategoryForm.elements.color) {
    adminCategoryForm.elements.color.value = getCategoryColor(category);
  }

  const submit = adminCategoryForm.querySelector('.primary');
  if (submit) {
    submit.textContent = 'Actualizar categoría';
  }
  if (adminCategoryCancel) {
    adminCategoryCancel.hidden = false;
  }
  adminCategoryForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function resetAdminPlayerForm() {
  if (!adminPlayerForm) return;
  adminPlayerForm.reset();
  state.adminPlayerEditingId = null;
  const submit = adminPlayerForm.querySelector('.primary');
  if (submit) {
    submit.textContent = 'Guardar usuario';
  }
  if (adminPlayerCancel) {
    adminPlayerCancel.hidden = true;
  }
}

function setAdminPlayerEditing(playerId) {
  if (!adminPlayerForm) return;
  const player = state.players.find((item) => (item._id || item.id) === playerId);
  if (!player) return;

  state.adminPlayerEditingId = playerId;
  adminPlayerForm.elements.fullName.value = player.fullName || '';
  adminPlayerForm.elements.email.value = player.email || '';
  adminPlayerForm.elements.password.value = '';
  adminPlayerForm.elements.gender.value = player.gender || 'masculino';
  adminPlayerForm.elements.role.value = player.role || 'player';
  adminPlayerForm.elements.phone.value = player.phone || '';
  adminPlayerForm.elements.preferredSchedule.value = player.preferredSchedule || 'flexible';
  adminPlayerForm.elements.notes.value = player.notes || '';

  const submit = adminPlayerForm.querySelector('.primary');
  if (submit) {
    submit.textContent = 'Actualizar usuario';
  }
  if (adminPlayerCancel) {
    adminPlayerCancel.hidden = false;
  }
  adminPlayerForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

function populateAdminMatchCourtOptions(selectedValue) {
  if (!adminMatchCourt) return;

  const courtNames = getClubCourtNames();
  const targetValue =
    selectedValue !== undefined && selectedValue !== null
      ? String(selectedValue)
      : adminMatchCourt.value;

  adminMatchCourt.innerHTML = '';

  const placeholder = document.createElement('option');
  placeholder.value = '';
  placeholder.textContent = courtNames.length
    ? 'Sin pista asignada'
    : 'Añade pistas en la sección del club';
  adminMatchCourt.appendChild(placeholder);

  courtNames.forEach((name) => {
    const option = document.createElement('option');
    option.value = name;
    option.textContent = name;
    adminMatchCourt.appendChild(option);
  });

  adminMatchCourt.title = courtNames.length
    ? 'Las pistas disponibles se gestionan en el perfil del club.'
    : 'Añade pistas en la sección del club para poder asignarlas.';

  if (targetValue && courtNames.includes(targetValue)) {
    adminMatchCourt.value = targetValue;
  } else {
    adminMatchCourt.value = '';
  }
}

function syncAdminMatchScheduledValue() {
  if (!adminMatchDate) {
    return;
  }

  const templates = getClubMatchScheduleTemplates();
  const hasTemplates = Array.isArray(templates) && templates.length > 0;

  if (hasTemplates && adminMatchSchedulePicker) {
    const selection = adminMatchSchedulePicker.getSelection();
    adminMatchDate.value = selection.scheduledAt || '';
    return;
  }

  if (adminMatchDatetimeInput) {
    const manualValue = adminMatchDatetimeInput.value ? adminMatchDatetimeInput.value.trim() : '';
    adminMatchDate.value = manualValue;
    return;
  }

  adminMatchDate.value = '';
}

function updateAdminMatchScheduleVisibility({ selectedTime, selectedCourt } = {}) {
  const templates = getClubMatchScheduleTemplates();
  const hasTemplates = Array.isArray(templates) && templates.length > 0;

  if (adminMatchScheduleContainer) {
    adminMatchScheduleContainer.hidden = !hasTemplates;
  }

  if (adminMatchDay) {
    adminMatchDay.disabled = !hasTemplates;
  }

  if (adminMatchClearSlot) {
    adminMatchClearSlot.hidden = !hasTemplates;
    adminMatchClearSlot.disabled = !hasTemplates;
    if (adminMatchClearSlotHandler) {
      adminMatchClearSlot.removeEventListener('click', adminMatchClearSlotHandler);
      adminMatchClearSlotHandler = null;
    }
  }

  if (adminMatchDatetimeField) {
    adminMatchDatetimeField.hidden = hasTemplates;
  }

  if (adminMatchDatetimeInput) {
    adminMatchDatetimeInput.disabled = hasTemplates;
    if (!hasTemplates && adminMatchDate) {
      adminMatchDatetimeInput.value = adminMatchDate.value || '';
    }
  }

  if (hasTemplates && adminMatchSchedulePickerContainer && adminMatchDay && adminMatchDate) {
    if (adminMatchSchedulePicker) {
      adminMatchSchedulePicker.destroy();
      adminMatchSchedulePicker = null;
    }

    const resolvedSelectedCourt =
      typeof selectedCourt === 'string' ? selectedCourt : adminMatchCourt?.value || '';

    adminMatchSchedulePicker = createMatchScheduleSlotPicker({
      container: adminMatchSchedulePickerContainer,
      dateField: adminMatchDay,
      scheduledField: adminMatchDate,
      courtField: adminMatchCourt,
      templates,
      scope: 'admin',
      existingValue: adminMatchDate.value || '',
      existingCourt: resolvedSelectedCourt,
      ignoreMatchId: state.adminMatchEditingId || '',
      ignoreManualLimit: hasCourtManagementAccess(),
      onChange: () => {
        syncAdminMatchScheduledValue();
      },
    });

    if (adminMatchClearSlot) {
      adminMatchClearSlotHandler = (event) => {
        event.preventDefault();
        adminMatchSchedulePicker?.clear();
        syncAdminMatchScheduledValue();
      };
      adminMatchClearSlot.addEventListener('click', adminMatchClearSlotHandler);
    }

    if (selectedTime && adminMatchDay.value) {
      adminMatchSchedulePicker.setSelection({
        date: adminMatchDay.value,
        time: selectedTime,
        court: resolvedSelectedCourt,
      });
    } else if (resolvedSelectedCourt) {
      const currentSelection = adminMatchSchedulePicker.getSelection();
      if (currentSelection.scheduledAt && !currentSelection.court) {
        adminMatchSchedulePicker.setSelection({
          scheduledAt: currentSelection.scheduledAt,
          court: resolvedSelectedCourt,
        });
      }
    }

    syncAdminMatchScheduledValue();
    return;
  }

  if (adminMatchSchedulePicker) {
    adminMatchSchedulePicker.destroy();
    adminMatchSchedulePicker = null;
  }

  if (adminMatchSchedulePickerContainer) {
    adminMatchSchedulePickerContainer.innerHTML = '';
    adminMatchSchedulePickerContainer.classList.remove('match-schedule-picker');
  }

  syncAdminMatchScheduledValue();
}

function resetAdminMatchForm() {
  if (!adminMatchForm) return;
  adminMatchForm.reset();
  populateAdminMatchCourtOptions('');
  if (adminMatchDay) {
    adminMatchDay.value = '';
  }
  if (adminMatchDatetimeInput) {
    adminMatchDatetimeInput.value = '';
  }
  if (adminMatchDate) {
    adminMatchDate.value = '';
  }
  updateAdminMatchScheduleVisibility();
  state.adminMatchEditingId = null;
  if (adminMatchSelect) {
    adminMatchSelect.value = '';
  }
  if (adminMatchCancel) {
    adminMatchCancel.hidden = true;
  }
  if (adminMatchDelete) {
    adminMatchDelete.hidden = true;
    adminMatchDelete.disabled = false;
    delete adminMatchDelete.dataset.matchId;
  }
  setStatusMessage(adminMatchStatusMessage, '', '');
}

function setAdminMatchEditing(matchId) {
  if (!adminMatchForm) return;
  setStatusMessage(adminMatchStatusMessage, '', '');
  const match = state.calendarMatches.find((item) => (item._id || item.id) === matchId);
  if (!match) return;

  state.adminMatchEditingId = matchId;
  if (adminMatchSelect) {
    adminMatchSelect.value = matchId;
  }
  if (adminMatchCategory) {
    const categoryValue = normalizeId(match.category);
    adminMatchCategory.value = categoryValue || '';
  }

  const playerIds = Array.isArray(match.players)
    ? match.players.map((player) => normalizeId(player))
    : [];
  const [firstPlayer, secondPlayer] = playerIds;

  if (adminMatchPlayer1) {
    if (firstPlayer && !Array.from(adminMatchPlayer1.options).some((opt) => opt.value === firstPlayer)) {
      const option = document.createElement('option');
      option.value = firstPlayer;
      option.textContent = match.players?.[0]?.fullName || 'Jugador';
      adminMatchPlayer1.appendChild(option);
    }
    adminMatchPlayer1.value = firstPlayer || '';
  }
  if (adminMatchPlayer2) {
    if (secondPlayer && !Array.from(adminMatchPlayer2.options).some((opt) => opt.value === secondPlayer)) {
      const option = document.createElement('option');
      option.value = secondPlayer;
      option.textContent = match.players?.[1]?.fullName || 'Jugador';
      adminMatchPlayer2.appendChild(option);
    }
    adminMatchPlayer2.value = secondPlayer || '';
  }

  if (adminMatchStatus) {
    adminMatchStatus.value = match.status || 'pendiente';
  }
  const scheduledValue = formatDateTimeLocal(match.scheduledAt);
  if (adminMatchDate) {
    adminMatchDate.value = scheduledValue;
  }
  if (adminMatchDatetimeInput) {
    adminMatchDatetimeInput.value = scheduledValue || '';
  }
  if (adminMatchDay) {
    adminMatchDay.value = scheduledValue ? scheduledValue.split('T')[0] : '';
  }
  populateAdminMatchCourtOptions(match.court || '');
  updateAdminMatchScheduleVisibility({
    selectedTime: scheduledValue ? scheduledValue.split('T')[1] : '',
    selectedCourt: match.court || '',
  });
  if (adminMatchNotes) {
    const notes = match.result?.notes || match.notes || '';
    adminMatchNotes.value = notes;
  }

  if (adminMatchCancel) {
    adminMatchCancel.hidden = false;
  }
  if (adminMatchDelete) {
    adminMatchDelete.hidden = match.status === 'completado';
    adminMatchDelete.disabled = match.status === 'completado';
    adminMatchDelete.dataset.matchId = matchId;
  }
  adminMatchForm.scrollIntoView({ behavior: 'smooth', block: 'center' });
}

async function loadEnrollments(categoryId, { force = false } = {}) {
  if (!categoryId) {
    return [];
  }

  if (force) {
    state.enrollments.delete(categoryId);
    invalidateLeaguePaymentsByCategory(categoryId);
  }

  if (state.enrollments.has(categoryId)) {
    return state.enrollments.get(categoryId);
  }

  const enrollments = await request(`/categories/${categoryId}/enrollments`);
  const sorted = Array.isArray(enrollments)
    ? [...enrollments].sort((a, b) => {
        const nameA = a?.user?.fullName || '';
        const nameB = b?.user?.fullName || '';
        return nameA.localeCompare(nameB, 'es');
      })
    : [];
  state.enrollments.set(categoryId, sorted);
  return sorted;
}

async function loadEnrollmentRequests(categoryId, { force = false } = {}) {
  if (!categoryId) {
    return [];
  }

  if (!force && state.enrollmentRequests.has(categoryId)) {
    return state.enrollmentRequests.get(categoryId);
  }

  const requests = await request(`/categories/${categoryId}/enrollment-requests`);
  const sorted = Array.isArray(requests)
    ? [...requests].sort((a, b) => new Date(a.createdAt) - new Date(b.createdAt))
    : [];
  state.enrollmentRequests.set(categoryId, sorted);
  return sorted;
}

function buildCategoryPayload(formData, isEditing = false) {
  const payload = {
    name: (formData.get('name') || '').trim(),
    gender: formData.get('gender'),
  };

  const description = (formData.get('description') || '').trim();
  if (description) {
    payload.description = description;
  } else if (isEditing) {
    payload.description = null;
  }

  const skillLevel = (formData.get('skillLevel') || '').trim();
  if (skillLevel) {
    payload.skillLevel = skillLevel;
  }

  if (formData.has('startDate')) {
    const startDate = formData.get('startDate');
    if (startDate) {
      payload.startDate = startDate;
    } else if (isEditing) {
      payload.startDate = null;
    }
  }

  if (formData.has('endDate')) {
    const endDate = formData.get('endDate');
    if (endDate) {
      payload.endDate = endDate;
    } else if (isEditing) {
      payload.endDate = null;
    }
  }

  const status = formData.get('status');
  if (status) {
    payload.status = status;
  }

  const matchFormat = (formData.get('matchFormat') || '').trim();
  if (matchFormat) {
    payload.matchFormat = matchFormat;
  }

  const leagueId = (formData.get('leagueId') || '').trim();
  if (leagueId) {
    payload.leagueId = leagueId;
  }

  if (formData.has('minimumAge')) {
    const rawMinimumAge = formData.get('minimumAge');
    if (rawMinimumAge !== null && rawMinimumAge !== undefined && rawMinimumAge !== '') {
      const parsedMinimumAge = Number.parseInt(rawMinimumAge, 10);
      if (Number.isFinite(parsedMinimumAge) && parsedMinimumAge >= 0) {
        payload.minimumAge = parsedMinimumAge;
      }
    } else if (isEditing) {
      payload.minimumAge = null;
    }
  }

  if (formData.has('color')) {
    const colorValue = resolveCategoryColor(formData.get('color'));
    if (colorValue) {
      payload.color = colorValue;
    }
  }

  return payload;
}

async function submitCategoryFormData({ form, categoryId, statusElement }) {
  if (!form) return false;
  const formData = new FormData(form);
  const isEditing = Boolean(categoryId);
  const payload = buildCategoryPayload(formData, isEditing);

  if (!payload.name) {
    setStatusMessage(statusElement, 'error', 'El nombre de la categoría es obligatorio.');
    return false;
  }

  if (!payload.leagueId) {
    setStatusMessage(statusElement, 'error', 'Selecciona una liga para la categoría.');
    return false;
  }

  if (
    !payload.skillLevel ||
    !CATEGORY_SKILL_LEVEL_OPTIONS.some((option) => option.value === payload.skillLevel)
  ) {
    setStatusMessage(statusElement, 'error', 'Selecciona un nivel para la categoría.');
    return false;
  }

  if (
    !payload.matchFormat ||
    !CATEGORY_MATCH_FORMAT_OPTIONS.some((option) => option.value === payload.matchFormat)
  ) {
    setStatusMessage(statusElement, 'error', 'Selecciona un formato de partido para la categoría.');
    return false;
  }

  setStatusMessage(
    statusElement,
    'info',
    isEditing ? 'Actualizando categoría...' : 'Creando categoría...'
  );

  try {
    const url = isEditing ? `/categories/${categoryId}` : '/categories';
    const method = isEditing ? 'PATCH' : 'POST';
    await request(url, { method, body: payload });
    setStatusMessage(
      statusElement,
      'success',
      isEditing ? 'Categoría actualizada.' : 'Categoría creada.'
    );
    await loadAllData();
    return true;
  } catch (error) {
    setStatusMessage(statusElement, 'error', error.message);
    return false;
  }
}

function buildLeaguePayload(formData, isEditing = false) {
  const payload = {
    name: (formData.get('name') || '').trim(),
    status: formData.get('status') || 'activa',
  };

  const yearRaw = (formData.get('year') || '').trim();
  if (yearRaw) {
    const parsedYear = Number.parseInt(yearRaw, 10);
    if (!Number.isNaN(parsedYear)) {
      payload.year = parsedYear;
    }
  }

  const description = (formData.get('description') || '').trim();
  if (description) {
    payload.description = description;
  } else if (isEditing) {
    payload.description = null;
  }

  const hasPosterField = typeof formData.has === 'function' ? formData.has('poster') : true;
  if (hasPosterField) {
    const poster = (formData.get('poster') || '').trim();
    if (poster) {
      payload.poster = poster;
    } else if (isEditing) {
      payload.poster = null;
    }
  }

  const startDate = formData.get('startDate');
  if (startDate) {
    payload.startDate = startDate;
  } else if (isEditing) {
    payload.startDate = null;
  }

  const endDate = formData.get('endDate');
  if (endDate) {
    payload.endDate = endDate;
  } else if (isEditing) {
    payload.endDate = null;
  }

  const registrationCloseDate = formData.get('registrationCloseDate');
  if (registrationCloseDate) {
    payload.registrationCloseDate = registrationCloseDate;
  } else if (isEditing) {
    payload.registrationCloseDate = null;
  }

  const visibility = formData.get('isPrivate');
  if (visibility === 'true') {
    payload.isPrivate = true;
  } else if (visibility === 'false') {
    payload.isPrivate = false;
  }

  const enrollmentFeeRaw = formData.get('enrollmentFee');
  if (enrollmentFeeRaw !== null && enrollmentFeeRaw !== undefined) {
    const trimmed = String(enrollmentFeeRaw).trim();
    if (trimmed) {
      const fee = Number.parseFloat(trimmed);
      if (!Number.isNaN(fee) && fee >= 0) {
        payload.enrollmentFee = fee;
      }
    } else if (isEditing) {
      payload.enrollmentFee = null;
    }
  }

  const categories = formData.getAll('categories').filter(Boolean);
  if (categories.length || isEditing) {
    payload.categories = categories;
  }

  return payload;
}

async function submitLeagueFormData({ form, leagueId, statusElement }) {
  if (!form) return false;
  const formData = new FormData(form);
  const isEditing = Boolean(leagueId);
  const payload = buildLeaguePayload(formData, isEditing);

  if (!payload.name) {
    setStatusMessage(statusElement, 'error', 'El nombre de la liga es obligatorio.');
    return false;
  }

  setStatusMessage(
    statusElement,
    'info',
    isEditing ? 'Actualizando liga...' : 'Creando liga...'
  );

  try {
    const url = isEditing ? `/leagues/${leagueId}` : '/leagues';
    const method = isEditing ? 'PATCH' : 'POST';
    await request(url, { method, body: payload });
    setStatusMessage(
      statusElement,
      'success',
      isEditing ? 'Liga actualizada.' : 'Liga creada.'
    );
    await loadAllData();
    return true;
  } catch (error) {
    setStatusMessage(statusElement, 'error', error.message);
    return false;
  }
}

async function deleteLeagueById(leagueId, { button } = {}) {
  if (!leagueId || !isAdmin()) {
    return false;
  }

  const league = state.leagues.find((item) => normalizeId(item) === leagueId);
  const leagueName = league?.name ? ` "${league.name}"` : '';
  const confirmed = window.confirm(
    `¿Seguro que deseas eliminar la liga${leagueName}? Esta acción no se puede deshacer.`
  );

  if (!confirmed) {
    return false;
  }

  if (button) {
    button.disabled = true;
  }

  try {
    await request(`/leagues/${leagueId}`, { method: 'DELETE' });
    showGlobalMessage('Liga eliminada correctamente.', 'success');
    await loadAllData();
    return true;
  } catch (error) {
    showGlobalMessage(error.message, 'error');
    return false;
  } finally {
    if (button) {
      button.disabled = false;
    }
  }
}

function buildTournamentPayload(form, { isEditing = false } = {}) {
  const formData = new FormData(form);
  const payload = {
    name: (formData.get('name') || '').trim(),
  };

  const description = (formData.get('description') || '').trim();
  if (description) {
    payload.description = description;
  } else if (isEditing) {
    payload.description = null;
  }

  ['startDate', 'endDate', 'registrationCloseDate'].forEach((field) => {
    const value = formData.get(field);
    if (value) {
      payload[field] = value;
    } else if (isEditing) {
      payload[field] = null;
    }
  });

  const poster = (formData.get('poster') || '').trim();
  if (poster) {
    payload.poster = poster;
  } else if (isEditing) {
    payload.poster = null;
  }

  const status = (formData.get('status') || '').trim();
  if (status) {
    payload.status = status;
  }

  const visibility = formData.get('isPrivate');
  if (visibility === 'true') {
    payload.isPrivate = true;
  } else if (visibility === 'false') {
    payload.isPrivate = false;
  }

  const hasShirtValue = formData.get('hasShirt');
  if (hasShirtValue === 'true') {
    payload.hasShirt = true;
  } else if (hasShirtValue === 'false') {
    payload.hasShirt = false;
  }

  const hasGiftBagValue = formData.get('hasGiftBag');
  if (hasGiftBagValue === 'true') {
    payload.hasGiftBag = true;
  } else if (hasGiftBagValue === 'false') {
    payload.hasGiftBag = false;
  }

  const feeEntries = Array.from(form.querySelectorAll('[data-fee-entry]'));
  if (feeEntries.length) {
    const fees = feeEntries
      .map((entry) => {
        const label = entry.querySelector('[data-fee-field="label"]')?.value.trim();
        if (!label) {
          return null;
        }
        const currencyRaw = entry.querySelector('[data-fee-field="currency"]')?.value.trim();
        const descriptionValue = entry
          .querySelector('[data-fee-field="description"]')
          ?.value.trim();
        const memberAmountValue = entry
          .querySelector('[data-fee-field="memberAmount"]')
          ?.value;
        const nonMemberAmountValue = entry
          .querySelector('[data-fee-field="nonMemberAmount"]')
          ?.value;
        const legacyAmountValue = entry.querySelector('[data-fee-field="amount"]')?.value;

        const memberAmount = Number.parseFloat(memberAmountValue);
        const nonMemberAmount = Number.parseFloat(nonMemberAmountValue);
        const legacyAmount = Number.parseFloat(legacyAmountValue);

        const hasMemberAmount = !Number.isNaN(memberAmount) && memberAmount >= 0;
        const hasNonMemberAmount = !Number.isNaN(nonMemberAmount) && nonMemberAmount >= 0;
        const hasLegacyAmount = !Number.isNaN(legacyAmount) && legacyAmount >= 0;

        if (!hasMemberAmount && !hasNonMemberAmount && !hasLegacyAmount) {
          return null;
        }

        const fee = {
          label,
          currency: currencyRaw ? currencyRaw.toUpperCase() : 'EUR',
        };

        if (descriptionValue) {
          fee.description = descriptionValue;
        }
        if (hasLegacyAmount) {
          fee.amount = legacyAmount;
        }
        if (hasMemberAmount) {
          fee.memberAmount = memberAmount;
        }
        if (hasNonMemberAmount) {
          fee.nonMemberAmount = nonMemberAmount;
        }

        return fee;
      })
      .filter(Boolean);
    if (fees.length || isEditing) {
      payload.fees = fees;
    }
  } else if (isEditing) {
    payload.fees = [];
  }

  return payload;
}

async function submitTournamentFormData({ form, tournamentId, statusElement }) {
  if (!form) return { success: false };
  const isEditing = Boolean(tournamentId);
  const payload = buildTournamentPayload(form, { isEditing });

  if (!payload.name) {
    setStatusMessage(statusElement, 'error', 'El nombre del torneo es obligatorio.');
    return { success: false };
  }

  setStatusMessage(
    statusElement,
    'info',
    isEditing ? 'Actualizando torneo...' : 'Creando torneo...'
  );

  try {
    const url = isEditing ? `/tournaments/${tournamentId}` : '/tournaments';
    const method = isEditing ? 'PATCH' : 'POST';
    const result = await request(url, { method, body: payload });
    const createdId = normalizeId(result) || normalizeId(tournamentId);
    await reloadTournaments({ selectTournamentId: createdId });
    if (createdId) {
      state.tournamentDetails.delete(createdId);
      await refreshTournamentDetail(createdId);
    }
    setStatusMessage(
      statusElement,
      'success',
      isEditing ? 'Torneo actualizado.' : 'Torneo creado.'
    );
    return { success: true, tournamentId: createdId };
  } catch (error) {
    setStatusMessage(statusElement, 'error', error.message);
    return { success: false };
  }
}

function openTournamentModal(tournamentId = '') {
  if (!isAdmin()) return;
  const normalizedId = tournamentId ? normalizeId(tournamentId) : '';
  const tournament = normalizedId ? getTournamentById(normalizedId) : null;

  const statusOptions = Object.entries(TOURNAMENT_STATUS_LABELS)
    .map(([value, label]) => `<option value="${value}">${label}</option>`)
    .join('');

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Nombre
      <input type="text" name="name" required />
    </label>
    <label>
      Descripción
      <textarea name="description" rows="3" placeholder="Detalles opcionales"></textarea>
    </label>
    <label>
      Visibilidad
      <select name="isPrivate" required>
        <option value="false">Público</option>
        <option value="true">Privado</option>
      </select>
      <span class="form-hint">Los torneos privados solo serán visibles y admiten inscripciones de socios.</span>
    </label>
    <div class="form-grid">
      <label>
        Fecha de inicio
        <input type="date" name="startDate" />
      </label>
      <label>
        Fecha de finalización
        <input type="date" name="endDate" />
      </label>
    </div>
    <label>
      Cierre de inscripciones
      <input type="date" name="registrationCloseDate" />
      <span class="form-hint">Déjalo vacío si las inscripciones cierran el día de inicio.</span>
    </label>
    <label>
      Estado
      <select name="status" required>
        ${statusOptions}
      </select>
    </label>
    <div class="form-grid">
      <label>
        Camiseta
        <select name="hasShirt" required>
          <option value="false">No</option>
          <option value="true">Sí</option>
        </select>
        <span class="form-hint">Indica si el torneo incluye camiseta para los participantes.</span>
      </label>
      <label>
        Bolsa regalo
        <select name="hasGiftBag" required>
          <option value="false">No</option>
          <option value="true">Sí</option>
        </select>
      </label>
    </div>
    <div class="form-section" data-fees-section>
      <div class="form-section__header">
        <h3>Cuotas de inscripción</h3>
        <button type="button" class="secondary" data-action="add-fee">Añadir cuota</button>
      </div>
      <p class="form-hint">Define importes opcionales para la inscripción del torneo.</p>
      <div data-fee-list></div>
    </div>
    <div class="form-actions">
      <button type="submit" class="primary">${tournament ? 'Actualizar' : 'Crear'} torneo</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
      ${
        tournament
          ? '<button type="button" class="danger" data-action="delete">Eliminar torneo</button>'
          : ''
      }
    </div>
  `;

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const feeList = form.querySelector('[data-fee-list]');
  const addFeeButton = form.querySelector('[data-action="add-fee"]');

  function addFeeEntry(data = {}) {
    if (!feeList) return;
    const entry = document.createElement('div');
    entry.className = 'form-section';
    entry.dataset.feeEntry = 'true';
    entry.innerHTML = `
      <div class="form-grid">
        <label>
          ¿En cuantas categorías se quiere inscribir?
          <select data-fee-field="label" required>
            <option value="">Selecciona una opción</option>
            <option value="1">1</option>
            <option value="2">2</option>
            <option value="3">3</option>
            <option value="4">4</option>
            <option value="5">5</option>
            <option value="6">6</option>
          </select>
        </label>
        <label>
          Importe socios
          <input
            type="number"
            min="0"
            step="0.01"
            data-fee-field="memberAmount"
            placeholder="0.00"
          />
        </label>
        <label>
          Importe no socios
          <input
            type="number"
            min="0"
            step="0.01"
            data-fee-field="nonMemberAmount"
            placeholder="0.00"
          />
        </label>
      </div>
      <div class="form-grid">
        <label>
          Divisa
          <input type="text" maxlength="3" data-fee-field="currency" placeholder="EUR" />
        </label>
        <label>
          Notas
          <input type="text" data-fee-field="description" placeholder="Información opcional" />
        </label>
      </div>
      <div class="form-actions">
        <button type="button" class="ghost" data-action="remove-fee">Quitar cuota</button>
      </div>
    `;

    const removeButton = entry.querySelector('[data-action="remove-fee"]');
    removeButton?.addEventListener('click', () => {
      entry.remove();
    });

    feeList.appendChild(entry);

    const labelField = entry.querySelector('[data-fee-field="label"]');
    const memberAmountField = entry.querySelector('[data-fee-field="memberAmount"]');
    const nonMemberAmountField = entry.querySelector('[data-fee-field="nonMemberAmount"]');
    const currencyField = entry.querySelector('[data-fee-field="currency"]');
    const descriptionField = entry.querySelector('[data-fee-field="description"]');

    if (labelField && data.label) {
      const labelValue = data.label.toString().trim();
      if (labelValue) {
        const options = Array.from(labelField.options || []);
        const hasMatchingOption = options.some((option) => option.value === labelValue);
        if (!hasMatchingOption) {
          const customOption = document.createElement('option');
          customOption.value = labelValue;
          customOption.textContent = labelValue;
          labelField.appendChild(customOption);
        }
        labelField.value = labelValue;
      }
    }
    const legacyAmount =
      typeof data.amount !== 'undefined' && data.amount !== null ? data.amount : undefined;
    if (memberAmountField) {
      if (typeof data.memberAmount !== 'undefined') {
        memberAmountField.value = data.memberAmount;
      } else if (typeof legacyAmount !== 'undefined') {
        memberAmountField.value = legacyAmount;
      }
    }
    if (nonMemberAmountField) {
      if (typeof data.nonMemberAmount !== 'undefined') {
        nonMemberAmountField.value = data.nonMemberAmount;
      } else if (typeof legacyAmount !== 'undefined') {
        nonMemberAmountField.value = legacyAmount;
      }
    }
    if (currencyField && data.currency) {
      currencyField.value = data.currency;
    }
    if (descriptionField && data.description) {
      descriptionField.value = data.description;
    }
  }

  addFeeButton?.addEventListener('click', () => {
    addFeeEntry();
  });

  if (Array.isArray(tournament?.fees) && tournament.fees.length) {
    tournament.fees.forEach((fee) => addFeeEntry(fee));
  }

  const formActions = form.querySelector('.form-actions');
  if (tournament && normalizedId && formActions) {
    const uploadSection = document.createElement('div');
    uploadSection.className = 'form-section tournament-poster-upload';
    uploadSection.innerHTML = `
      <h3>Cartel del torneo</h3>
      <p class="form-hint">Sube una imagen en formato JPG o PNG (máximo 5&nbsp;MB).</p>
      <label>
        Selecciona una imagen
        <input type="file" name="posterFile" accept="image/*" />
      </label>
      <div class="form-actions">
        <button type="button" class="secondary" data-action="upload-poster">Subir cartel</button>
      </div>
    `;

    const posterUploadStatus = document.createElement('p');
    posterUploadStatus.className = 'status-message';
    posterUploadStatus.style.display = 'none';
    uploadSection.appendChild(posterUploadStatus);

    formActions.before(uploadSection);

    const uploadButton = uploadSection.querySelector('[data-action="upload-poster"]');
    const fileInput = uploadSection.querySelector('input[name="posterFile"]');

    uploadButton?.addEventListener('click', async () => {
      if (!fileInput?.files?.length) {
        setStatusMessage(posterUploadStatus, 'error', 'Selecciona una imagen para el cartel.');
        return;
      }

      const file = fileInput.files[0];
      if (!file.type.startsWith('image/')) {
        setStatusMessage(posterUploadStatus, 'error', 'El archivo seleccionado debe ser una imagen.');
        return;
      }

      if (file.size > MAX_POSTER_SIZE) {
        setStatusMessage(
          posterUploadStatus,
          'error',
          'La imagen supera el tamaño máximo permitido (5 MB).'
        );
        return;
      }

      const formData = new FormData();
      formData.append('poster', file);

      setStatusMessage(posterUploadStatus, 'info', 'Subiendo cartel...');

      try {
        const result = await request(`/tournaments/${normalizedId}/poster`, {
          method: 'POST',
          body: formData,
        });
        setStatusMessage(posterUploadStatus, 'success', 'Cartel actualizado.');
        if (form.elements.poster) {
          form.elements.poster.value = result?.poster || '';
        }
        fileInput.value = '';
        await reloadTournaments({ selectTournamentId: normalizedId });
        state.tournamentDetails.delete(normalizedId);
        await refreshTournamentDetail(normalizedId);
      } catch (error) {
        setStatusMessage(posterUploadStatus, 'error', error.message);
      }
    });
  }

  form.elements.name.value = tournament?.name || '';
  form.elements.description.value = tournament?.description || '';
  if (form.elements.startDate) {
    form.elements.startDate.value = formatDateInput(tournament?.startDate);
  }
  if (form.elements.endDate) {
    form.elements.endDate.value = formatDateInput(tournament?.endDate);
  }
  if (form.elements.registrationCloseDate) {
    form.elements.registrationCloseDate.value = formatDateInput(
      tournament?.registrationCloseDate
    );
  }
  if (form.elements.poster) {
    form.elements.poster.value = tournament?.poster || '';
  }
  if (form.elements.status) {
    form.elements.status.value = tournament?.status || 'inscripcion';
  }
  if (form.elements.isPrivate) {
    form.elements.isPrivate.value = tournament?.isPrivate ? 'true' : 'false';
  }
  if (form.elements.hasShirt) {
    form.elements.hasShirt.value = tournament?.hasShirt ? 'true' : 'false';
  }
  if (form.elements.hasGiftBag) {
    form.elements.hasGiftBag.value = tournament?.hasGiftBag ? 'true' : 'false';
  }

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const result = await submitTournamentFormData({
      form,
      tournamentId: normalizedId,
      statusElement: status,
    });
    if (result.success) {
      closeModal();
    }
  });

  const cancelButton = form.querySelector('[data-action="cancel"]');
  cancelButton?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  const deleteButton = form.querySelector('[data-action="delete"]');
  deleteButton?.addEventListener('click', async () => {
    if (!normalizedId) {
      return;
    }

    const confirmed = window.confirm(
      '¿Seguro que deseas eliminar este torneo y toda la información relacionada? Esta acción no se puede deshacer.'
    );

    if (!confirmed) {
      return;
    }

    setStatusMessage(status, 'info', 'Eliminando torneo...');

    try {
      await request(`/tournaments/${normalizedId}`, { method: 'DELETE' });
      clearTournamentState(normalizedId);
    } catch (error) {
      setStatusMessage(status, 'error', error.message || 'No fue posible eliminar el torneo.');
      return;
    }

    setStatusMessage(status, 'success', 'Torneo eliminado correctamente.');

    try {
      await reloadTournaments();
    } catch (error) {
      console.warn('No se pudo actualizar la lista de torneos tras eliminar uno', error);
    }

    closeModal();
    showGlobalMessage('Torneo eliminado correctamente.');
  });

  openModal({
    title: tournament ? 'Editar torneo' : 'Nuevo torneo',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

function buildTournamentCategoryPayload(form) {
  const formData = new FormData(form);
  const payload = {
    name: (formData.get('name') || '').trim(),
    gender: formData.get('gender') || 'masculino',
  };

  const description = (formData.get('description') || '').trim();
  if (description) {
    payload.description = description;
  }

  const menuTitle = (formData.get('menuTitle') || '').trim();
  if (menuTitle) {
    payload.menuTitle = menuTitle;
  }

  const color = formData.get('color');
  if (color) {
    payload.color = resolveCategoryColor(color);
  }

  const matchType = formData.get('matchType');
  if (matchType && TOURNAMENT_MATCH_TYPE_LABELS[matchType]) {
    payload.matchType = matchType;
  }

  const matchFormat = formData.get('matchFormat');
  if (matchFormat && MATCH_FORMAT_LABELS[matchFormat]) {
    payload.matchFormat = matchFormat;
  }

  const drawSizeValue = Number.parseInt(formData.get('drawSize'), 10);
  if (
    Number.isFinite(drawSizeValue) &&
    TOURNAMENT_CATEGORY_DRAW_SIZE_OPTIONS.includes(drawSizeValue)
  ) {
    payload.drawSize = drawSizeValue;
  }

  return payload;
}

async function submitTournamentCategoryForm({
  form,
  tournamentId,
  categoryId = '',
  statusElement,
  confirmedPlayers = 0,
}) {
  if (!form || !tournamentId) return { success: false };

  const payload = buildTournamentCategoryPayload(form);
  if (!payload.name) {
    setStatusMessage(statusElement, 'error', 'El nombre de la categoría es obligatorio.');
    return { success: false };
  }

  if (!payload.gender) {
    setStatusMessage(statusElement, 'error', 'Selecciona el género de la categoría.');
    return { success: false };
  }

  if (!payload.matchType) {
    setStatusMessage(statusElement, 'error', 'Selecciona el tipo de partido de la categoría.');
    return { success: false };
  }

  if (!payload.matchFormat) {
    setStatusMessage(statusElement, 'error', 'Selecciona el formato de partido.');
    return { success: false };
  }

  const drawSizeFieldValue = Number.parseInt(form.elements.drawSize?.value, 10);
  if (
    !Number.isFinite(drawSizeFieldValue) ||
    !TOURNAMENT_CATEGORY_DRAW_SIZE_OPTIONS.includes(drawSizeFieldValue)
  ) {
    setStatusMessage(
      statusElement,
      'error',
      'Selecciona un tamaño de cuadro válido (8, 16 o 32).'
    );
    return { success: false };
  }

  payload.drawSize = drawSizeFieldValue;

  const normalizedCategoryId = categoryId ? normalizeId(categoryId) : '';
  const isEditing = Boolean(normalizedCategoryId);

  setStatusMessage(
    statusElement,
    'info',
    isEditing ? 'Actualizando categoría de torneo...' : 'Creando categoría de torneo...'
  );

  try {
    const endpoint = isEditing
      ? `/tournaments/${tournamentId}/categories/${normalizedCategoryId}`
      : `/tournaments/${tournamentId}/categories`;
    const method = isEditing ? 'PATCH' : 'POST';
    await request(endpoint, { method, body: payload });
    await reloadTournaments({ selectTournamentId: tournamentId });
    state.tournamentDetails.delete(tournamentId);
    await refreshTournamentDetail(tournamentId);
    setStatusMessage(
      statusElement,
      'success',
      isEditing ? 'Categoría actualizada correctamente.' : 'Categoría creada correctamente.'
    );
    return { success: true };
  } catch (error) {
    setStatusMessage(statusElement, 'error', error.message);
    return { success: false };
  }
}

async function openTournamentCategoryModal({ tournamentId: initialTournamentId = '', categoryId = '' } = {}) {
  if (!isAdmin()) return;
  const tournaments = Array.isArray(state.tournaments) ? [...state.tournaments] : [];
  if (!tournaments.length) {
    showGlobalMessage('Registra un torneo antes de crear categorías.', 'error');
    return;
  }

  const normalizedInitialTournamentId = normalizeId(initialTournamentId);
  const normalizedCategoryId = normalizeId(categoryId);
  const fallbackTournamentId = normalizeId(
    state.selectedTournamentCategoriesId || state.selectedTournamentId
  );

  let resolvedTournamentId = normalizedInitialTournamentId || fallbackTournamentId;
  if (normalizedCategoryId && !resolvedTournamentId) {
    const inferredTournament = tournaments.find((tournament) => {
      const id = normalizeId(tournament);
      if (!id) return false;
      const categories = getTournamentCategories(id);
      return categories.some((category) => normalizeId(category) === normalizedCategoryId);
    });
    resolvedTournamentId = normalizeId(inferredTournament);
  }

  let category = null;
  if (normalizedCategoryId && resolvedTournamentId) {
    if (!state.tournamentDetails.has(resolvedTournamentId)) {
      try {
        await refreshTournamentDetail(resolvedTournamentId);
      } catch (error) {
        console.warn('No se pudo refrescar el detalle del torneo antes de editar la categoría', error);
      }
    }
    category =
      getTournamentCategories(resolvedTournamentId).find(
        (entry) => normalizeId(entry) === normalizedCategoryId
      ) || null;

    if (!category) {
      try {
        category = await request(
          `/tournaments/${resolvedTournamentId}/categories/${normalizedCategoryId}`
        );
      } catch (error) {
        showGlobalMessage(error.message || 'No fue posible cargar la categoría seleccionada.', 'error');
        return;
      }
    }
  }

  const editing = Boolean(category);
  const selectedColor = category ? getCategoryColor(category) : DEFAULT_CATEGORY_COLOR;
  const confirmedPlayersCount = Number.isFinite(Number(category?.enrollmentCount))
    ? Number(category.enrollmentCount)
    : 0;

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Torneo
      <select name="tournamentId" required ${editing ? 'disabled' : ''}></select>
    </label>
    <label>
      Nombre
      <input type="text" name="name" required />
    </label>
    <label>
      Título corto (opcional)
      <input type="text" name="menuTitle" placeholder="Texto para menús o tarjetas" />
    </label>
    <label>
      Descripción
      <textarea name="description" rows="3" placeholder="Detalles opcionales"></textarea>
    </label>
    <div class="form-grid">
      <label>
        Género
        <select name="gender" required>
          <option value="masculino">Masculino</option>
          <option value="femenino">Femenino</option>
          <option value="mixto">Mixto</option>
        </select>
      </label>
      <label>
        Tipo de partido
        <select name="matchType" required>
          ${TOURNAMENT_MATCH_TYPE_OPTIONS.map(
            (option) => `<option value="${option.value}">${option.label}</option>`
          ).join('')}
        </select>
      </label>
    </div>
    <label>
      Formato de partido
      <select name="matchFormat" required>
        ${CATEGORY_MATCH_FORMAT_OPTIONS.map(
          (option) => `<option value="${option.value}">${option.label}</option>`
        ).join('')}
      </select>
      <span class="form-hint">Define cómo se registrarán los resultados de la categoría.</span>
    </label>
    ${renderCategoryColorField({
      name: 'color',
      selected: selectedColor,
    })}
    <label>
      Tamaño de cuadro
      <select name="drawSize" required>
        <option value="" disabled selected>Selecciona el tamaño del cuadro</option>
        ${TOURNAMENT_CATEGORY_DRAW_SIZE_OPTIONS.map(
          (size) => `<option value="${size}">${size} jugadores</option>`
        ).join('')}
      </select>
    </label>
    <div class="form-actions">
      <button type="submit" class="primary">${
        editing ? 'Actualizar categoría' : 'Crear categoría'
      }</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
      ${
        editing
          ? '<button type="button" class="danger" data-action="delete">Eliminar</button>'
          : ''
      }
    </div>
  `;

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const tournamentSelect = form.elements.tournamentId;
  tournaments
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
    .forEach((tournament) => {
      const option = document.createElement('option');
      option.value = normalizeId(tournament);
      option.textContent = tournament.name || 'Torneo';
      tournamentSelect.appendChild(option);
    });

  if (
    resolvedTournamentId &&
    Array.from(tournamentSelect.options).some((option) => option.value === resolvedTournamentId)
  ) {
    tournamentSelect.value = resolvedTournamentId;
  }

  const defaultMatchType = TOURNAMENT_MATCH_TYPE_OPTIONS[0]?.value || 'individual';
  const defaultMatchFormat = CATEGORY_MATCH_FORMAT_OPTIONS[0]?.value || DEFAULT_CATEGORY_MATCH_FORMAT;

  form.elements.name.value = category?.name || '';
  form.elements.menuTitle.value = category?.menuTitle || '';
  form.elements.description.value = category?.description || '';
  form.elements.gender.value = category?.gender || 'masculino';
  form.elements.matchType.value = category?.matchType || defaultMatchType;
  if (form.elements.matchFormat) {
    form.elements.matchFormat.value = category?.matchFormat || defaultMatchFormat;
  }
  if (form.elements.drawSize) {
    const drawSizeElement = form.elements.drawSize;
    const normalizedDrawSize = Number.isFinite(Number(category?.drawSize))
      ? String(Number(category.drawSize))
      : '';
    drawSizeElement.value = normalizedDrawSize || '';
    if (!normalizedDrawSize && drawSizeElement.options.length) {
      drawSizeElement.selectedIndex = 0;
    }
  }

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const tournamentId = editing ? resolvedTournamentId : tournamentSelect.value;
    if (!tournamentId) {
      setStatusMessage(status, 'error', 'Selecciona un torneo.');
      return;
    }

    const result = await submitTournamentCategoryForm({
      form,
      tournamentId,
      categoryId: normalizedCategoryId,
      statusElement: status,
      confirmedPlayers: confirmedPlayersCount,
    });
    if (result.success) {
      closeModal();
    }
  });

  const cancelButton = form.querySelector('[data-action="cancel"]');
  cancelButton?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  const deleteButton = form.querySelector('[data-action="delete"]');
  deleteButton?.addEventListener('click', async () => {
    if (!normalizedCategoryId || !resolvedTournamentId) {
      return;
    }
    const confirmed = window.confirm('¿Seguro que deseas eliminar esta categoría?');
    if (!confirmed) return;

    setStatusMessage(status, 'info', 'Eliminando categoría de torneo...');
    try {
      await request(`/tournaments/${resolvedTournamentId}/categories/${normalizedCategoryId}`, {
        method: 'DELETE',
      });
      setStatusMessage(status, 'success', 'Categoría eliminada correctamente.');
      closeModal();
      await reloadTournaments({ selectTournamentId: resolvedTournamentId });
      state.tournamentDetails.delete(resolvedTournamentId);
      await refreshTournamentDetail(resolvedTournamentId);
      showGlobalMessage('Categoría de torneo eliminada correctamente.');
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    }
  });

  openModal({
    title: editing ? 'Editar categoría de torneo' : 'Nueva categoría de torneo',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

async function openTournamentCategoryEnrollmentModal(tournamentId, categoryId) {
  if (!isAdmin()) return;

  const resolvedTournamentId = normalizeId(tournamentId) || state.selectedTournamentCategoriesId;
  const resolvedCategoryId = normalizeId(categoryId);

  if (!resolvedTournamentId || !resolvedCategoryId) {
    showGlobalMessage('Selecciona un torneo y una categoría válidos.', 'error');
    return;
  }

  if (!state.tournamentDetails.has(resolvedTournamentId)) {
    try {
      await refreshTournamentDetail(resolvedTournamentId);
    } catch (error) {
      showGlobalMessage(error.message || 'No fue posible cargar el detalle del torneo.', 'error');
      return;
    }
  }

  const categories = getTournamentCategories(resolvedTournamentId);
  const category = categories.find((item) => normalizeId(item) === resolvedCategoryId);
  if (!category) {
    showGlobalMessage('Categoría de torneo no encontrada.', 'error');
    return;
  }

  try {
    await ensurePlayersLoaded();
  } catch (error) {
    showGlobalMessage(error.message || 'No fue posible cargar la lista de jugadores.', 'error');
    return;
  }

  const cacheKey = `${resolvedTournamentId}:${resolvedCategoryId}`;
  let enrollments = [];

  const container = document.createElement('div');
  container.className = 'enrollment-modal';

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const header = document.createElement('p');
  header.className = 'meta';
  header.textContent = `Jugadores inscritos en ${category.name || 'Categoría'}`;
  container.appendChild(header);

  const pendingHeader = document.createElement('p');
  pendingHeader.className = 'meta';
  pendingHeader.textContent = 'Solicitudes de inscripción pendientes';
  container.appendChild(pendingHeader);

  const pendingList = document.createElement('ul');
  pendingList.className = 'list compact';
  pendingList.innerHTML = '<li class="empty-state">Cargando solicitudes...</li>';
  container.appendChild(pendingList);

  const enrolledHeader = document.createElement('p');
  enrolledHeader.className = 'meta';
  enrolledHeader.textContent = 'Jugadores confirmados';
  container.appendChild(enrolledHeader);

  const enrolledList = document.createElement('ul');
  enrolledList.className = 'list compact';
  enrolledList.innerHTML = '<li class="empty-state">Cargando inscripciones...</li>';
  container.appendChild(enrolledList);

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Añadir jugador
      <select name="playerId" required>
        <option value="">Selecciona un jugador</option>
      </select>
    </label>
    <label data-shirt-size-wrapper hidden>
      Talla de camiseta
    </label>
    <div class="form-actions">
      <button type="submit" class="primary" disabled>Inscribir</button>
    </div>
  `;
  container.appendChild(form);
  container.appendChild(status);

  const playerSelect = form.elements.playerId;
  const submitButton = form.querySelector('button[type="submit"]');
  const shirtWrapper = form.querySelector('[data-shirt-size-wrapper]');

  const tournamentDetail =
    state.tournamentDetails.get(resolvedTournamentId) || getTournamentById(resolvedTournamentId);
  const requiresShirtSize = Boolean(tournamentDetail?.hasShirt);
  const rawShirtSizes = Array.isArray(tournamentDetail?.shirtSizes)
    ? tournamentDetail.shirtSizes
        .map((size) => (typeof size === 'string' ? size.trim() : ''))
        .filter((size, index, array) => size && array.indexOf(size) === index)
    : [];

  const allowedShirtSizes = rawShirtSizes
    .map((size) => size.toUpperCase())
    .filter((size, index, array) => size && array.indexOf(size) === index);
  let shirtField = null;
  let shirtFieldTouched = false;

  function applyDefaultShirtSize() {
    if (!requiresShirtSize || !shirtField) {
      return;
    }

    if (shirtFieldTouched) {
      return;
    }

    const playerId = playerSelect.value;
    const player = playerId
      ? state.players.find((item) => normalizeId(item) === playerId)
      : null;
    const defaultSize = player?.shirtSize ? String(player.shirtSize).trim().toUpperCase() : '';

    if (shirtField.tagName === 'SELECT') {
      if (defaultSize && allowedShirtSizes.includes(defaultSize)) {
        shirtField.value = defaultSize;
      } else {
        shirtField.value = '';
      }
    } else {
      shirtField.value = defaultSize || '';
    }
  }

  function renderShirtField() {
    if (!shirtWrapper) {
      return;
    }

    if (shirtField) {
      shirtField.remove();
      shirtField = null;
    }

    shirtFieldTouched = false;

    if (!requiresShirtSize) {
      shirtWrapper.hidden = true;
      return;
    }

    shirtWrapper.hidden = false;

    if (allowedShirtSizes.length) {
      const select = document.createElement('select');
      select.name = 'shirtSize';
      select.required = true;

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Selecciona una talla';
      select.appendChild(placeholder);

      allowedShirtSizes.forEach((size) => {
        const option = document.createElement('option');
        option.value = size;
        option.textContent = size;
        select.appendChild(option);
      });

      shirtField = select;
    } else {
      const input = document.createElement('input');
      input.type = 'text';
      input.name = 'shirtSize';
      input.required = true;
      input.placeholder = 'Indica la talla';
      input.maxLength = 20;
      shirtField = input;
    }

    shirtField.addEventListener('input', () => {
      shirtFieldTouched = true;
    });

    shirtWrapper.appendChild(shirtField);
    applyDefaultShirtSize();
  }

  renderShirtField();

  function renderEnrollmentLists() {
    const pendingEntries = enrollments.filter((entry) => entry?.status === 'pendiente');
    const confirmedEntries = enrollments.filter((entry) => entry?.status === 'confirmada');
    const cancelledEntries = enrollments.filter((entry) => entry?.status === 'cancelada');

    pendingList.innerHTML = '';
    if (!pendingEntries.length) {
      pendingList.innerHTML = '<li class="empty-state">No hay solicitudes pendientes.</li>';
    } else {
      pendingEntries.forEach((entry) => {
        const item = document.createElement('li');
        const name = document.createElement('strong');
        name.textContent = entry?.user?.fullName || entry?.user?.email || 'Jugador';
        item.appendChild(name);

        const meta = document.createElement('div');
        meta.className = 'meta';

        const statusValue = entry?.status || 'pendiente';
        const statusTag = document.createElement('span');
        statusTag.className = `tag status-${statusValue}`;
        statusTag.textContent = formatTournamentEnrollmentStatusLabel(statusValue);
        meta.appendChild(statusTag);

        if (entry?.user?.email) {
          const emailSpan = document.createElement('span');
          emailSpan.textContent = entry.user.email;
          meta.appendChild(emailSpan);
        }

        if (entry?.user?.phone) {
          const phoneSpan = document.createElement('span');
          phoneSpan.textContent = entry.user.phone;
          meta.appendChild(phoneSpan);
        }

        if (entry?.shirtSize) {
          const shirtSpan = document.createElement('span');
          shirtSpan.textContent = `Talla: ${entry.shirtSize}`;
          meta.appendChild(shirtSpan);
        }

        item.appendChild(meta);

        const confirmButton = document.createElement('button');
        confirmButton.type = 'button';
        confirmButton.className = 'primary';
        confirmButton.dataset.enrollmentAction = 'update-status';
        confirmButton.dataset.enrollmentId = normalizeId(entry);
        confirmButton.dataset.targetStatus = 'confirmada';
        confirmButton.textContent = 'Confirmar';
        item.appendChild(confirmButton);

        const cancelButton = document.createElement('button');
        cancelButton.type = 'button';
        cancelButton.className = 'ghost';
        cancelButton.dataset.enrollmentAction = 'update-status';
        cancelButton.dataset.enrollmentId = normalizeId(entry);
        cancelButton.dataset.targetStatus = 'cancelada';
        cancelButton.textContent = 'Marcar como cancelada';
        item.appendChild(cancelButton);

        pendingList.appendChild(item);
      });
    }

    enrolledList.innerHTML = '';
    if (!confirmedEntries.length && !cancelledEntries.length) {
      enrolledList.innerHTML = '<li class="empty-state">Aún no hay jugadores inscritos en esta categoría.</li>';
    } else {
      confirmedEntries.forEach((entry) => {
        const item = document.createElement('li');
        const name = document.createElement('strong');
        name.textContent = entry?.user?.fullName || entry?.user?.email || 'Jugador';
        item.appendChild(name);

        const meta = document.createElement('div');
        meta.className = 'meta';

        const statusValue = entry?.status || 'confirmada';
        const statusTag = document.createElement('span');
        statusTag.className = `tag status-${statusValue}`;
        statusTag.textContent = formatTournamentEnrollmentStatusLabel(statusValue);
        meta.appendChild(statusTag);

        if (entry?.user?.email) {
          meta.appendChild(document.createElement('span')).textContent = entry.user.email;
        }

        if (entry?.user?.phone) {
          meta.appendChild(document.createElement('span')).textContent = entry.user.phone;
        }

        if (entry?.shirtSize) {
          meta.appendChild(document.createElement('span')).textContent = `Talla: ${entry.shirtSize}`;
        }

        item.appendChild(meta);

        const cancelButton = document.createElement('button');
        cancelButton.type = 'button';
        cancelButton.className = 'ghost';
        cancelButton.dataset.enrollmentAction = 'update-status';
        cancelButton.dataset.enrollmentId = normalizeId(entry);
        cancelButton.dataset.targetStatus = 'cancelada';
        cancelButton.textContent = 'Marcar como cancelada';
        item.appendChild(cancelButton);

        const removeButton = document.createElement('button');
        removeButton.type = 'button';
        removeButton.className = 'ghost';
        removeButton.dataset.enrollmentAction = 'remove';
        removeButton.dataset.enrollmentId = normalizeId(entry);
        removeButton.textContent = 'Quitar';
        item.appendChild(removeButton);

        enrolledList.appendChild(item);
      });

      cancelledEntries.forEach((entry) => {
        const item = document.createElement('li');
        const name = document.createElement('strong');
        name.textContent = entry?.user?.fullName || entry?.user?.email || 'Jugador';
        item.appendChild(name);

        const meta = document.createElement('div');
        meta.className = 'meta';

        const statusValue = entry?.status || 'cancelada';
        const statusTag = document.createElement('span');
        statusTag.className = `tag status-${statusValue}`;
        statusTag.textContent = formatTournamentEnrollmentStatusLabel(statusValue);
        meta.appendChild(statusTag);

        if (entry?.user?.email) {
          meta.appendChild(document.createElement('span')).textContent = entry.user.email;
        }

        if (entry?.user?.phone) {
          meta.appendChild(document.createElement('span')).textContent = entry.user.phone;
        }

        if (entry?.shirtSize) {
          meta.appendChild(document.createElement('span')).textContent = `Talla: ${entry.shirtSize}`;
        }

        item.appendChild(meta);

        const restoreButton = document.createElement('button');
        restoreButton.type = 'button';
        restoreButton.className = 'ghost';
        restoreButton.dataset.enrollmentAction = 'update-status';
        restoreButton.dataset.enrollmentId = normalizeId(entry);
        restoreButton.dataset.targetStatus = 'pendiente';
        restoreButton.textContent = 'Reactivar';
        item.appendChild(restoreButton);

        const removeButton = document.createElement('button');
        removeButton.type = 'button';
        removeButton.className = 'ghost';
        removeButton.dataset.enrollmentAction = 'remove';
        removeButton.dataset.enrollmentId = normalizeId(entry);
        removeButton.textContent = 'Eliminar';
        item.appendChild(removeButton);

        enrolledList.appendChild(item);
      });
    }
  }

  function refreshPlayerOptions() {
    const enrolledIds = new Set(
      enrollments.map((entry) => normalizeId(entry?.user)).filter((value) => Boolean(value))
    );

    const availablePlayers = state.players
      .filter((player) => entityHasRole(player, 'player'))
      .filter((player) => !enrolledIds.has(normalizeId(player)))
      .sort((a, b) => (a.fullName || '').localeCompare(b.fullName || '', 'es'));

    playerSelect.innerHTML = '';
    if (!availablePlayers.length) {
      playerSelect.innerHTML = '<option value="">Sin jugadores disponibles</option>';
      playerSelect.disabled = true;
      submitButton.disabled = true;
      shirtFieldTouched = false;
      applyDefaultShirtSize();
      return;
    }

    const placeholder = document.createElement('option');
    placeholder.value = '';
    placeholder.textContent = 'Selecciona un jugador';
    playerSelect.appendChild(placeholder);

    availablePlayers.forEach((player) => {
      const option = document.createElement('option');
      option.value = normalizeId(player);
      option.textContent = player.fullName || player.email || 'Jugador';
      playerSelect.appendChild(option);
    });

    playerSelect.disabled = false;
    submitButton.disabled = !playerSelect.value;
    applyDefaultShirtSize();
  }

  async function loadEnrollmentData({ force = false } = {}) {
    try {
      const list = await fetchTournamentEnrollments(resolvedTournamentId, resolvedCategoryId, {
        forceReload: force,
      });
      enrollments = Array.isArray(list) ? list : [];
      renderEnrollmentLists();
      refreshPlayerOptions();
      if (!force) {
        setStatusMessage(status, '', '');
      }
    } catch (error) {
      enrollments = [];
      pendingList.innerHTML = '<li class="empty-state">No fue posible cargar las inscripciones.</li>';
      enrolledList.innerHTML = '<li class="empty-state">No fue posible cargar las inscripciones.</li>';
      setStatusMessage(status, 'error', error.message || 'No fue posible cargar las inscripciones.');
    }
  }

  container.addEventListener('click', async (event) => {
    const actionButton = event.target.closest('button[data-enrollment-action]');
    if (!actionButton) {
      return;
    }

    const action = actionButton.dataset.enrollmentAction;
    const enrollmentId = normalizeId(actionButton.dataset.enrollmentId);
    if (!enrollmentId) {
      return;
    }

    const parentItem = actionButton.closest('li');
    const relatedButtons = parentItem
      ? Array.from(parentItem.querySelectorAll('button[data-enrollment-action]'))
      : [actionButton];

    relatedButtons.forEach((button) => {
      button.disabled = true;
    });

    if (action === 'update-status') {
      const targetStatus = actionButton.dataset.targetStatus;
      if (!targetStatus) {
        relatedButtons.forEach((button) => {
          button.disabled = false;
        });
        return;
      }

      setStatusMessage(status, 'info', 'Actualizando inscripción...');
      try {
        await request(
          `/tournaments/${resolvedTournamentId}/categories/${resolvedCategoryId}/enrollments/${enrollmentId}`,
          {
            method: 'PATCH',
            body: { status: targetStatus },
          }
        );
        state.tournamentEnrollments.delete(cacheKey);
        state.tournamentEnrollments.delete(
          getTournamentEnrollmentCacheKey(
            resolvedTournamentId,
            TOURNAMENT_ENROLLMENT_ALL_OPTION
          )
        );
        await loadEnrollmentData({ force: true });
        await reloadTournaments({ selectTournamentId: resolvedTournamentId });
        state.tournamentDetails.delete(resolvedTournamentId);
        await refreshTournamentDetail(resolvedTournamentId);
        if (
          state.selectedEnrollmentTournamentId === resolvedTournamentId &&
          (state.selectedEnrollmentCategoryId === resolvedCategoryId ||
            state.selectedEnrollmentCategoryId === TOURNAMENT_ENROLLMENT_ALL_OPTION)
        ) {
          await refreshTournamentEnrollments({ forceReload: true });
        }
        setStatusMessage(status, 'success', 'Inscripción actualizada correctamente.');
      } catch (error) {
        setStatusMessage(status, 'error', error.message || 'No fue posible actualizar la inscripción.');
      } finally {
        relatedButtons.forEach((button) => {
          button.disabled = false;
        });
        updateTournamentActionAvailability();
      }
      return;
    }

    if (action === 'remove') {
      setStatusMessage(status, 'info', 'Eliminando inscripción...');
      try {
        await request(
          `/tournaments/${resolvedTournamentId}/categories/${resolvedCategoryId}/enrollments/${enrollmentId}`,
          { method: 'DELETE' }
        );
        state.tournamentEnrollments.delete(cacheKey);
        state.tournamentEnrollments.delete(
          getTournamentEnrollmentCacheKey(
            resolvedTournamentId,
            TOURNAMENT_ENROLLMENT_ALL_OPTION
          )
        );
        await loadEnrollmentData({ force: true });
        await reloadTournaments({ selectTournamentId: resolvedTournamentId });
        state.tournamentDetails.delete(resolvedTournamentId);
        await refreshTournamentDetail(resolvedTournamentId);
        if (
          state.selectedEnrollmentTournamentId === resolvedTournamentId &&
          (state.selectedEnrollmentCategoryId === resolvedCategoryId ||
            state.selectedEnrollmentCategoryId === TOURNAMENT_ENROLLMENT_ALL_OPTION)
        ) {
          await refreshTournamentEnrollments({ forceReload: true });
        }
        setStatusMessage(status, 'success', 'Inscripción eliminada correctamente.');
      } catch (error) {
        setStatusMessage(status, 'error', error.message || 'No fue posible eliminar la inscripción.');
      } finally {
        relatedButtons.forEach((button) => {
          button.disabled = false;
        });
        updateTournamentActionAvailability();
      }
    }
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const playerId = playerSelect.value;
    if (!playerId) {
      setStatusMessage(status, 'error', 'Selecciona un jugador.');
      return;
    }

    let shirtSizeValue = '';
    if (requiresShirtSize && shirtField) {
      shirtSizeValue = (shirtField.value || '').trim().toUpperCase();
      if (!shirtSizeValue) {
        setStatusMessage(status, 'error', 'Indica la talla de camiseta.');
        if (typeof shirtField.focus === 'function') {
          shirtField.focus();
        }
        return;
      }
    }

    submitButton.disabled = true;
    setStatusMessage(status, 'info', 'Inscribiendo jugador...');

    try {
      const payload = { userId: playerId };
      if (shirtSizeValue) {
        payload.shirtSize = shirtSizeValue;
      }

      await request(`/tournaments/${resolvedTournamentId}/categories/${resolvedCategoryId}/enrollments`, {
        method: 'POST',
        body: payload,
      });
      playerSelect.value = '';
      shirtFieldTouched = false;
      applyDefaultShirtSize();
      state.tournamentEnrollments.delete(cacheKey);
      state.tournamentEnrollments.delete(
        getTournamentEnrollmentCacheKey(resolvedTournamentId, TOURNAMENT_ENROLLMENT_ALL_OPTION)
      );
      await loadEnrollmentData({ force: true });
      await reloadTournaments({ selectTournamentId: resolvedTournamentId });
      state.tournamentDetails.delete(resolvedTournamentId);
      await refreshTournamentDetail(resolvedTournamentId);
        if (
          state.selectedEnrollmentTournamentId === resolvedTournamentId &&
          (state.selectedEnrollmentCategoryId === resolvedCategoryId ||
            state.selectedEnrollmentCategoryId === TOURNAMENT_ENROLLMENT_ALL_OPTION)
        ) {
          await refreshTournamentEnrollments({ forceReload: true });
        }
      refreshPlayerOptions();
      setStatusMessage(status, 'success', 'Jugador inscrito correctamente.');
    } catch (error) {
      setStatusMessage(status, 'error', error.message || 'No fue posible inscribir al jugador.');
    } finally {
      submitButton.disabled = false;
      updateTournamentActionAvailability();
    }
  });

  playerSelect.addEventListener('change', () => {
    submitButton.disabled = !playerSelect.value;
    shirtFieldTouched = false;
    applyDefaultShirtSize();
  });

  openModal({
    title: `Inscripciones · ${category.name || 'Categoría'}`,
    content: (body) => {
      body.appendChild(container);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });

  await loadEnrollmentData({ force: true });
}

async function openTournamentEnrollmentModal() {
  if (!isAdmin()) return;
  const tournaments = Array.isArray(state.tournaments) ? [...state.tournaments] : [];
  if (!tournaments.length) {
    showGlobalMessage('Registra un torneo antes de inscribir jugadores.', 'error');
    return;
  }

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Torneo
      <select name="tournamentId" required></select>
    </label>
    <label>
      Categoría
      <select name="categoryId" required disabled>
        <option value="">Selecciona un torneo</option>
      </select>
    </label>
    <label>
      Jugador
      <select name="playerId" required disabled>
        <option value="">Selecciona una categoría</option>
      </select>
    </label>
    <label data-shirt-size-wrapper hidden>
      Talla de camiseta
    </label>
    <div class="form-actions">
      <button type="submit" class="primary" disabled>Inscribir jugador</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const tournamentSelect = form.elements.tournamentId;
  const categorySelect = form.elements.categoryId;
  const playerSelect = form.elements.playerId;
  const shirtWrapper = form.querySelector('[data-shirt-size-wrapper]');
  const submitButton = form.querySelector('button[type="submit"]');

  let shirtField = null;
  let shirtFieldTouched = false;
  let requiresShirtSize = false;
  let allowedShirtSizes = [];

  function getSelectedTournamentDetail() {
    const tournamentId = tournamentSelect.value;
    if (!tournamentId) {
      return null;
    }
    return state.tournamentDetails.get(tournamentId) || getTournamentById(tournamentId);
  }

  function applyDefaultShirtSize() {
    if (!requiresShirtSize || !shirtField) {
      return;
    }

    if (shirtFieldTouched) {
      return;
    }

    const playerId = playerSelect.value;
    const player = playerId
      ? state.players.find((item) => normalizeId(item) === playerId)
      : null;
    const defaultSize = player?.shirtSize ? String(player.shirtSize).trim().toUpperCase() : '';

    if (shirtField.tagName === 'SELECT') {
      if (defaultSize && allowedShirtSizes.includes(defaultSize)) {
        shirtField.value = defaultSize;
      } else {
        shirtField.value = '';
      }
    } else {
      shirtField.value = defaultSize || '';
    }
  }

  function renderShirtField() {
    if (!shirtWrapper) {
      return;
    }

    if (shirtField) {
      shirtField.remove();
      shirtField = null;
    }

    const detail = getSelectedTournamentDetail();
    requiresShirtSize = Boolean(detail?.hasShirt);

    const rawSizes = Array.isArray(detail?.shirtSizes)
      ? detail.shirtSizes
          .map((size) => (typeof size === 'string' ? size.trim() : ''))
          .filter((size, index, array) => size && array.indexOf(size) === index)
      : [];

    allowedShirtSizes = rawSizes
      .map((size) => size.toUpperCase())
      .filter((size, index, array) => size && array.indexOf(size) === index);
    shirtFieldTouched = false;

    if (!requiresShirtSize) {
      shirtWrapper.hidden = true;
      return;
    }

    shirtWrapper.hidden = false;

    if (allowedShirtSizes.length) {
      const select = document.createElement('select');
      select.name = 'shirtSize';
      select.required = true;

      const placeholder = document.createElement('option');
      placeholder.value = '';
      placeholder.textContent = 'Selecciona una talla';
      select.appendChild(placeholder);

      allowedShirtSizes.forEach((size) => {
        const option = document.createElement('option');
        option.value = size;
        option.textContent = size;
        select.appendChild(option);
      });

      shirtField = select;
    } else {
      const input = document.createElement('input');
      input.type = 'text';
      input.name = 'shirtSize';
      input.required = true;
      input.placeholder = 'Indica la talla';
      input.maxLength = 20;
      shirtField = input;
    }

    shirtField.addEventListener('input', () => {
      shirtFieldTouched = true;
    });

    shirtWrapper.appendChild(shirtField);
    applyDefaultShirtSize();
  }

  tournaments
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
    .forEach((tournament) => {
      const option = document.createElement('option');
      option.value = normalizeId(tournament);
      option.textContent = tournament.name || 'Torneo';
      tournamentSelect.appendChild(option);
    });

  const preferredTournamentId = normalizeId(
    state.selectedEnrollmentTournamentId || state.selectedTournamentId
  );
  if (
    preferredTournamentId &&
    Array.from(tournamentSelect.options).some((option) => option.value === preferredTournamentId)
  ) {
    tournamentSelect.value = preferredTournamentId;
  }

  async function populateCategories(tournamentId) {
    categorySelect.innerHTML = '<option value="">Selecciona una categoría</option>';
    categorySelect.disabled = true;

    if (!tournamentId) {
      renderShirtField();
      playerSelect.innerHTML = '<option value="">Selecciona una categoría</option>';
      playerSelect.disabled = true;
      submitButton.disabled = true;
      return;
    }

    if (!state.tournamentDetails.has(tournamentId)) {
      await refreshTournamentDetail(tournamentId);
    }

    renderShirtField();

    const categories = getTournamentCategories(tournamentId);
    categories
      .slice()
      .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
      .forEach((category) => {
        const id = normalizeId(category);
        if (!id) return;
        const option = document.createElement('option');
        option.value = id;
        option.textContent = category.menuTitle || category.name || 'Categoría';
        categorySelect.appendChild(option);
      });

    categorySelect.disabled = !categories.length;

    if (categories.length) {
      const preferredCategory = normalizeId(state.selectedEnrollmentCategoryId);
      if (
        preferredCategory &&
        categories.some((category) => normalizeId(category) === preferredCategory)
      ) {
        categorySelect.value = preferredCategory;
      }
    }

    await updatePlayerOptions();
  }

  async function updatePlayerOptions() {
    const tournamentId = tournamentSelect.value;
    const categoryId = categorySelect.value;
    playerSelect.innerHTML = '<option value="">Selecciona un jugador</option>';
    playerSelect.disabled = true;
    submitButton.disabled = true;

    if (!tournamentId || !categoryId) {
      shirtFieldTouched = false;
      applyDefaultShirtSize();
      return;
    }

    try {
      await ensurePlayersLoaded();
    } catch (error) {
      return;
    }

    let enrollments = [];
    try {
      enrollments = await fetchTournamentEnrollments(tournamentId, categoryId);
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
      shirtFieldTouched = false;
      applyDefaultShirtSize();
      return;
    }

    const enrolledIds = new Set(
      enrollments.map((enrollment) => normalizeId(enrollment.user)).filter(Boolean)
    );

    const availablePlayers = state.players
      .filter((player) => entityHasRole(player, 'player'))
      .filter((player) => !enrolledIds.has(normalizeId(player)))
      .sort((a, b) => (a.fullName || '').localeCompare(b.fullName || '', 'es'));

    if (!availablePlayers.length) {
      playerSelect.innerHTML = '<option value="">Sin jugadores disponibles</option>';
      playerSelect.disabled = true;
      submitButton.disabled = true;
      shirtFieldTouched = false;
      applyDefaultShirtSize();
      return;
    }

    availablePlayers.forEach((player) => {
      const option = document.createElement('option');
      option.value = normalizeId(player);
      option.textContent = player.fullName || player.email || 'Jugador';
      playerSelect.appendChild(option);
    });

    playerSelect.disabled = false;
    submitButton.disabled = !playerSelect.value;
    applyDefaultShirtSize();
    setStatusMessage(status, '', '');
  }

  tournamentSelect.addEventListener('change', async (event) => {
    setStatusMessage(status, '', '');
    await populateCategories(event.target.value);
    updateTournamentActionAvailability();
  });

  categorySelect.addEventListener('change', async () => {
    setStatusMessage(status, '', '');
    shirtFieldTouched = false;
    await updatePlayerOptions();
    updateTournamentActionAvailability();
  });

  playerSelect.addEventListener('change', () => {
    submitButton.disabled = !playerSelect.value;
    shirtFieldTouched = false;
    applyDefaultShirtSize();
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const tournamentId = tournamentSelect.value;
    const categoryId = categorySelect.value;
    const playerId = playerSelect.value;
    if (!tournamentId || !categoryId || !playerId) {
      setStatusMessage(status, 'error', 'Selecciona torneo, categoría y jugador.');
      return;
    }

    let shirtSizeValue = '';
    if (requiresShirtSize && shirtField) {
      shirtSizeValue = (shirtField.value || '').trim().toUpperCase();
      if (!shirtSizeValue) {
        setStatusMessage(status, 'error', 'Indica la talla de camiseta.');
        if (typeof shirtField.focus === 'function') {
          shirtField.focus();
        }
        return;
      }
    }

    setStatusMessage(status, 'info', 'Inscribiendo jugador...');
    submitButton.disabled = true;

    try {
      const payload = { userId: playerId };
      if (shirtSizeValue) {
        payload.shirtSize = shirtSizeValue;
      }

      await request(`/tournaments/${tournamentId}/categories/${categoryId}/enrollments`, {
        method: 'POST',
        body: payload,
      });
      state.tournamentEnrollments.delete(`${tournamentId}:${categoryId}`);
      state.tournamentEnrollments.delete(
        getTournamentEnrollmentCacheKey(tournamentId, TOURNAMENT_ENROLLMENT_ALL_OPTION)
      );
      await fetchTournamentEnrollments(tournamentId, categoryId, { forceReload: true });
      if (state.selectedEnrollmentTournamentId === tournamentId) {
        state.selectedEnrollmentCategoryId = categoryId;
        await refreshTournamentEnrollments({ forceReload: true });
      }
      state.tournamentDetails.delete(tournamentId);
      await refreshTournamentDetail(tournamentId);
      updateTournamentActionAvailability();
      setStatusMessage(status, 'success', 'Jugador inscrito correctamente.');
      closeModal();
    } catch (error) {
      submitButton.disabled = false;
      setStatusMessage(status, 'error', error.message);
    }
  });

  const cancelButton = form.querySelector('[data-action="cancel"]');
  cancelButton?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  openModal({
    title: 'Inscribir jugador en torneo',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });

  populateCategories(tournamentSelect.value);
}

async function openTournamentDrawModal() {
  if (!isAdmin()) return;
  const tournaments = Array.isArray(state.tournaments) ? [...state.tournaments] : [];
  if (!tournaments.length) {
    showGlobalMessage('Registra un torneo antes de generar cuadros.', 'error');
    return;
  }

  const defaultTournamentId = normalizeId(
    state.selectedMatchTournamentId || state.selectedTournamentId
  );
  const defaultCategoryId = normalizeId(state.selectedMatchCategoryId);

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Torneo
      <select name="tournamentId" required></select>
    </label>
    <label>
      Categoría
      <select name="categoryId" required disabled>
        <option value="">Selecciona un torneo</option>
      </select>
    </label>
    <fieldset class="form-section" data-match-section>
      <div class="form-section__header">
        <h3>Partidos del cuadro</h3>
        <button type="button" class="secondary" data-action="add-match">Añadir partido</button>
      </div>
      <p class="form-hint" data-match-hint>
        Añade los emparejamientos para iniciar el cuadro del torneo.
      </p>
      <div data-match-list></div>
    </fieldset>
    <label class="checkbox-option">
      <input type="checkbox" name="replaceExisting" value="true" />
      Reemplazar los partidos existentes de esta categoría
    </label>
    <div class="form-actions">
      <button type="submit" class="primary" disabled>Generar cuadro</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const tournamentSelect = form.elements.tournamentId;
  const categorySelect = form.elements.categoryId;
  const submitButton = form.querySelector('button[type="submit"]');
  const addMatchButton = form.querySelector('[data-action="add-match"]');
  const matchList = form.querySelector('[data-match-list]');
  const matchHint = form.querySelector('[data-match-hint]');

  tournaments
    .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
    .forEach((tournament) => {
      const option = document.createElement('option');
      option.value = normalizeId(tournament);
      option.textContent = tournament.name || 'Torneo';
      tournamentSelect.appendChild(option);
    });

  if (
    defaultTournamentId &&
    Array.from(tournamentSelect.options).some((option) => option.value === defaultTournamentId)
  ) {
    tournamentSelect.value = defaultTournamentId;
  }

  let currentEnrollments = [];

  function updateMatchControlsAvailability() {
    const hasPlayers = Array.isArray(currentEnrollments) && currentEnrollments.length >= 2;
    const hasCategory = Boolean(categorySelect.value);
    if (matchHint) {
      if (!hasCategory) {
        matchHint.textContent = 'Selecciona un torneo y categoría para comenzar.';
        matchHint.hidden = false;
      } else if (!hasPlayers) {
        matchHint.textContent =
          'Necesitas al menos dos jugadores inscritos en la categoría para generar el cuadro.';
        matchHint.hidden = false;
      } else {
        matchHint.textContent = 'Define cada partido del cuadro en el orden deseado.';
        matchHint.hidden = true;
      }
    }
    if (addMatchButton) {
      addMatchButton.disabled = !hasPlayers;
    }
    submitButton.disabled = !hasPlayers || !matchList?.children.length;
  }

  function getAvailablePlayers() {
    return currentEnrollments
      .map((enrollment) => enrollment.user)
      .filter(Boolean)
      .sort((a, b) => (a.fullName || '').localeCompare(b.fullName || '', 'es'));
  }

  function populatePlayerSelect(select, selectedValue = '') {
    if (!select) return;
    const players = getAvailablePlayers();
    select.innerHTML = '<option value="">Selecciona un jugador</option>';
    players.forEach((player) => {
      const option = document.createElement('option');
      option.value = normalizeId(player);
      option.textContent = player.fullName || player.email || 'Jugador';
      select.appendChild(option);
    });
    if (selectedValue && players.some((player) => normalizeId(player) === selectedValue)) {
      select.value = selectedValue;
    }
  }

  function addMatchEntry(data = {}) {
    if (!matchList) return;
    const entry = document.createElement('div');
    entry.className = 'form-section';
    entry.dataset.matchEntry = 'true';
    entry.innerHTML = `
      <div class="form-grid">
        <label>
          Ronda
          <input type="text" data-match-field="round" placeholder="Ej. Cuartos de final" />
        </label>
        <label>
          Nº de partido
          <input type="number" min="1" step="1" data-match-field="matchNumber" />
        </label>
      </div>
      <div class="form-grid">
        <label>
          Jugador A
          <select data-match-field="playerA" required></select>
        </label>
        <label>
          Jugador B
          <select data-match-field="playerB" required></select>
        </label>
      </div>
      <div class="form-grid">
        <label>
          Pista (opcional)
          <input type="text" data-match-field="court" placeholder="Nombre de la pista" />
        </label>
        <label>
          Fecha y hora (opcional)
          <input type="datetime-local" data-match-field="scheduledAt" step="${CALENDAR_TIME_SLOT_STEP_SECONDS}" />
        </label>
      </div>
      <div class="form-actions">
        <button type="button" class="ghost" data-action="remove-match">Quitar partido</button>
      </div>
    `;

    const removeButton = entry.querySelector('[data-action="remove-match"]');
    removeButton?.addEventListener('click', () => {
      entry.remove();
      updateMatchControlsAvailability();
    });

    matchList.appendChild(entry);

    const roundField = entry.querySelector('[data-match-field="round"]');
    const matchNumberField = entry.querySelector('[data-match-field="matchNumber"]');
    const playerASelect = entry.querySelector('[data-match-field="playerA"]');
    const playerBSelect = entry.querySelector('[data-match-field="playerB"]');
    const scheduledField = entry.querySelector('[data-match-field="scheduledAt"]');
    const courtField = entry.querySelector('[data-match-field="court"]');

    populatePlayerSelect(playerASelect, normalizeId(data.playerA));
    populatePlayerSelect(playerBSelect, normalizeId(data.playerB));

    if (roundField && data.round) {
      roundField.value = data.round;
    }
    if (matchNumberField && typeof data.matchNumber !== 'undefined') {
      matchNumberField.value = data.matchNumber;
    }
    if (scheduledField && data.scheduledAt) {
      scheduledField.value = formatDateTimeLocal(data.scheduledAt);
    }
    if (courtField && data.court) {
      courtField.value = data.court;
    }

    playerASelect?.addEventListener('change', () => {
      updateMatchControlsAvailability();
    });
    playerBSelect?.addEventListener('change', () => {
      updateMatchControlsAvailability();
    });

    updateMatchControlsAvailability();
  }

  async function populateMatchesForCategory(tournamentId, categoryId) {
    if (!categoryId) {
      matchList.innerHTML = '';
      currentEnrollments = [];
      updateMatchControlsAvailability();
      return;
    }

    try {
      currentEnrollments = await fetchTournamentEnrollments(tournamentId, categoryId, {
        forceReload: true,
      });
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
      currentEnrollments = [];
    }

    matchList.innerHTML = '';
    updateMatchControlsAvailability();
  }

  async function populateCategories(tournamentId) {
    categorySelect.innerHTML = '<option value="">Selecciona una categoría</option>';
    categorySelect.disabled = true;
    currentEnrollments = [];

    if (!tournamentId) {
      matchList.innerHTML = '';
      updateMatchControlsAvailability();
      return;
    }

    if (!state.tournamentDetails.has(tournamentId)) {
      await refreshTournamentDetail(tournamentId);
    }

    const categories = getTournamentCategories(tournamentId);
    categories
      .slice()
      .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
      .forEach((category) => {
        const id = normalizeId(category);
        if (!id) return;
        const option = document.createElement('option');
        option.value = id;
        option.textContent = category.menuTitle || category.name || 'Categoría';
        categorySelect.appendChild(option);
      });

    categorySelect.disabled = !categories.length;

    if (categories.length && defaultCategoryId) {
      if (categories.some((category) => normalizeId(category) === defaultCategoryId)) {
        categorySelect.value = defaultCategoryId;
      }
    }

    await populateMatchesForCategory(tournamentId, categorySelect.value);
  }

  addMatchButton?.addEventListener('click', () => {
    addMatchEntry();
  });

  tournamentSelect.addEventListener('change', async (event) => {
    await populateCategories(event.target.value);
    updateTournamentActionAvailability();
  });

  categorySelect.addEventListener('change', async (event) => {
    await populateMatchesForCategory(tournamentSelect.value, event.target.value);
    updateTournamentActionAvailability();
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const tournamentId = tournamentSelect.value;
    const categoryId = categorySelect.value;
    if (!tournamentId || !categoryId) {
      setStatusMessage(status, 'error', 'Selecciona torneo y categoría.');
      return;
    }

    const entries = matchList ? Array.from(matchList.querySelectorAll('[data-match-entry]')) : [];
    if (!entries.length) {
      setStatusMessage(status, 'error', 'Añade al menos un partido al cuadro.');
      return;
    }

    const matches = [];
    for (const entry of entries) {
      const round = entry.querySelector('[data-match-field="round"]')?.value.trim();
      const matchNumberValue = entry.querySelector('[data-match-field="matchNumber"]')?.value;
      const playerA = entry.querySelector('[data-match-field="playerA"]')?.value;
      const playerB = entry.querySelector('[data-match-field="playerB"]')?.value;
      const scheduledAt = entry.querySelector('[data-match-field="scheduledAt"]')?.value;
      const court = entry.querySelector('[data-match-field="court"]')?.value.trim();

      if (!playerA || !playerB) {
        setStatusMessage(status, 'error', 'Selecciona ambos jugadores en cada partido.');
        return;
      }

      if (playerA === playerB) {
        setStatusMessage(status, 'error', 'Un partido no puede tener el mismo jugador en ambos lados.');
        return;
      }

      const parsedMatchNumber = Number.parseInt(matchNumberValue, 10);
      matches.push({
        round: round || undefined,
        matchNumber: Number.isNaN(parsedMatchNumber) ? undefined : parsedMatchNumber,
        players: [playerA, playerB],
        scheduledAt: scheduledAt || undefined,
        court: court || undefined,
      });
    }

    const replaceExisting = form.elements.replaceExisting?.checked || false;

    if (replaceExisting) {
      const confirmed = await openConfirmationDialog({
        title: 'Generar nuevo cuadro',
        message: TOURNAMENT_BRACKET_RESULTS_REPLACEMENT_CONFIRMATION,
        confirmLabel: 'Generar nuevo cuadro',
        cancelLabel: 'Cancelar',
      });
      if (!confirmed) {
        setStatusMessage(status, '', '');
        return;
      }
    }

    setStatusMessage(status, 'info', 'Generando cuadro...');
    submitButton.disabled = true;

    try {
      await request(`/tournaments/${tournamentId}/categories/${categoryId}/matches/generate`, {
        method: 'POST',
        body: { matches, replaceExisting },
      });
      state.tournamentMatches.delete(`${tournamentId}:${categoryId}`);
      recomputeTournamentOrderOfPlayDays(tournamentId);
      state.tournamentDetails.delete(tournamentId);
      state.selectedMatchTournamentId = tournamentId;
      state.selectedMatchCategoryId = categoryId;
      await refreshTournamentDetail(tournamentId);
      await refreshTournamentMatches({ forceReload: true });
      updateTournamentActionAvailability();
      setStatusMessage(status, 'success', 'Cuadro generado correctamente.');
      closeModal();
    } catch (error) {
      submitButton.disabled = false;
      setStatusMessage(status, 'error', error.message);
    }
  });

  const cancelButton = form.querySelector('[data-action="cancel"]');
  cancelButton?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  openModal({
    title: 'Generar cuadro de torneo',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });

  await populateCategories(tournamentSelect.value);
  updateMatchControlsAvailability();
}

function buildPlayerPayload(formData, isEditing = false) {
  const payload = {
    fullName: (formData.get('fullName') || '').trim(),
    email: (formData.get('email') || '').trim(),
    gender: formData.get('gender'),
    phone: (formData.get('phone') || '').trim(),
    preferredSchedule: formData.get('preferredSchedule'),
    birthDate: formData.get('birthDate'),
  };

  const shirtSizeRaw = (formData.get('shirtSize') || '').trim().toUpperCase();
  if (shirtSizeRaw) {
    payload.shirtSize = shirtSizeRaw;
  }

  const roles = formData
    .getAll('roles')
    .map((value) => (typeof value === 'string' ? value.toLowerCase() : ''))
    .filter(Boolean);
  let normalizedRoles = roles.length ? roles : ['player'];
  if (normalizedRoles.includes('admin')) {
    normalizedRoles = normalizedRoles.filter((role) => role !== 'player');
  } else if (!normalizedRoles.includes('player')) {
    normalizedRoles.push('player');
  }
  const uniqueRoles = Array.from(new Set(normalizedRoles));
  payload.roles = uniqueRoles.length ? uniqueRoles : ['player'];

  const notes = (formData.get('notes') || '').trim();
  if (notes || isEditing) {
    payload.notes = notes;
  }

  payload.notifyMatchRequests = formData.has('notifyMatchRequests');
  payload.notifyMatchResults = formData.has('notifyMatchResults');

  const isMember = formData.has('isMember');
  payload.isMember = isMember;

  const membershipNumber = (formData.get('membershipNumber') || '').trim();
  if (isMember) {
    payload.membershipNumber = membershipNumber;
    payload.membershipNumberVerified = formData.has('membershipNumberVerified');
  } else {
    if (isEditing) {
      payload.membershipNumber = '';
    }
    payload.membershipNumberVerified = false;
  }

  const password = formData.get('password');
  if (password) {
    payload.password = password;
  }

  return payload;
}

async function submitPlayerFormData({ form, playerId, statusElement }) {
  if (!form) return false;
  const formData = new FormData(form);
  const isEditing = Boolean(playerId);
  const payload = buildPlayerPayload(formData, isEditing);

  if (!payload.fullName || !payload.email || !payload.phone || !payload.birthDate) {
    setStatusMessage(
      statusElement,
      'error',
      'Nombre, correo, teléfono y fecha de nacimiento son obligatorios.'
    );
    return false;
  }

  if (!payload.shirtSize) {
    setStatusMessage(statusElement, 'error', 'Selecciona una talla de camiseta.');
    return false;
  }

  if (payload.isMember && !payload.membershipNumber) {
    setStatusMessage(
      statusElement,
      'error',
      'Indica el número de socio para los usuarios marcados como socios.'
    );
    return false;
  }

  if (!isEditing && !payload.password) {
    setStatusMessage(statusElement, 'error', 'Asigna una contraseña para el nuevo usuario.');
    return false;
  }

  setStatusMessage(
    statusElement,
    'info',
    isEditing ? 'Actualizando usuario...' : 'Creando usuario...'
  );

  try {
    const photoData = await extractPhotoFromForm(form);
    if (photoData) {
      payload.photo = photoData;
    }

    const url = isEditing ? `/players/${playerId}` : '/players';
    const method = isEditing ? 'PATCH' : 'POST';
    await request(url, { method, body: payload });
    setStatusMessage(
      statusElement,
      'success',
      isEditing ? 'Usuario actualizado.' : 'Usuario creado.'
    );
    await loadAllData();
    return true;
  } catch (error) {
    setStatusMessage(statusElement, 'error', error.message);
    return false;
  }
}

function buildMatchPayload(formData, isEditing = false) {
  const payload = {};
  const categoryId = formData.get('categoryId');
  if (categoryId) {
    payload.categoryId = categoryId;
  }

  const scheduledAt = formData.get('scheduledAt');
  if (scheduledAt) {
    payload.scheduledAt = scheduledAt;
  } else if (isEditing) {
    payload.scheduledAt = null;
  }

  const courtValue = (formData.get('court') || '').toString().trim();
  if (courtValue) {
    payload.court = courtValue;
  } else if (isEditing) {
    payload.court = null;
  }

  const status = formData.get('status');
  if (status) {
    payload.status = status;
  }

  const notes = (formData.get('notes') || '').trim();
  if (notes) {
    payload.notes = notes;
  } else if (isEditing) {
    payload.notes = null;
  }

  return payload;
}

async function submitMatchFormData({ form, matchId, statusElement, creating = false }) {
  if (!form) return false;
  const formData = new FormData(form);
  const isEditing = !creating && Boolean(matchId);
  const payload = buildMatchPayload(formData, isEditing);

  if (payload.scheduledAt) {
    const scheduledDate = new Date(payload.scheduledAt);
    if (Number.isNaN(scheduledDate.getTime())) {
      setStatusMessage(statusElement, 'error', 'Selecciona una fecha y hora válidas.');
      return false;
    }
    if (!isValidReservationSlotStart(scheduledDate)) {
      setStatusMessage(
        statusElement,
        'error',
        'Selecciona un horario válido de 75 minutos entre las 08:30 y las 22:15.'
      );
      return false;
    }
  }

  const player1 = formData.get('player1');
  const player2 = formData.get('player2');
  const selectedPlayers = [player1, player2].filter(Boolean);

  if (selectedPlayers.length === 1) {
    setStatusMessage(statusElement, 'error', 'Selecciona ambos jugadores para el partido.');
    return false;
  }

  if (selectedPlayers.length === 2) {
    if (selectedPlayers[0] === selectedPlayers[1]) {
      setStatusMessage(statusElement, 'error', 'Los jugadores deben ser distintos.');
      return false;
    }
    payload.players = selectedPlayers;
  } else if (creating) {
    setStatusMessage(statusElement, 'error', 'Selecciona dos jugadores para crear el partido.');
    return false;
  }

  if (creating && !payload.categoryId) {
    setStatusMessage(statusElement, 'error', 'Selecciona una categoría para el partido.');
    return false;
  }

  setStatusMessage(
    statusElement,
    'info',
    creating ? 'Creando partido...' : 'Actualizando partido...'
  );

  try {
    const url = creating ? '/matches' : `/matches/${matchId}`;
    const method = creating ? 'POST' : 'PATCH';
    await request(url, { method, body: payload });
    setStatusMessage(
      statusElement,
      'success',
      creating ? 'Partido creado.' : 'Partido actualizado.'
    );
    await loadAllData();
    return true;
  } catch (error) {
    setStatusMessage(statusElement, 'error', error.message);
    return false;
  }
}

async function submitTournamentMatchSchedule({
  form,
  tournamentId,
  categoryId,
  matchId,
  statusElement,
  submitButton,
} = {}) {
  if (!form || !tournamentId || !categoryId || !matchId) {
    return false;
  }

  const normalizedTournamentId = normalizeId(tournamentId);
  const normalizedCategoryId = normalizeId(categoryId);
  const normalizedMatchId = normalizeId(matchId);

  if (!normalizedTournamentId || !normalizedCategoryId || !normalizedMatchId) {
    setStatusMessage(statusElement, 'error', 'Selecciona un torneo y partido válidos.');
    return false;
  }

  const formData = new FormData(form);
  const scheduledAtRaw = (formData.get('scheduledAt') || '').toString();
  const statusValue = (formData.get('status') || '').toString();
  const notifyPlayers = formData.get('notifyPlayers') === 'true';
  const courtValue = (formData.get('court') || '').toString().trim();

  if (scheduledAtRaw) {
    const scheduledDate = new Date(scheduledAtRaw);
    if (Number.isNaN(scheduledDate.getTime())) {
      setStatusMessage(statusElement, 'error', 'Selecciona una fecha y hora válidas.');
      return false;
    }
    if (!isValidReservationSlotStart(scheduledDate)) {
      setStatusMessage(
        statusElement,
        'error',
        'Selecciona un horario válido de 75 minutos entre las 08:30 y las 22:15.'
      );
      return false;
    }
  }

  if (!scheduledAtRaw && ['programado', 'confirmado'].includes(statusValue)) {
    setStatusMessage(
      statusElement,
      'error',
      'Asigna día y hora antes de marcar el partido como programado o confirmado.'
    );
    return false;
  }

  const payload = {
    scheduledAt: scheduledAtRaw || null,
  };

  if (statusValue) {
    payload.status = statusValue;
  }

  payload.court = courtValue || null;

  if (notifyPlayers) {
    payload.notifyPlayers = true;
  }

  setStatusMessage(statusElement, 'info', 'Guardando horario del partido...');
  if (submitButton) {
    submitButton.disabled = true;
  }

  try {
    const updated = await request(
      `/tournaments/${normalizedTournamentId}/categories/${normalizedCategoryId}/matches/${normalizedMatchId}`,
      {
        method: 'PATCH',
        body: payload,
      }
    );

    await applyTournamentMatchUpdate(updated);

    const listKey = `${normalizedTournamentId}:${normalizedCategoryId}`;
    if (state.tournamentMatches instanceof Map && state.tournamentMatches.has(listKey)) {
      renderTournamentMatches(state.tournamentMatches.get(listKey) || []);
    }

    const bracketKey = getTournamentBracketCacheKey(normalizedTournamentId, normalizedCategoryId);
    if (bracketKey && state.tournamentBracketMatches instanceof Map) {
      const matches = state.tournamentBracketMatches.get(bracketKey);
      if (matches) {
        renderTournamentBracket(matches);
      }
    }

    setStatusMessage(statusElement, 'success', 'Horario guardado correctamente.');
    showGlobalMessage('Horario del partido actualizado.', 'success');
    return true;
  } catch (error) {
    setStatusMessage(statusElement, 'error', error.message);
    return false;
  } finally {
    if (submitButton) {
      submitButton.disabled = false;
    }
  }
}

async function submitTournamentMatchResult({
  form,
  tournamentId,
  categoryId,
  matchId,
  statusElement,
  submitButton,
} = {}) {
  if (!form || !tournamentId || !categoryId || !matchId) {
    return false;
  }

  const normalizedTournamentId = normalizeId(tournamentId);
  const normalizedCategoryId = normalizeId(categoryId);
  const normalizedMatchId = normalizeId(matchId);

  if (!normalizedTournamentId || !normalizedCategoryId || !normalizedMatchId) {
    setStatusMessage(statusElement, 'error', 'Selecciona un torneo y partido válidos.');
    return false;
  }

  const formData = new FormData(form);
  const winnerId = (formData.get('winner') || '').toString().trim();
  const scoreValue = (formData.get('score') || '').toString().trim();
  const notesValue = (formData.get('notes') || '').toString().trim();

  if (!winnerId) {
    setStatusMessage(statusElement, 'error', 'Selecciona el ganador del partido.');
    return false;
  }

  const payload = { winner: winnerId };
  if (scoreValue) {
    payload.score = scoreValue;
  }
  if (notesValue) {
    payload.notes = notesValue;
  }

  setStatusMessage(statusElement, 'info', 'Guardando resultado del partido...');
  if (submitButton) {
    submitButton.disabled = true;
  }

  try {
    const updated = await request(
      `/tournaments/${normalizedTournamentId}/categories/${normalizedCategoryId}/matches/${normalizedMatchId}/result/approve`,
      {
        method: 'POST',
        body: payload,
      }
    );

    await applyTournamentMatchUpdate(updated);

    const listKey = `${normalizedTournamentId}:${normalizedCategoryId}`;
    const hasMatchCache =
      state.tournamentMatches instanceof Map && state.tournamentMatches.has(listKey);
    if (hasMatchCache) {
      renderTournamentMatches(state.tournamentMatches.get(listKey) || []);
    }

    const bracketKey = getTournamentBracketCacheKey(normalizedTournamentId, normalizedCategoryId);
    const hasBracketCache =
      Boolean(bracketKey) &&
      state.tournamentBracketMatches instanceof Map &&
      state.tournamentBracketMatches.has(bracketKey);
    if (hasBracketCache) {
      renderTournamentBracket(state.tournamentBracketMatches.get(bracketKey) || []);
    }

    const matchesActive =
      hasMatchCache &&
      state.selectedMatchTournamentId === normalizedTournamentId &&
      state.selectedMatchCategoryId === normalizedCategoryId;
    if (matchesActive) {
      await refreshTournamentMatches({ forceReload: true });
    } else if (hasMatchCache) {
      state.tournamentMatches.delete(listKey);
      recomputeTournamentOrderOfPlayDays(normalizedTournamentId);
    }

    const bracketActive =
      hasBracketCache &&
      state.selectedBracketTournamentId === normalizedTournamentId &&
      state.selectedBracketCategoryId === normalizedCategoryId;
    if (bracketActive) {
      await refreshTournamentBracketMatches({ forceReload: true });
    } else if (hasBracketCache) {
      state.tournamentBracketMatches.delete(bracketKey);
    }

    setStatusMessage(statusElement, 'success', 'Resultado guardado correctamente.');
    showGlobalMessage('Resultado del partido actualizado.', 'success');
    return true;
  } catch (error) {
    setStatusMessage(statusElement, 'error', error.message);
    return false;
  } finally {
    if (submitButton) {
      submitButton.disabled = false;
    }
  }
}

async function deleteMatchById(matchId, { statusElement, button } = {}) {
  if (!matchId || !isAdmin()) {
    return false;
  }

  const matchSources = [
    state.calendarMatches,
    state.upcomingMatches,
    state.pendingApprovalMatches,
    state.completedMatches,
    state.myMatches,
  ];

  let match = null;
  for (const source of matchSources) {
    if (!Array.isArray(source)) continue;
    const found = source.find((item) => normalizeId(item) === matchId);
    if (found) {
      match = found;
      break;
    }
  }
  const playersLabel = Array.isArray(match?.players)
    ? match.players.map((player) => player.fullName || player.email || 'Jugador').join(' vs ')
    : '';
  const message = playersLabel
    ? `¿Seguro que deseas eliminar el partido ${playersLabel}?`
    : '¿Seguro que deseas eliminar este partido?';

  const confirmed = window.confirm(message);
  if (!confirmed) {
    return false;
  }

  if (button) {
    button.disabled = true;
  }

  if (statusElement) {
    setStatusMessage(statusElement, 'info', 'Eliminando partido...');
  }

  try {
    await request(`/matches/${matchId}`, { method: 'DELETE' });
    if (statusElement) {
      setStatusMessage(statusElement, 'success', 'Partido eliminado correctamente.');
    } else {
      showGlobalMessage('Partido eliminado correctamente.', 'success');
    }
    if (state.adminMatchEditingId === matchId) {
      resetAdminMatchForm();
    }
    await loadAllData();
    return true;
  } catch (error) {
    if (statusElement) {
      setStatusMessage(statusElement, 'error', error.message);
    } else {
      showGlobalMessage(error.message, 'error');
    }
    return false;
  } finally {
    if (button) {
      button.disabled = false;
    }
  }
}

async function populateMatchPlayerSelects(form, categoryId, selectedPlayers = [], statusElement) {
  const player1Select = form?.elements?.player1;
  const player2Select = form?.elements?.player2;
  if (!player1Select || !player2Select) return;

  player1Select.innerHTML = '<option value="">Selecciona jugador 1</option>';
  player2Select.innerHTML = '<option value="">Selecciona jugador 2</option>';
  player1Select.disabled = true;
  player2Select.disabled = true;

  if (!categoryId) {
    player1Select.disabled = false;
    player2Select.disabled = false;
    return;
  }

  try {
    const enrollments = await loadEnrollments(categoryId);
    enrollments.forEach((enrollment) => {
      const userId = normalizeId(enrollment.user);
      if (!userId) return;
      const label = enrollment.user?.fullName || enrollment.user?.email || 'Jugador';
      const optionOne = new Option(label, userId);
      const optionTwo = new Option(label, userId);
      player1Select.appendChild(optionOne);
      player2Select.appendChild(optionTwo);
    });

    player1Select.disabled = false;
    player2Select.disabled = false;

    if (selectedPlayers[0]) {
      player1Select.value = selectedPlayers[0];
    }
    if (selectedPlayers[1]) {
      player2Select.value = selectedPlayers[1];
    }
  } catch (error) {
    player1Select.disabled = false;
    player2Select.disabled = false;
    setStatusMessage(statusElement, 'error', error.message);
  }
}

function openCategoryModal(categoryId = '') {
  if (!isAdmin()) return;
  const normalizedId = categoryId || '';
  const category = normalizedId
    ? state.categories.find((item) => normalizeId(item) === normalizedId)
    : null;

  const form = document.createElement('form');
  form.className = 'form';
  const skillLevelOptions = CATEGORY_SKILL_LEVEL_OPTIONS.map(
    (option) => `<option value="${option.value}">${option.label}</option>`
  ).join('');
  form.innerHTML = `
    <label>
      Nombre
      <input type="text" name="name" required />
    </label>
    <label>
      Descripción
      <textarea name="description" rows="2" maxlength="280" placeholder="Detalles opcionales"></textarea>
    </label>
    <label data-field="league">
      Liga
      <select name="leagueId" required>
        <option value="">Selecciona una liga</option>
      </select>
      <span class="form-hint">Selecciona la liga a la que pertenecerá la categoría.</span>
    </label>
    <div class="form-grid">
      <label>
        Género
        <select name="gender" required>
          <option value="masculino">Masculino</option>
          <option value="femenino">Femenino</option>
          <option value="mixto">Mixto</option>
        </select>
      </label>
      <label>
        Nivel
        <select name="skillLevel" required>
          <option value="">Selecciona un nivel</option>
          ${skillLevelOptions}
        </select>
      </label>
    </div>
    <label>
      Estado
      <select name="status" required>
        <option value="inscripcion">Inscripción abierta</option>
        <option value="en_curso">En curso</option>
      </select>
      <span class="form-hint">Cuando está en curso no se aceptan nuevas inscripciones.</span>
    </label>
    <label>
      Formato de partido
      <select name="matchFormat" required>
        ${CATEGORY_MATCH_FORMAT_OPTIONS.map(
          (option) => `<option value="${option.value}">${option.label}</option>`
        ).join('')}
      </select>
      <span class="form-hint">Define cómo se registrarán los resultados de la categoría.</span>
    </label>
    ${renderCategoryColorField({
      name: 'color',
      selected: category ? getCategoryColor(category) : DEFAULT_CATEGORY_COLOR,
      hint: 'Se utilizará para identificar la categoría en listas y calendarios.',
    })}
    <label>
      Edad mínima (años)
      <input type="number" name="minimumAge" min="0" step="1" placeholder="Opcional" />
      <span class="form-hint">Los jugadores deben cumplir esta edad durante el año natural de la liga.</span>
    </label>
    <div class="form-actions">
      <button type="submit" class="primary">${category ? 'Actualizar' : 'Crear'} categoría</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  form.elements.name.value = category?.name || '';
  form.elements.description.value = category?.description || '';
  form.elements.gender.value = category?.gender || 'masculino';
  form.elements.skillLevel.value = category?.skillLevel || '';
  if (form.elements.minimumAge) {
    form.elements.minimumAge.value =
      category?.minimumAge === undefined || category?.minimumAge === null
        ? ''
        : Number(category.minimumAge);
  }
  if (form.elements.status) {
    form.elements.status.value = category?.status || 'inscripcion';
  }
  if (form.elements.matchFormat) {
    form.elements.matchFormat.value = category?.matchFormat || DEFAULT_CATEGORY_MATCH_FORMAT;
  }
  if (form.elements.color) {
    const colorValue = category ? getCategoryColor(category) : DEFAULT_CATEGORY_COLOR;
    form.elements.color.value = colorValue || DEFAULT_CATEGORY_COLOR;
  }

  const leagueSelect = form.elements.leagueId;
  const leagueField = form.querySelector('[data-field="league"]');
  const leagueHint = leagueField?.querySelector('.form-hint');
  const currentLeagueId = normalizeId(category?.league);
  if (leagueSelect) {
    const availableLeagues = Array.isArray(state.leagues) ? [...state.leagues] : [];
    if (!availableLeagues.length && category?.league && typeof category.league === 'object') {
      availableLeagues.push(category.league);
    }

    availableLeagues
      .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
      .forEach((league) => {
        const leagueId = normalizeId(league);
        if (!leagueId) return;
        const labelParts = [league.name || 'Liga'];
        if (league.year) {
          labelParts.push(league.year);
        }
        const option = document.createElement('option');
        option.value = leagueId;
        option.textContent = labelParts.join(' · ');
        const isClosed = league.status === 'cerrada';
        if (isClosed && leagueId !== currentLeagueId) {
          option.disabled = true;
          option.textContent += ' (cerrada)';
        }
        leagueSelect.appendChild(option);
      });

    let hasEnabledOption = Array.from(leagueSelect.options).some((option) => !option.disabled && option.value);

    if (currentLeagueId) {
      leagueSelect.value = currentLeagueId;
      hasEnabledOption = true;
    } else if (hasEnabledOption) {
      const preferred = availableLeagues.find((league) => league.status !== 'cerrada');
      if (preferred) {
        leagueSelect.value = normalizeId(preferred);
      } else if (leagueSelect.options.length > 1) {
        leagueSelect.selectedIndex = 1;
      }
    }

    leagueSelect.disabled = !hasEnabledOption;

    const submitButton = form.querySelector('button[type="submit"]');
    if (submitButton && !category) {
      submitButton.disabled = leagueSelect.disabled;
    }

    if (leagueHint) {
      leagueHint.textContent = leagueSelect.disabled && !category
        ? 'Crea una liga activa antes de registrar categorías.'
        : 'Selecciona la liga a la que pertenecerá la categoría.';
    }
  }

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const succeeded = await submitCategoryFormData({
      form,
      categoryId: normalizedId,
      statusElement: status,
    });
    if (succeeded) {
      closeModal();
    }
  });

  const cancelButton = form.querySelector('[data-action="cancel"]');
  cancelButton?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  openModal({
    title: category ? 'Editar categoría' : 'Nueva categoría',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

function openLeagueModal(leagueId = '') {
  if (!isAdmin()) return;
  const normalizedId = leagueId || '';
  const league = normalizedId
    ? state.leagues.find((item) => normalizeId(item) === normalizedId)
    : null;

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Nombre
      <input type="text" name="name" required />
    </label>
    <div class="form-grid">
      <label>
        Año
        <input type="number" name="year" min="2000" placeholder="Opcional" />
      </label>
      <label>
        Estado
        <select name="status" required>
          <option value="activa">${LEAGUE_STATUS_LABELS.activa}</option>
          <option value="cerrada">${LEAGUE_STATUS_LABELS.cerrada}</option>
        </select>
      </label>
    </div>
    <label>
      Visibilidad
      <select name="isPrivate" required>
        <option value="false">Pública</option>
        <option value="true">Privada</option>
      </select>
      <span class="form-hint">Las ligas privadas solo están disponibles para socios y se ocultarán al resto de usuarios.</span>
    </label>
    <label>
      Descripción
      <textarea name="description" rows="2" maxlength="280" placeholder="Detalles opcionales"></textarea>
    </label>
    <div class="form-grid">
      <label>
        Inicio
        <input type="date" name="startDate" />
      </label>
      <label>
        Fin
        <input type="date" name="endDate" />
      </label>
    </div>
    <div class="form-grid">
      <label>
        Cierre de inscripciones
        <input type="date" name="registrationCloseDate" />
        <span class="form-hint">Último día para que los jugadores envíen su inscripción.</span>
      </label>
      <label>
        Tarifa de inscripción
        <input type="number" name="enrollmentFee" min="0" step="0.01" placeholder="0.00" />
        <span class="form-hint">Importe total en euros. Déjalo vacío si la inscripción es gratuita.</span>
      </label>
    </div>
    <label>
      Categorías asociadas
      <select name="categories" multiple size="6"></select>
      <span class="form-hint">Selecciona categorías existentes para vincularlas a esta liga.</span>
    </label>
    <div class="form-actions">
      <button type="submit" class="primary">${league ? 'Actualizar' : 'Crear'} liga</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  form.elements.name.value = league?.name || '';
  if (form.elements.year) {
    form.elements.year.value = league?.year ? String(league.year) : '';
  }
  if (form.elements.status) {
    form.elements.status.value = league?.status || 'activa';
  }
  if (form.elements.isPrivate) {
    form.elements.isPrivate.value = league?.isPrivate ? 'true' : 'false';
  }
  form.elements.description.value = league?.description || '';
  if (form.elements.poster) {
    form.elements.poster.value = league?.poster || '';
  }
  form.elements.startDate.value = formatDateInput(league?.startDate);
  form.elements.endDate.value = formatDateInput(league?.endDate);
  if (form.elements.registrationCloseDate) {
    form.elements.registrationCloseDate.value = formatDateInput(league?.registrationCloseDate);
  }
  if (form.elements.enrollmentFee) {
    form.elements.enrollmentFee.value =
      typeof league?.enrollmentFee === 'number' ? String(league.enrollmentFee) : '';
  }

  const categoriesSelect = form.elements.categories;
  if (categoriesSelect) {
    const categories = Array.isArray(state.categories) ? [...state.categories] : [];
    const selectedIds = league
      ? Array.isArray(league.categories)
        ? league.categories.map((category) => normalizeId(category))
        : []
      : [];

    categories
      .sort((a, b) => (a.name || '').localeCompare(b.name || '', 'es'))
      .forEach((category) => {
        const categoryId = normalizeId(category);
        if (!categoryId) return;
        const option = document.createElement('option');
        option.value = categoryId;
        const parts = [category.name || 'Categoría', translateGender(category.gender)];
        const linkedLeague = resolveLeague(category.league);
        const linkedLeagueId = normalizeId(linkedLeague);
        if (linkedLeagueId && linkedLeagueId !== normalizedId) {
          const linkedLeagueName = linkedLeague?.name || 'Asignada';
          parts.push(`Liga ${linkedLeagueName}`);
          option.disabled = true;
        }
        option.textContent = parts.join(' · ');
        option.selected = selectedIds.includes(categoryId);
        categoriesSelect.appendChild(option);
      });

    const optionCount = categoriesSelect.options.length || 3;
    categoriesSelect.size = Math.min(8, Math.max(3, optionCount));
  }

  const formActions = form.querySelector('.form-actions');
  if (league && normalizedId && formActions) {
    const uploadSection = document.createElement('div');
    uploadSection.className = 'form-section league-poster-upload';
    uploadSection.innerHTML = `
      <h3>Cartel de la liga</h3>
      <p class="form-hint">Sube una imagen en formato JPG o PNG (máximo 5&nbsp;MB).</p>
      <label>
        Selecciona una imagen
        <input type="file" name="posterFile" accept="image/*" />
      </label>
      <div class="form-actions">
        <button type="button" class="secondary" data-action="upload-poster">Subir cartel</button>
      </div>
    `;
    const posterUploadStatus = document.createElement('p');
    posterUploadStatus.className = 'status-message';
    posterUploadStatus.style.display = 'none';
    uploadSection.appendChild(posterUploadStatus);
    formActions.before(uploadSection);

    const uploadButton = uploadSection.querySelector('[data-action="upload-poster"]');
    const fileInput = uploadSection.querySelector('input[name="posterFile"]');
    uploadButton?.addEventListener('click', async () => {
      if (!fileInput?.files?.length) {
        setStatusMessage(posterUploadStatus, 'error', 'Selecciona una imagen para el cartel.');
        return;
      }

      const file = fileInput.files[0];
      if (!file.type.startsWith('image/')) {
        setStatusMessage(posterUploadStatus, 'error', 'El archivo seleccionado debe ser una imagen.');
        return;
      }

      if (file.size > MAX_POSTER_SIZE) {
        setStatusMessage(
          posterUploadStatus,
          'error',
          'La imagen supera el tamaño máximo permitido (5 MB).'
        );
        return;
      }

      const formData = new FormData();
      formData.append('poster', file);

      setStatusMessage(posterUploadStatus, 'info', 'Subiendo cartel...');

      try {
        const result = await request(`/leagues/${normalizedId}/poster`, {
          method: 'POST',
          body: formData,
        });
        setStatusMessage(posterUploadStatus, 'success', 'Cartel actualizado.');
        if (form.elements.poster) {
          form.elements.poster.value = result?.poster || '';
        }
        fileInput.value = '';
        await loadAllData();
      } catch (error) {
        setStatusMessage(posterUploadStatus, 'error', error.message);
      }
    });
  }

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const succeeded = await submitLeagueFormData({
      form,
      leagueId: normalizedId,
      statusElement: status,
    });
    if (succeeded) {
      closeModal();
    }
  });

  const cancelButton = form.querySelector('[data-action="cancel"]');
  cancelButton?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  openModal({
    title: league ? 'Editar liga' : 'Nueva liga',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

function openPlayerModal(playerId = '') {
  if (!isAdmin()) return;
  const normalizedId = playerId || '';
  const player = normalizedId
    ? state.players.find((item) => normalizeId(item) === normalizedId)
    : null;

  const scheduleOptions = Object.entries(SCHEDULE_LABELS)
    .map(([value, label]) => `<option value="${value}">${label}</option>`)
    .join('');

  const form = document.createElement('form');
  form.className = 'form';
  form.enctype = 'multipart/form-data';
  form.innerHTML = `
    <label>
      Nombre completo
      <input type="text" name="fullName" required />
    </label>
    <label>
      Correo electrónico
      <input type="email" name="email" required />
    </label>
    <label>
      Contraseña
      <input type="password" name="password" minlength="8" ${player ? '' : 'required'} />
      <span class="form-hint">${
        player
          ? 'Deja vacío para mantener la contraseña actual.'
          : 'Mínimo 8 caracteres para nuevos usuarios.'
      }</span>
    </label>
    <div class="form-grid">
      <label>
        Género
        <select name="gender" required>
          <option value="masculino">Masculino</option>
          <option value="femenino">Femenino</option>
          <option value="mixto">Mixto</option>
        </select>
      </label>
      <fieldset class="checkbox-group">
        <legend>Roles</legend>
        <label class="checkbox-option">
          <input type="checkbox" name="roles" value="player" />
          Jugador
        </label>
        <label class="checkbox-option">
          <input type="checkbox" name="roles" value="court_manager" />
          Gestor de pistas
        </label>
        <label class="checkbox-option">
          <input type="checkbox" name="roles" value="admin" />
          Administrador
        </label>
      </fieldset>
    </div>
    <label>
      Fecha de nacimiento
      <input type="date" name="birthDate" required />
    </label>
    <label>
      Teléfono
      <input type="tel" name="phone" required />
    </label>
    <label>
      Fotografía
      <input type="file" name="photo" accept="image/*" />
      <span class="form-hint">Imágenes en Base64 hasta 2&nbsp;MB. Deja vacío para conservar la actual.</span>
    </label>
    <label>
      Horario preferido
      <select name="preferredSchedule" required>${scheduleOptions}</select>
    </label>
    <label>
      Talla de camiseta
      <select name="shirtSize" required>
        <option value="">Selecciona</option>
        <option value="XS">XS</option>
        <option value="S">S</option>
        <option value="M">M</option>
        <option value="L">L</option>
        <option value="XL">XL</option>
        <option value="XXL">XXL</option>
      </select>
    </label>
    <div class="form-grid">
      <label class="checkbox-option checkbox-option--stacked">
        <input type="checkbox" name="isMember" value="true" />
        Es socio del club
        <span class="form-hint">Marca esta opción si dispone de número de socio.</span>
      </label>
      <label data-membership-wrapper hidden>
        Nº de socio
        <input type="text" name="membershipNumber" maxlength="50" />
        <span class="form-hint">Introduce el número asignado por el club.</span>
      </label>
      <label class="checkbox-option" data-membership-verified-wrapper hidden>
        <input type="checkbox" name="membershipNumberVerified" value="true" />
        Nº de socio verificado
        <span class="form-hint">
          Marca esta casilla cuando hayas comprobado el número con el registro del club.
        </span>
      </label>
    </div>
    <label>
      Notas
      <textarea name="notes" rows="2" maxlength="500" placeholder="Preferencias adicionales"></textarea>
    </label>
    <div class="form-grid form-grid--stacked">
      <label class="checkbox-option">
        <input type="checkbox" name="notifyMatchRequests" value="true" />
        Enviar notificaciones cuando reciba solicitudes de partido
      </label>
      <label class="checkbox-option">
        <input type="checkbox" name="notifyMatchResults" value="true" />
        Avisar cuando se confirme el resultado de un partido
      </label>
    </div>
    <div class="form-actions">
      <button type="submit" class="primary">${player ? 'Actualizar' : 'Crear'}</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
      ${
        player ? '<button type="button" class="danger" data-action="delete">Eliminar</button>' : ''
      }
    </div>
  `;

  form.elements.fullName.value = player?.fullName || '';
  form.elements.email.value = player?.email || '';
  form.elements.gender.value = player?.gender || 'masculino';
  form.elements.birthDate.value = formatDateInput(player?.birthDate);
  form.elements.phone.value = player?.phone || '';
  form.elements.preferredSchedule.value = player?.preferredSchedule || 'flexible';
  form.elements.shirtSize.value = player?.shirtSize || '';
  form.elements.notes.value = player?.notes || '';
  form.elements.notifyMatchRequests.checked = player ? player.notifyMatchRequests !== false : true;
  form.elements.notifyMatchResults.checked = player ? player.notifyMatchResults !== false : true;

  const roleInputs = Array.from(form.querySelectorAll('input[name="roles"]'));
  const adminInput = roleInputs.find((input) => input.value === 'admin');
  const playerInput = roleInputs.find((input) => input.value === 'player');
  const currentRolesRaw = Array.isArray(player?.roles)
    ? player.roles
    : player?.role
    ? [player.role]
    : [];
  let currentRoles = currentRolesRaw
    .map((role) => (typeof role === 'string' ? role.toLowerCase() : ''))
    .filter(Boolean);

  if (!currentRoles.length) {
    currentRoles = ['player'];
  }

  if (currentRoles.includes('admin')) {
    currentRoles = currentRoles.filter((role) => role !== 'player');
  }

  roleInputs.forEach((input) => {
    input.checked = currentRoles.includes(input.value);
  });

  function enforceRoleExclusivity() {
    if (adminInput?.checked) {
      if (playerInput) {
        playerInput.checked = false;
        playerInput.disabled = true;
      }
    } else if (playerInput) {
      playerInput.disabled = false;
      if (!roleInputs.some((input) => input !== playerInput && input.checked)) {
        playerInput.checked = true;
      }
    }
  }

  roleInputs.forEach((input) => {
    input.addEventListener('change', enforceRoleExclusivity);
  });

  enforceRoleExclusivity();

  const membershipCheckbox = form.elements.isMember;
  const membershipWrapper = form.querySelector('[data-membership-wrapper]');
  const membershipInput = form.elements.membershipNumber;
  const membershipVerifiedWrapper = form.querySelector('[data-membership-verified-wrapper]');
  const membershipVerifiedInput = form.elements.membershipNumberVerified;

  if (membershipCheckbox) {
    membershipCheckbox.checked = Boolean(player?.isMember);
  }

  if (membershipInput) {
    membershipInput.value = player?.membershipNumber || '';
  }

  if (membershipVerifiedInput) {
    membershipVerifiedInput.checked = Boolean(player?.membershipNumberVerified);
  }

  function updateMembershipControls({ clearWhenDisabled = false } = {}) {
    toggleMembershipField(membershipCheckbox, membershipWrapper, membershipInput, {
      clearWhenDisabled,
    });

    if (!membershipVerifiedWrapper) {
      return;
    }

    const isMemberSelected = Boolean(membershipCheckbox?.checked);
    membershipVerifiedWrapper.hidden = !isMemberSelected;

    if (membershipVerifiedInput) {
      membershipVerifiedInput.disabled = !isMemberSelected;
      if (!isMemberSelected && (clearWhenDisabled || !player)) {
        membershipVerifiedInput.checked = false;
      }
    }
  }

  if (membershipCheckbox) {
    updateMembershipControls({ clearWhenDisabled: !player });
    membershipCheckbox.addEventListener('change', () => {
      updateMembershipControls({ clearWhenDisabled: false });
      if (!membershipCheckbox.checked && membershipVerifiedInput) {
        membershipVerifiedInput.checked = false;
      }
    });
  } else {
    updateMembershipControls({ clearWhenDisabled: true });
  }

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const succeeded = await submitPlayerFormData({
      form,
      playerId: normalizedId,
      statusElement: status,
    });
    if (succeeded) {
      closeModal();
    }
  });

  const cancelButton = form.querySelector('[data-action="cancel"]');
  cancelButton?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  const deleteButton = form.querySelector('[data-action="delete"]');
  deleteButton?.addEventListener('click', async () => {
    if (!normalizedId) return;
    const confirmed = window.confirm('¿Seguro que deseas eliminar este jugador?');
    if (!confirmed) return;

    setStatusMessage(status, 'info', 'Eliminando jugador...');
    try {
      await request(`/players/${normalizedId}`, { method: 'DELETE' });
      setStatusMessage(status, 'success', 'Jugador eliminado.');
      closeModal();
      await loadAllData();
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    }
  });

  openModal({
    title: player ? 'Editar usuario' : 'Nuevo usuario',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

function openMatchModal(matchId = '') {
  if (!isAdmin()) return;
  const normalizedId = normalizeId(matchId);
  const match = normalizedId ? findMatchById(normalizedId) : null;

  const categories = Array.isArray(state.categories) ? [...state.categories] : [];
  const leagues = Array.isArray(state.leagues) ? [...state.leagues] : [];
  const currentMatchLeagueId = match ? normalizeId(match.league) : '';
  const stateLeagueMap = new Map();
  leagues.forEach((league) => {
    const id = normalizeId(league);
    if (id && !stateLeagueMap.has(id)) {
      stateLeagueMap.set(id, league);
    }
  });

  const categoriesByLeague = new Map();
  const leagueDetailsMap = new Map();
  const UNASSIGNED_LEAGUE_VALUE = '__unassigned__';

  const registerLeague = (league) => {
    if (!league) return;
    const id = normalizeId(league);
    if (!id || leagueDetailsMap.has(id)) return;
    if (typeof league === 'object') {
      leagueDetailsMap.set(id, league);
    } else if (stateLeagueMap.has(id)) {
      leagueDetailsMap.set(id, stateLeagueMap.get(id));
    } else {
      leagueDetailsMap.set(id, { _id: id });
    }
  };

  categories.forEach((category) => {
    const leagueId = normalizeId(category.league);
    const key = leagueId || UNASSIGNED_LEAGUE_VALUE;
    if (!categoriesByLeague.has(key)) {
      categoriesByLeague.set(key, []);
    }
    categoriesByLeague.get(key).push(category);
    if (leagueId) {
      registerLeague(category.league || stateLeagueMap.get(leagueId));
    }
  });

  if (match?.league) {
    registerLeague(match.league);
  }

  const statusOptions = Object.entries(STATUS_LABELS)
    .map(([value, label]) => `<option value="${value}">${label}</option>`)
    .join('');

  const scheduleTemplates = getClubMatchScheduleTemplates();
  const scheduleFieldMarkup = `
    <div class="match-schedule-field">
      <input
        type="date"
        name="scheduledDate"
        data-match-schedule="date"
        class="sr-only"
        aria-label="Día del partido"
      />
      <input type="hidden" name="scheduledAt" />
      <input type="hidden" name="court" />
      <div class="match-schedule-picker" data-match-schedule="picker"></div>
      <div class="match-schedule-actions">
        <button type="button" class="ghost" data-match-schedule="clear">Dejar sin horario</button>
        <span class="form-hint">Selecciona una franja para reservar la pista automáticamente.</span>
      </div>
    </div>
  `;

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Liga
      <select name="leagueId" required>
        <option value="">Selecciona una liga</option>
      </select>
    </label>
    <label>
      Categoría
      <select name="categoryId" required disabled>
        <option value="">Selecciona una categoría</option>
      </select>
    </label>
    <div class="form-grid">
      <label>
        Jugador 1
        <select name="player1" required>
          <option value="">Selecciona jugador 1</option>
        </select>
      </label>
      <label>
        Jugador 2
        <select name="player2" required>
          <option value="">Selecciona jugador 2</option>
        </select>
      </label>
    </div>
    <label>
      Estado
      <select name="status" required>
        ${statusOptions}
      </select>
    </label>
    ${scheduleFieldMarkup}
    <label>
      Notas internas
      <textarea name="notes" rows="3" maxlength="500" placeholder="Comentarios o recordatorios"></textarea>
    </label>
    <div class="form-actions">
      <button type="submit" class="primary">${match ? 'Actualizar' : 'Crear'} partido</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const leagueField = form.elements.leagueId;
  const categoryField = form.elements.categoryId;
  const scheduledField = form.elements.scheduledAt;
  const courtField = form.elements.court;
  const scheduleDateField = form.elements.scheduledDate;
  const schedulePickerContainer = form.querySelector('[data-match-schedule="picker"]');
  const scheduleClearButton = form.querySelector('button[data-match-schedule="clear"]');
  const statusField = form.elements.status;
  const notesField = form.elements.notes;
  const submitButton = form.querySelector('button[type="submit"]');

  const formatLeagueLabel = (league) => {
    if (!league || typeof league !== 'object') {
      return 'Liga';
    }
    const parts = [];
    const name = typeof league.name === 'string' && league.name.trim() ? league.name.trim() : 'Liga';
    parts.push(name);
    if (league.year) {
      parts.push(league.year);
    }
    return parts.join(' · ');
  };

  if (leagueField) {
    const leagueOptionEntries = [];
    categoriesByLeague.forEach((list, key) => {
      if (key === UNASSIGNED_LEAGUE_VALUE) return;
      if (!Array.isArray(list) || !list.length) return;
      const info =
        leagueDetailsMap.get(key) || stateLeagueMap.get(key) || { _id: key };
      leagueOptionEntries.push({ id: key, info });
    });

    leagueOptionEntries
      .sort((a, b) => (a.info?.name || '').localeCompare(b.info?.name || '', 'es'))
      .forEach(({ id, info }) => {
        const isClosed = info?.status === 'cerrada';
        const isCurrentSelection = currentMatchLeagueId && currentMatchLeagueId === id;
        if (isClosed && !isCurrentSelection) {
          return;
        }

        const option = document.createElement('option');
        option.value = id;
        option.textContent = formatLeagueLabel(info);
        if (isClosed) {
          option.textContent += ' (cerrada)';
        }
        leagueField.appendChild(option);
      });

    if (categoriesByLeague.has(UNASSIGNED_LEAGUE_VALUE)) {
      const option = document.createElement('option');
      option.value = UNASSIGNED_LEAGUE_VALUE;
      option.textContent = 'Sin liga asignada';
      leagueField.appendChild(option);
    }

    const enabledLeagueOptions = Array.from(leagueField.options || []).filter(
      (option) => option.value && !option.disabled
    );
    if (!match && !enabledLeagueOptions.length) {
      leagueField.disabled = true;
      if (submitButton) {
        submitButton.disabled = true;
      }
      setStatusMessage(
        status,
        'warning',
        'Todas las ligas activas están cerradas. No es posible crear nuevos partidos.'
      );
    }
  }

  const resolveCategoriesForLeague = (leagueId) => {
    if (!leagueId) return [];
    if (leagueId === UNASSIGNED_LEAGUE_VALUE) {
      return categoriesByLeague.get(UNASSIGNED_LEAGUE_VALUE) || [];
    }
    return categoriesByLeague.get(leagueId) || [];
  };

  const updateCategoryOptions = ({ leagueId, targetCategoryId, preserveSelection = false } = {}) => {
    if (!categoryField) return '';
    const previousValue = categoryField.value || '';
    categoryField.innerHTML = '<option value="">Selecciona una categoría</option>';
    categoryField.disabled = true;

    const categoryList = resolveCategoriesForLeague(leagueId);
    if (!categoryList.length) {
      return '';
    }

    const normalizedCategories = categoryList
      .map((entry) => ({ id: normalizeId(entry), category: entry }))
      .filter((entry) => entry.id)
      .sort((a, b) => (a.category.name || '').localeCompare(b.category.name || '', 'es'));

    if (!normalizedCategories.length) {
      return '';
    }

    normalizedCategories.forEach((entry) => {
      const option = new Option(entry.category.name || 'Categoría', entry.id);
      categoryField.appendChild(option);
    });

    categoryField.disabled = false;

    const desiredValue = targetCategoryId || (preserveSelection ? previousValue : '');
    if (desiredValue && normalizedCategories.some((entry) => entry.id === desiredValue)) {
      categoryField.value = desiredValue;
    } else if (normalizedCategories.length === 1) {
      categoryField.value = normalizedCategories[0].id;
    } else {
      categoryField.value = '';
    }

    return categoryField.value || '';
  };

  const categoryValue = match ? normalizeId(match.category) : '';
  let initialLeagueId = '';
  if (categoryValue) {
    const categoryEntry = categories.find((item) => normalizeId(item) === categoryValue);
    if (categoryEntry) {
      initialLeagueId = normalizeId(categoryEntry.league);
      if (!initialLeagueId && categoriesByLeague.has(UNASSIGNED_LEAGUE_VALUE)) {
        initialLeagueId = UNASSIGNED_LEAGUE_VALUE;
      }
    }
  } else if (match?.league) {
    initialLeagueId = normalizeId(match.league);
  }

  const selectInitialLeague = (desiredLeagueId) => {
    if (!leagueField) return '';
    const options = Array.from(leagueField.options || []);
    const isDesiredEnabled =
      desiredLeagueId &&
      options.some((option) => option.value === desiredLeagueId && !option.disabled);
    if (isDesiredEnabled) {
      leagueField.value = desiredLeagueId;
    } else if (leagueField.value) {
      const currentOption = leagueField.options[leagueField.selectedIndex];
      if (currentOption?.disabled) {
        leagueField.value = '';
      }
    }
    if (!leagueField.value) {
      const availableOptions = options.filter((option) => option.value && !option.disabled);
      if (availableOptions.length === 1) {
        leagueField.value = availableOptions[0].value;
      } else {
        leagueField.value = '';
      }
    }
    return leagueField.value || '';
  };

  const selectedLeagueId = selectInitialLeague(initialLeagueId);
  const initialCategorySelection = updateCategoryOptions({
    leagueId: selectedLeagueId,
    targetCategoryId: categoryValue,
  });

  if (leagueField) {
    leagueField.addEventListener('change', (event) => {
      setStatusMessage(status, '', '');
      const nextCategoryId = updateCategoryOptions({ leagueId: event.target.value });
      populateMatchPlayerSelects(form, nextCategoryId, [], status).catch((error) => {
        console.warn('No fue posible cargar jugadores inscritos', error);
      });
    });
  }

  if (statusField) {
    statusField.value = match?.status || 'pendiente';
  }
  if (scheduledField) {
    scheduledField.value = formatDateTimeLocal(match?.scheduledAt);
  }
  if (courtField) {
    courtField.value = match?.court || '';
  }

  let schedulePicker = null;
  if (schedulePickerContainer && scheduleDateField && scheduledField) {
    const updateStatusForSchedule = () => {
      if (!statusField) {
        return;
      }
      const hasSchedule = Boolean(scheduledField.value);
      if (hasSchedule && statusField.value === 'pendiente') {
        statusField.value = 'programado';
      } else if (!hasSchedule && statusField.value === 'programado') {
        statusField.value = 'pendiente';
      }
    };

    schedulePicker = createMatchScheduleSlotPicker({
      container: schedulePickerContainer,
      dateField: scheduleDateField,
      scheduledField,
      courtField,
      templates: scheduleTemplates,
      scope: 'admin',
      existingValue: scheduledField?.value || '',
      existingCourt: match?.court || '',
      ignoreMatchId: match?._id || '',
      onChange: updateStatusForSchedule,
    });

    scheduleClearButton?.addEventListener('click', (event) => {
      event.preventDefault();
      schedulePicker.clear();
      updateStatusForSchedule();
    });

    updateStatusForSchedule();
  }
  if (notesField) {
    notesField.value = match?.result?.notes || match?.notes || '';
  }

  const selectedPlayers = Array.isArray(match?.players)
    ? match.players.map((player) => normalizeId(player))
    : [];
  const initialCategoryId = initialCategorySelection || categoryField.value;

  populateMatchPlayerSelects(form, initialCategoryId, selectedPlayers, status).catch((error) => {
    console.warn('No fue posible cargar jugadores inscritos', error);
  });

  categoryField.addEventListener('change', (event) => {
    setStatusMessage(status, '', '');
    populateMatchPlayerSelects(form, event.target.value, [], status).catch((error) => {
      console.warn('No fue posible cargar jugadores inscritos', error);
    });
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const succeeded = await submitMatchFormData({
      form,
      matchId: normalizedId,
      statusElement: status,
      creating: !match,
    });
    if (succeeded) {
      closeModal();
    }
  });

  const cancelButton = form.querySelector('[data-action="cancel"]');
  cancelButton?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  openModal({
    title: match ? 'Editar partido' : 'Nuevo partido',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => {
      setStatusMessage(status, '', '');
      schedulePicker?.destroy();
    },
  });
}

function openClubModal() {
  if (!isAdmin()) return;

  const club = state.club || {};
  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <div class="form-grid">
      <label>
        Nombre del club
        <input type="text" name="name" required />
      </label>
      <label>
        Lema o eslogan
        <input type="text" name="slogan" maxlength="120" />
      </label>
    </div>
    <label>
      Descripción
      <textarea name="description" rows="3" maxlength="600" placeholder="Presentación del club y servicios principales"></textarea>
    </label>
    <div class="form-grid">
      <label>
        Dirección
        <input type="text" name="address" maxlength="160" />
      </label>
      <label>
        Teléfono de contacto
        <input type="text" name="contactPhone" maxlength="40" />
      </label>
    </div>
    <div class="form-grid">
      <label>
        Correo electrónico
        <input type="email" name="contactEmail" maxlength="160" />
      </label>
      <label>
        Sitio web
        <input type="text" name="website" placeholder="ej. clubtenis.com" maxlength="160" />
      </label>
    </div>
    <label>
      Logotipo
      <input type="file" name="logo" accept="image/*" />
      <span class="form-hint">El logotipo se almacena en la base de datos (máx. 2&nbsp;MB).</span>
    </label>
    <section class="form-section">
      <div class="form-section__header">
        <h3>Horarios preferentes</h3>
        <p class="form-hint">Define franjas horarias por día y ajusta su horario.</p>
      </div>
      <div data-mount="schedules"></div>
    </section>
    <section class="form-section">
      <div class="form-section__header">
        <h3>Pistas disponibles</h3>
        <p class="form-hint">Añade cada pista con sus características principales.</p>
      </div>
      <div data-mount="courts"></div>
    </section>
    <label>
      Servicios del club
      <textarea
        name="facilities"
        rows="3"
        placeholder="Una línea por servicio destacado"
      ></textarea>
    </label>
    <div class="form-actions">
      <button type="submit" class="primary">Guardar cambios</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const schedulesMount = form.querySelector('[data-mount="schedules"]');
  const schedulesEditor = createSchedulesEditor(club.schedules);
  schedulesMount?.appendChild(schedulesEditor.element);

  const courtsMount = form.querySelector('[data-mount="courts"]');
  const courtsEditor = createCourtsEditor(club.courts);
  courtsMount?.appendChild(courtsEditor.element);

  form.elements.name.value = club.name || '';
  form.elements.slogan.value = club.slogan || '';
  form.elements.description.value = club.description || '';
  form.elements.address.value = club.address || '';
  form.elements.contactPhone.value = club.contactPhone || '';
  form.elements.contactEmail.value = club.contactEmail || '';
  form.elements.website.value = club.website || '';
  form.elements.facilities.value = Array.isArray(club.facilities) ? club.facilities.join('\n') : '';

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    if (!isAdmin()) return;

    const formData = new FormData(form);
    const schedules = schedulesEditor?.getValue?.() || [];
    const courts = courtsEditor?.getValue?.() || [];

    const payload = {
      name: formData.get('name')?.toString().trim() || '',
      slogan: formData.get('slogan')?.toString().trim() || '',
      description: formData.get('description')?.toString().trim() || '',
      address: formData.get('address')?.toString().trim() || '',
      contactPhone: formData.get('contactPhone')?.toString().trim() || '',
      contactEmail: formData.get('contactEmail')?.toString().trim() || '',
      website: formData.get('website')?.toString().trim() || '',
      schedules,
      courts,
      facilities: parseFacilitiesInput(formData.get('facilities')?.toString() || ''),
    };

    try {
      const logoData = await extractPhotoFromForm(form, 'logo');
      if (logoData !== undefined) {
        payload.logo = logoData;
      }
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
      return;
    }

    setStatusMessage(status, 'info', 'Guardando cambios del club...');

    try {
      const updated = await request('/club', { method: 'PUT', body: payload });
      const fallbackClub = {
        ...(state.club || {}),
        ...payload,
      };
      const nextClub = updated && typeof updated === 'object' ? updated : fallbackClub;
      renderClubProfile(nextClub);
      setStatusMessage(status, 'success', 'Información actualizada correctamente.');
      closeModal();
      showGlobalMessage('Información del club actualizada.');
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    }
  });

  form.querySelector('[data-action="cancel"]')?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  openModal({
    title: 'Editar información del club',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

function openTournamentMatchScheduleModal(matchId, context = {}) {
  if (!isAdmin()) return;
  const normalizedMatchId = normalizeId(matchId);
  if (!normalizedMatchId) {
    showGlobalMessage('Selecciona un partido válido.', 'error');
    return;
  }

  let resolvedTournamentId = normalizeId(context.tournamentId) || '';
  let resolvedCategoryId = normalizeId(context.categoryId) || '';
  let match = context.match || null;

  if (!match) {
    const located = findTournamentMatchContext(normalizedMatchId);
    if (located) {
      match = located.match;
      resolvedTournamentId = resolvedTournamentId || normalizeId(located.tournamentId) || '';
      resolvedCategoryId = resolvedCategoryId || normalizeId(located.categoryId) || '';
    }
  }

  if (!resolvedTournamentId) {
    resolvedTournamentId =
      normalizeId(state.selectedMatchTournamentId) ||
      normalizeId(state.selectedBracketTournamentId) ||
      '';
  }

  if (!resolvedCategoryId) {
    resolvedCategoryId =
      normalizeId(state.selectedMatchCategoryId) ||
      normalizeId(state.selectedBracketCategoryId) ||
      '';
  }

  if (!match && resolvedTournamentId && resolvedCategoryId) {
    const cacheKey = `${resolvedTournamentId}:${resolvedCategoryId}`;
    if (state.tournamentMatches instanceof Map && state.tournamentMatches.has(cacheKey)) {
      const list = state.tournamentMatches.get(cacheKey) || [];
      match = list.find((entry) => normalizeId(entry) === normalizedMatchId) || match;
    }
    if (!match && state.tournamentBracketMatches instanceof Map) {
      const bracketMatches = state.tournamentBracketMatches.get(cacheKey);
      if (Array.isArray(bracketMatches)) {
        match = bracketMatches.find((entry) => normalizeId(entry) === normalizedMatchId) || match;
      }
    }
  }

  if (!match) {
    showGlobalMessage('No se encontró el partido del torneo.', 'error');
    return;
  }

  const tournament = getTournamentById(resolvedTournamentId) || {};
  let category = getTournamentCategoryById(resolvedTournamentId, resolvedCategoryId);

  if (!category && resolvedTournamentId) {
    const detail = state.tournamentDetails.get(resolvedTournamentId);
    if (detail && Array.isArray(detail.categories)) {
      category = detail.categories.find((entry) => normalizeId(entry) === resolvedCategoryId) || null;
    }
  }

  const scheduleTemplates = getClubMatchScheduleTemplates();
  const scheduleFieldMarkup = `
    <div class="match-schedule-field">
      <input
        type="date"
        name="scheduledDate"
        data-match-schedule="date"
        class="sr-only"
        aria-label="Día del partido"
      />
      <input type="hidden" name="scheduledAt" />
      <input type="hidden" name="court" />
      <div class="match-schedule-picker" data-match-schedule="picker"></div>
      <div class="match-schedule-actions">
        <button type="button" class="ghost" data-match-schedule="clear">Dejar sin horario</button>
        <span class="form-hint">Selecciona una franja para reservar la pista automáticamente.</span>
      </div>
    </div>
  `;

  const statusOptions = Object.entries(TOURNAMENT_MATCH_STATUS_LABELS)
    .map(([value, label]) => `<option value="${value}">${escapeHtml(label)}</option>`)
    .join('');

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Torneo
      <input type="text" name="tournamentLabel" readonly />
    </label>
    <label>
      Categoría
      <input type="text" name="categoryLabel" readonly />
    </label>
    <div class="form-grid">
      <label>
        Jugador 1
        <input type="text" name="playerLabel1" readonly />
      </label>
      <label>
        Jugador 2
        <input type="text" name="playerLabel2" readonly />
      </label>
    </div>
    <label>
      Estado
      <select name="status" required>
        ${statusOptions}
      </select>
    </label>
    ${scheduleFieldMarkup}
    <p class="form-hint" data-match-court-info></p>
    <label class="checkbox-option">
      <input type="checkbox" name="notifyPlayers" value="true" />
      Notificar a los jugadores por correo y push
    </label>
    <div class="form-actions">
      <button type="submit" class="primary">Guardar horario</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  const statusMessage = document.createElement('p');
  statusMessage.className = 'status-message';
  statusMessage.style.display = 'none';

  const tournamentField = form.elements.tournamentLabel;
  const categoryField = form.elements.categoryLabel;
  const playerOneField = form.elements.playerLabel1;
  const playerTwoField = form.elements.playerLabel2;
  const statusField = form.elements.status;
  const scheduledField = form.elements.scheduledAt;
  const courtField = form.elements.court;
  const scheduleDateField = form.elements.scheduledDate;
  const schedulePickerContainer = form.querySelector('[data-match-schedule="picker"]');
  const scheduleClearButton = form.querySelector('button[data-match-schedule="clear"]');
  const notifyField = form.elements.notifyPlayers;
  const courtInfoElement = form.querySelector('[data-match-court-info]');
  const cancelButton = form.querySelector('button[data-action="cancel"]');
  const submitButton = form.querySelector('button[type="submit"]');

  const playerNames = Array.isArray(match?.players)
    ? match.players.map((player, index) => {
        if (typeof player === 'object' && player) {
          return getPlayerDisplayName(player) || `Jugador ${index + 1}`;
        }
        const playerId = normalizeId(player);
        if (!playerId) {
          return `Jugador ${index + 1} por definir`;
        }
        const statePlayer = Array.isArray(state.players)
          ? state.players.find((item) => normalizeId(item) === playerId)
          : null;
        return getPlayerDisplayName(statePlayer) || `Jugador ${index + 1}`;
      })
    : [];

  if (tournamentField) {
    tournamentField.value = tournament?.name || 'Torneo';
  }
  if (categoryField) {
    categoryField.value = category?.name || 'Categoría';
  }
  if (playerOneField) {
    playerOneField.value = playerNames[0] || 'Jugador por definir';
  }
  if (playerTwoField) {
    playerTwoField.value = playerNames[1] || 'Jugador por definir';
  }

  const metaParts = [];
  if (Number.isFinite(Number(match?.matchNumber))) {
    metaParts.push(`Partido ${match.matchNumber}`);
  }
  if (match?.round) {
    metaParts.push(`Ronda: ${match.round}`);
  }
  if (metaParts.length) {
    const metaInfo = document.createElement('p');
    metaInfo.className = 'form-hint';
    metaInfo.textContent = metaParts.join(' · ');
    form.prepend(metaInfo);
  }

  const scheduledValue = formatDateTimeLocal(match?.scheduledAt);
  if (scheduledField) {
    scheduledField.value = scheduledValue;
  }
  if (courtField) {
    courtField.value = match?.court || '';
  }

  if (statusField) {
    const currentStatus = match?.status && TOURNAMENT_MATCH_STATUS_LABELS[match.status]
      ? match.status
      : scheduledValue
      ? 'programado'
      : 'pendiente';
    statusField.value = currentStatus;
  }

  const updateCourtInfoDisplay = () => {
    if (!courtInfoElement) {
      return;
    }
    const selectedCourt = courtField?.value?.trim();
    if (selectedCourt) {
      courtInfoElement.textContent = `Pista seleccionada: ${selectedCourt}.`;
      return;
    }
    if (match?.court && scheduledValue && scheduledField?.value === scheduledValue) {
      courtInfoElement.textContent = `Pista asignada automáticamente: ${match.court}.`;
      return;
    }
    courtInfoElement.textContent =
      'La pista se asignará automáticamente según la disponibilidad del club al guardar el horario.';
  };

  updateCourtInfoDisplay();

  scheduleDateField?.addEventListener('change', updateCourtInfoDisplay);
  scheduleDateField?.addEventListener('input', updateCourtInfoDisplay);

  if (notifyField) {
    notifyField.checked = !match?.scheduledAt;
  }

  let schedulePicker = null;
  if (schedulePickerContainer && scheduleDateField && scheduledField) {
    schedulePicker = createMatchScheduleSlotPicker({
      container: schedulePickerContainer,
      dateField: scheduleDateField,
      scheduledField,
      courtField,
      templates: scheduleTemplates,
      scope: 'admin',
      existingValue: scheduledField?.value || '',
      existingCourt: courtField?.value || match?.court || '',
      ignoreMatchId: match?._id || '',
      ignoreManualLimit: hasCourtManagementAccess(),
      onChange: () => {
        updateCourtInfoDisplay();
        if (statusField) {
          const hasSchedule = Boolean(scheduledField.value);
          if (hasSchedule && statusField.value === 'pendiente') {
            statusField.value = 'programado';
          } else if (!hasSchedule && statusField.value === 'programado') {
            statusField.value = 'pendiente';
          }
        }
      },
    });

    scheduleClearButton?.addEventListener('click', (event) => {
      event.preventDefault();
      schedulePicker.clear();
      updateCourtInfoDisplay();
    });
  }

  if (!schedulePicker && scheduledField && statusField) {
    const updateStatusForSchedule = () => {
      const hasSchedule = Boolean(scheduledField.value);
      if (hasSchedule && statusField.value === 'pendiente') {
        statusField.value = 'programado';
      } else if (!hasSchedule && statusField.value === 'programado') {
        statusField.value = 'pendiente';
      }
    };
    scheduledField.addEventListener('input', updateStatusForSchedule);
    scheduledField.addEventListener('change', updateStatusForSchedule);
    updateStatusForSchedule();
  }

  cancelButton?.addEventListener('click', (event) => {
    event.preventDefault();
    setStatusMessage(statusMessage, '', '');
    closeModal();
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    if (!isAdmin()) return;

    const succeeded = await submitTournamentMatchSchedule({
      form,
      tournamentId: resolvedTournamentId,
      categoryId: resolvedCategoryId,
      matchId: normalizedMatchId,
      statusElement: statusMessage,
      submitButton,
    });

    if (succeeded) {
      closeModal();
    }
  });

  openModal({
    title: match?.scheduledAt ? 'Editar horario del partido' : 'Programar partido',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(statusMessage);
    },
    onClose: () => {
      setStatusMessage(statusMessage, '', '');
      schedulePicker?.destroy();
    },
  });
}

function openTournamentMatchResultModal(matchId, context = {}) {
  if (!isAdmin()) return;

  const normalizedMatchId = normalizeId(matchId);
  if (!normalizedMatchId) {
    showGlobalMessage('Selecciona un partido válido.', 'error');
    return;
  }

  let resolvedTournamentId = normalizeId(context.tournamentId) || '';
  let resolvedCategoryId = normalizeId(context.categoryId) || '';
  let match = context.match || null;

  if (!match) {
    const located = findTournamentMatchContext(normalizedMatchId);
    if (located) {
      match = located.match;
      resolvedTournamentId = resolvedTournamentId || normalizeId(located.tournamentId) || '';
      resolvedCategoryId = resolvedCategoryId || normalizeId(located.categoryId) || '';
    }
  }

  if (!resolvedTournamentId) {
    resolvedTournamentId =
      normalizeId(state.selectedMatchTournamentId) ||
      normalizeId(state.selectedBracketTournamentId) ||
      '';
  }

  if (!resolvedCategoryId) {
    resolvedCategoryId =
      normalizeId(state.selectedMatchCategoryId) ||
      normalizeId(state.selectedBracketCategoryId) ||
      '';
  }

  if (!match && resolvedTournamentId && resolvedCategoryId) {
    const cacheKey = `${resolvedTournamentId}:${resolvedCategoryId}`;
    if (state.tournamentMatches instanceof Map && state.tournamentMatches.has(cacheKey)) {
      const list = state.tournamentMatches.get(cacheKey) || [];
      match = list.find((entry) => normalizeId(entry) === normalizedMatchId) || match;
    }
    if (!match && state.tournamentBracketMatches instanceof Map) {
      const bracketMatches = state.tournamentBracketMatches.get(cacheKey);
      if (Array.isArray(bracketMatches)) {
        match = bracketMatches.find((entry) => normalizeId(entry) === normalizedMatchId) || match;
      }
    }
  }

  if (!match) {
    showGlobalMessage('No se encontró el partido del torneo.', 'error');
    return;
  }

  const tournament = getTournamentById(resolvedTournamentId) || {};
  let category = getTournamentCategoryById(resolvedTournamentId, resolvedCategoryId);

  if (!category && resolvedTournamentId) {
    const detail = state.tournamentDetails.get(resolvedTournamentId);
    if (detail && Array.isArray(detail.categories)) {
      category = detail.categories.find((entry) => normalizeId(entry) === resolvedCategoryId) || null;
    }
  }

  const players = Array.isArray(match?.players) ? match.players.filter(Boolean) : [];
  const winnerOptions = players
    .map((player, index) => {
      const playerId = normalizeId(player);
      if (!playerId) {
        return '';
      }
      const label = getPlayerDisplayName(player) || `Jugador ${index + 1}`;
      return `<option value="${playerId}">${escapeHtml(label)}</option>`;
    })
    .filter(Boolean)
    .join('');

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <p class="form-hint">
      Registra el resultado definitivo del partido. El cuadro se actualizará automáticamente tras guardarlo.
    </p>
    <label>
      Torneo
      <input type="text" name="tournamentLabel" readonly />
    </label>
    <label>
      Categoría
      <input type="text" name="categoryLabel" readonly />
    </label>
    <div class="form-grid">
      <label>
        Jugador 1
        <input type="text" name="playerLabel1" readonly />
      </label>
      <label>
        Jugador 2
        <input type="text" name="playerLabel2" readonly />
      </label>
    </div>
    <label>
      Ganador
      <select name="winner" required>
        <option value="">Selecciona al ganador</option>
        ${winnerOptions}
      </select>
      <span class="form-hint">Solo puedes escoger entre los jugadores asignados.</span>
    </label>
    <label>
      Marcador
      <input type="text" name="score" placeholder="Ej: 6-4 3-6 10-8" maxlength="60" />
      <span class="form-hint">Introduce el marcador final o utiliza "WO" si corresponde.</span>
    </label>
    <label>
      Notas
      <textarea name="notes" rows="3" maxlength="300" placeholder="Información adicional del partido"></textarea>
    </label>
    <div class="form-actions">
      <button type="submit" class="primary">Guardar resultado</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  const statusMessage = document.createElement('p');
  statusMessage.className = 'status-message';
  statusMessage.style.display = 'none';

  const tournamentField = form.elements.tournamentLabel;
  const categoryField = form.elements.categoryLabel;
  const playerOneField = form.elements.playerLabel1;
  const playerTwoField = form.elements.playerLabel2;
  const winnerField = form.elements.winner;
  const scoreField = form.elements.score;
  const notesField = form.elements.notes;
  const cancelButton = form.querySelector('button[data-action="cancel"]');
  const submitButton = form.querySelector('button[type="submit"]');

  const playerNames = players.map((player, index) => {
    if (typeof player === 'object' && player) {
      return getPlayerDisplayName(player) || `Jugador ${index + 1}`;
    }
    const playerId = normalizeId(player);
    if (!playerId) {
      return `Jugador ${index + 1}`;
    }
    const statePlayer = Array.isArray(state.players)
      ? state.players.find((item) => normalizeId(item) === playerId)
      : null;
    return getPlayerDisplayName(statePlayer) || `Jugador ${index + 1}`;
  });

  if (tournamentField) {
    tournamentField.value = tournament?.name || 'Torneo';
  }
  if (categoryField) {
    categoryField.value = category?.name || 'Categoría';
  }
  if (playerOneField) {
    playerOneField.value = playerNames[0] || 'Jugador por definir';
  }
  if (playerTwoField) {
    playerTwoField.value = playerNames[1] || 'Jugador por definir';
  }

  if (winnerField && players.length === 0) {
    winnerField.disabled = true;
    if (submitButton) {
      submitButton.disabled = true;
    }
    setStatusMessage(
      statusMessage,
      'warning',
      'Asigna jugadores al partido antes de registrar el resultado.'
    );
  } else {
    setStatusMessage(statusMessage, '', '');
  }

  const existingWinnerId = normalizeId(match?.result?.winner);
  if (winnerField && existingWinnerId) {
    winnerField.value = existingWinnerId;
  }

  if (scoreField && typeof match?.result?.score === 'string') {
    scoreField.value = match.result.score;
  }
  if (notesField && typeof match?.result?.notes === 'string') {
    notesField.value = match.result.notes;
  }

  cancelButton?.addEventListener('click', (event) => {
    event.preventDefault();
    setStatusMessage(statusMessage, '', '');
    closeModal();
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    if (!isAdmin()) return;

    const succeeded = await submitTournamentMatchResult({
      form,
      tournamentId: resolvedTournamentId,
      categoryId: resolvedCategoryId,
      matchId: normalizedMatchId,
      statusElement: statusMessage,
      submitButton,
    });

    if (succeeded) {
      closeModal();
    }
  });

  openModal({
    title: match?.result?.winner ? 'Editar resultado del partido' : 'Registrar resultado del partido',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(statusMessage);
    },
    onClose: () => setStatusMessage(statusMessage, '', ''),
  });
}

function openRulesEditorModal(scope = 'league') {
  if (!isAdmin()) return;

  const club = state.club || {};
  const isTournament = scope === 'tournament';
  const existingContent = getRegulationHtml(
    isTournament ? club.tournamentRegulation : club.regulation
  );

  const description = isTournament
    ? 'Redacta el reglamento de torneos con formato enriquecido (negritas, cursivas, encabezados y listas).'
    : 'Redacta el reglamento de la liga con formato enriquecido (negritas, cursivas, encabezados y listas).';
  const placeholder = isTournament
    ? 'Describe el reglamento de torneos con formato enriquecido'
    : 'Describe el reglamento del club con formato enriquecido';

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <p class="form-hint">
      ${description}
      Los cambios estarán disponibles inmediatamente para todos los jugadores.
    </p>
    <div data-mount="regulation"></div>
    <div class="form-actions">
      <button type="submit" class="primary">Guardar reglamento</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const mount = form.querySelector('[data-mount="regulation"]');
  const editor = createRegulationEditor(existingContent, placeholder);
  mount?.appendChild(editor.element);

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    if (!isAdmin()) return;

    const content = editor.getValue();
    if (!content) {
      setStatusMessage(status, 'error', 'Añade contenido antes de guardar el reglamento.');
      return;
    }

    if (content.length > 5000) {
      setStatusMessage(
        status,
        'error',
        'El reglamento supera el límite máximo de 5000 caracteres permitidos.'
      );
      return;
    }

    const payload = isTournament
      ? { tournamentRegulation: content }
      : { regulation: content };

    const savingMessage = isTournament
      ? 'Guardando reglamento de torneos...'
      : 'Guardando reglamento...';
    const successMessage = isTournament
      ? 'Reglamento de torneos actualizado correctamente.'
      : 'Reglamento actualizado correctamente.';
    const toastMessage = isTournament
      ? 'Reglamento de torneos actualizado.'
      : 'Reglamento del club actualizado.';

    setStatusMessage(status, 'info', savingMessage);

    try {
      const updated = await request('/club', { method: 'PUT', body: payload });
      renderClubProfile(updated);
      setStatusMessage(status, 'success', successMessage);
      closeModal();
      showGlobalMessage(toastMessage);
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    }
  });

  form.querySelector('[data-action="cancel"]')?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  openModal({
    title: isTournament ? 'Editar reglamento de torneos' : 'Editar reglamento del club',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

function openGenerateMatchesModal(preselectedCategoryId = '') {
  if (!isAdmin()) return;

  if (!Array.isArray(state.categories) || !state.categories.length) {
    showGlobalMessage('Crea al menos una categoría antes de generar partidos.', 'warning');
    return;
  }

  const categories = Array.isArray(state.categories) ? [...state.categories] : [];
  const leagues = Array.isArray(state.leagues) ? [...state.leagues] : [];
  const stateLeagueMap = new Map();
  leagues.forEach((league) => {
    const id = normalizeId(league);
    if (id && !stateLeagueMap.has(id)) {
      stateLeagueMap.set(id, league);
    }
  });

  const categoriesByLeague = new Map();
  const leagueDetailsMap = new Map();
  const UNASSIGNED_LEAGUE_VALUE = '__unassigned__';

  const registerLeague = (league) => {
    if (!league) return;
    const id = normalizeId(league);
    if (!id || leagueDetailsMap.has(id)) return;
    if (typeof league === 'object') {
      leagueDetailsMap.set(id, league);
    } else if (stateLeagueMap.has(id)) {
      leagueDetailsMap.set(id, stateLeagueMap.get(id));
    } else {
      leagueDetailsMap.set(id, { _id: id });
    }
  };

  categories.forEach((category) => {
    const leagueId = normalizeId(category.league);
    const key = leagueId || UNASSIGNED_LEAGUE_VALUE;
    if (!categoriesByLeague.has(key)) {
      categoriesByLeague.set(key, []);
    }
    categoriesByLeague.get(key).push(category);
    if (leagueId) {
      registerLeague(category.league || stateLeagueMap.get(leagueId));
    }
  });

  const normalizedPreselectedCategoryId = preselectedCategoryId
    ? normalizeId(preselectedCategoryId)
    : '';
  let initialLeagueId = '';
  if (normalizedPreselectedCategoryId) {
    const categoryEntry = categories.find(
      (item) => normalizeId(item) === normalizedPreselectedCategoryId
    );
    if (categoryEntry) {
      initialLeagueId = normalizeId(categoryEntry.league);
      if (!initialLeagueId && categoriesByLeague.has(UNASSIGNED_LEAGUE_VALUE)) {
        initialLeagueId = UNASSIGNED_LEAGUE_VALUE;
      }
    }
  }

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Liga
      <select name="leagueId" required>
        <option value="">Selecciona una liga</option>
      </select>
    </label>
    <label>
      Categoría
      <select name="categoryId" required disabled>
        <option value="">Selecciona una categoría</option>
      </select>
    </label>
    <p class="form-hint">
      El sistema generará enfrentamientos pendientes entre los jugadores inscritos que aún no hayan jugado entre sí.
    </p>
    <div class="form-actions">
      <button type="submit" class="primary">Generar partidos</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const leagueSelect = form.elements.leagueId;
  const categorySelect = form.elements.categoryId;
  const submitButton = form.querySelector('button[type="submit"]');

  const formatLeagueLabel = (league) => {
    if (!league || typeof league !== 'object') {
      return 'Liga';
    }
    const parts = [];
    const name = typeof league.name === 'string' && league.name.trim() ? league.name.trim() : 'Liga';
    parts.push(name);
    if (league.year) {
      parts.push(league.year);
    }
    return parts.join(' · ');
  };

  if (leagueSelect) {
    const leagueOptionEntries = [];
    categoriesByLeague.forEach((list, key) => {
      if (key === UNASSIGNED_LEAGUE_VALUE) return;
      if (!Array.isArray(list) || !list.length) return;
      const info = leagueDetailsMap.get(key) || stateLeagueMap.get(key) || { _id: key };
      leagueOptionEntries.push({ id: key, info });
    });

    leagueOptionEntries
      .sort((a, b) => (a.info?.name || '').localeCompare(b.info?.name || '', 'es'))
      .forEach(({ id, info }) => {
        if (info?.status === 'cerrada') {
          return;
        }

        const option = document.createElement('option');
        option.value = id;
        option.textContent = formatLeagueLabel(info);
        leagueSelect.appendChild(option);
      });

    if (categoriesByLeague.has(UNASSIGNED_LEAGUE_VALUE)) {
      const option = document.createElement('option');
      option.value = UNASSIGNED_LEAGUE_VALUE;
      option.textContent = 'Sin liga asignada';
      leagueSelect.appendChild(option);
    }

    const enabledLeagueOptions = Array.from(leagueSelect.options || []).filter(
      (option) => option.value && !option.disabled
    );
    if (!enabledLeagueOptions.length) {
      leagueSelect.disabled = true;
      if (categorySelect) {
        categorySelect.disabled = true;
      }
      if (submitButton) {
        submitButton.disabled = true;
      }
      setStatusMessage(
        status,
        'warning',
        'Todas las ligas activas están cerradas. No es posible generar partidos pendientes.'
      );
    }
  }

  const resolveCategoriesForLeague = (leagueId) => {
    if (!leagueId) return [];
    if (leagueId === UNASSIGNED_LEAGUE_VALUE) {
      return categoriesByLeague.get(UNASSIGNED_LEAGUE_VALUE) || [];
    }
    return categoriesByLeague.get(leagueId) || [];
  };

  const updateCategoryOptions = ({ leagueId, targetCategoryId } = {}) => {
    if (!categorySelect) return '';
    categorySelect.innerHTML = '<option value="">Selecciona una categoría</option>';
    categorySelect.disabled = true;

    const categoryList = resolveCategoriesForLeague(leagueId);
    if (!categoryList.length) {
      return '';
    }

    const normalizedCategories = categoryList
      .map((entry) => ({ id: normalizeId(entry), category: entry }))
      .filter((entry) => entry.id)
      .sort((a, b) => (a.category.name || '').localeCompare(b.category.name || '', 'es'));

    if (!normalizedCategories.length) {
      return '';
    }

    normalizedCategories.forEach((entry) => {
      const option = new Option(entry.category.name || 'Categoría', entry.id);
      categorySelect.appendChild(option);
    });

    categorySelect.disabled = false;

    const desiredValue = targetCategoryId && normalizedCategories.some((entry) => entry.id === targetCategoryId)
      ? targetCategoryId
      : normalizedCategories.length === 1
      ? normalizedCategories[0].id
      : '';
    if (desiredValue) {
      categorySelect.value = desiredValue;
    } else {
      categorySelect.value = '';
    }

    return categorySelect.value || '';
  };

  const selectInitialLeague = (desiredLeagueId) => {
    if (!leagueSelect) return '';
    const options = Array.from(leagueSelect.options || []);
    const desiredOption = options.find(
      (option) => option.value === desiredLeagueId && !option.disabled
    );
    if (desiredOption) {
      leagueSelect.value = desiredOption.value;
    } else if (leagueSelect.value) {
      const currentOption = leagueSelect.options[leagueSelect.selectedIndex];
      if (currentOption?.disabled) {
        leagueSelect.value = '';
      }
    }
    if (!leagueSelect.value) {
      const availableOptions = options.filter((option) => option.value && !option.disabled);
      if (availableOptions.length === 1) {
        leagueSelect.value = availableOptions[0].value;
      } else {
        leagueSelect.value = '';
      }
    }
    return leagueSelect.value || '';
  };

  const selectedLeagueId = selectInitialLeague(initialLeagueId);
  updateCategoryOptions({
    leagueId: selectedLeagueId,
    targetCategoryId: normalizedPreselectedCategoryId,
  });

  leagueSelect?.addEventListener('change', (event) => {
    setStatusMessage(status, '', '');
    updateCategoryOptions({ leagueId: event.target.value });
  });

  categorySelect?.addEventListener('change', () => {
    setStatusMessage(status, '', '');
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const categoryId = categorySelect ? categorySelect.value : '';
    if (!categoryId) {
      setStatusMessage(status, 'error', 'Selecciona la categoría a generar.');
      return;
    }

    setStatusMessage(status, 'info', 'Creando enfrentamientos pendientes...');

    try {
      const result = await request(`/categories/${categoryId}/generate-matches`, { method: 'POST' });
      const created = Number(result?.created || 0);
      const message =
        created > 0
          ? `Se generaron ${created} partidos pendientes.`
          : result?.message || 'No había nuevos partidos por crear.';
      setStatusMessage(status, 'success', message);
      await loadAllData();
      closeModal();
      showGlobalMessage(message);
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    }
  });

  form.querySelector('[data-action="cancel"]')?.addEventListener('click', () => {
    setStatusMessage(status, '', '');
    closeModal();
  });

  openModal({
    title: 'Generar partidos pendientes',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

function openResultModal(matchId) {
  if (!matchId) return;

  const normalizedId = normalizeId(matchId);
  const match = findMatchById(normalizedId);

  if (!match || !Array.isArray(match.players) || match.players.length < 2) {
    showGlobalMessage('No fue posible cargar los datos del partido.', 'error');
    return;
  }

  if (!isAdmin() && !isUserMatchParticipant(match)) {
    showGlobalMessage('Solo puedes registrar resultados de tus partidos.', 'error');
    return;
  }

  const participants = getMatchScores(match);
  if (participants.length < 2) {
    showGlobalMessage('No fue posible identificar a los jugadores del partido.', 'error');
    return;
  }
  const currentWinnerId = normalizeId(match.result?.winner);
  const existingSets = getMatchSets(match);
  const matchFormat = match?.category?.matchFormat || DEFAULT_CATEGORY_MATCH_FORMAT;
  const fallbackFormat =
    MATCH_FORMAT_METADATA[DEFAULT_CATEGORY_MATCH_FORMAT] ||
    MATCH_FORMAT_METADATA.two_sets_six_games_super_tb || {
      description: '',
      minimumSets: 2,
      setDefinitions: [
        { number: 1, tieBreak: false, label: 'Set 1' },
        { number: 2, tieBreak: false, label: 'Set 2' },
        { number: 3, tieBreak: true, label: 'Super tie-break' },
      ],
    };
  const formatDefinition = MATCH_FORMAT_METADATA[matchFormat] || fallbackFormat;
  const baseSetDefinitions =
    Array.isArray(formatDefinition.setDefinitions) && formatDefinition.setDefinitions.length
      ? formatDefinition.setDefinitions
      : fallbackFormat.setDefinitions;
  const setDefinitionMap = new Map(
    (baseSetDefinitions || []).map((definition) => [definition.number, { ...definition }])
  );
  existingSets.forEach((set) => {
    if (!setDefinitionMap.has(set.number)) {
      setDefinitionMap.set(set.number, {
        number: set.number,
        tieBreak: Boolean(set.tieBreak),
        label: set.tieBreak ? `Super tie-break` : `Set ${set.number}`,
      });
    }
  });
  const orderedDefinitions = Array.from(setDefinitionMap.values()).sort((a, b) => a.number - b.number);
  const setDefinitions = orderedDefinitions.length
    ? orderedDefinitions
    : [
        { number: 1, tieBreak: false, label: 'Set 1' },
        { number: 2, tieBreak: false, label: 'Set 2' },
        { number: 3, tieBreak: true, label: 'Super tie-break' },
      ];
  const minimumSets = Number.isFinite(formatDefinition.minimumSets)
    ? formatDefinition.minimumSets
    : fallbackFormat.minimumSets;
  const formatHintMarkup = formatDefinition.description
    ? `<p class="form-hint match-format-hint">${formatDefinition.description}</p>`
    : '';

  const form = document.createElement('form');
  form.className = 'form';

  const playersMarkup = participants
    .map(({ player, id }) => {
      const name = player?.fullName || player?.email || 'Jugador';
      return `
        <label class="radio-field">
          <input type="radio" name="winner" value="${id}" ${currentWinnerId === id ? 'checked' : ''} required />
          <span>${name}</span>
        </label>
      `;
    })
    .join('');

  const setRows = setDefinitions
    .map((definition) => {
      const { number: setNumber, tieBreak: isTieBreak } = definition;
      const stored = existingSets.find((set) => set.number === setNumber);
      const legend = definition.label || (isTieBreak ? 'Super tie-break' : `Set ${setNumber}`);
      const inputs = participants
        .map(({ id, player }) => {
          const currentValue = stored?.scores?.[id] ?? 0;
          const name = player?.fullName || player?.email || 'Jugador';
          return `
            <label>
              ${name}
              <input type="number" name="set${setNumber}-${id}" min="0" step="1" value="${
                Number.isFinite(currentValue) ? currentValue : 0
              }" />
            </label>
          `;
        })
        .join('');

      return `
        <fieldset data-set="${setNumber}">
          <legend>${legend}</legend>
          <div class="form-grid">${inputs}</div>
        </fieldset>
      `;
    })
    .join('');

  form.innerHTML = `
    ${formatHintMarkup}
    <fieldset>
      <legend>Ganador del partido</legend>
      <div class="form-grid form-grid--columns-1">${playersMarkup}</div>
    </fieldset>
    ${setRows}
    <label>
      Notas
      <textarea name="notes" rows="3" maxlength="500" placeholder="Comentarios opcionales">${
        match.result?.notes || ''
      }</textarea>
    </label>
    <div class="form-actions">
      <button type="submit" class="primary">Guardar resultado</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
    </div>
  `;

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const formData = new FormData(form);
    const winnerId = formData.get('winner');

    if (!winnerId) {
      setStatusMessage(status, 'error', 'Selecciona el jugador ganador.');
      return;
    }

    const setsPayload = setDefinitions
      .map(({ number: setNumber, tieBreak }) => {
        const scores = participants.reduce((acc, { id }) => {
          const value = Number(formData.get(`set${setNumber}-${id}`));
          acc[id] = Number.isFinite(value) && value >= 0 ? Math.floor(value) : 0;
          return acc;
        }, {});
        const total = Object.values(scores).reduce((acc, value) => acc + value, 0);
        if (total === 0) {
          return null;
        }
        return {
          number: setNumber,
          tieBreak: Boolean(tieBreak),
          scores,
        };
      })
      .filter(Boolean);

    if (setsPayload.length < minimumSets) {
      const setLabel = minimumSets === 1 ? 'un set' : `${minimumSets} sets`;
      setStatusMessage(status, 'error', `Introduce al menos ${setLabel} para registrar el resultado.`);
      return;
    }

    const scorePayload = setsPayload.reduce((acc, set) => {
      Object.entries(set.scores).forEach(([playerId, value]) => {
        const current = acc[playerId] || 0;
        acc[playerId] = current + value;
      });
      return acc;
    }, {});

    setStatusMessage(status, 'info', 'Guardando resultado...');

    try {
      await request(`/matches/${normalizedId}/result`, {
        method: 'POST',
        body: {
          winnerId,
          sets: setsPayload,
          scores: scorePayload,
          notes: (formData.get('notes') || '').trim() || undefined,
        },
      });
      setStatusMessage(status, 'success', 'Resultado enviado.');
      closeModal();
      await loadAllData();
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    }
  });

  form.querySelector('[data-action="cancel"]')?.addEventListener('click', () => {
    closeModal();
  });

  openModal({
    title: 'Registrar resultado',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

async function openEnrollmentModal(categoryId, { focusRequests = false } = {}) {
  if (!isAdmin() || !categoryId) return;

  const category = state.categories.find((item) => normalizeId(item) === categoryId);
  if (!category) {
    showGlobalMessage('Categoría no encontrada.', 'error');
    return;
  }

  try {
    await loadEnrollments(categoryId);
  } catch (error) {
    showGlobalMessage(error.message, 'error');
  }

  let requestLoadError = null;
  try {
    state.enrollmentRequests.delete(categoryId);
    await loadEnrollmentRequests(categoryId);
  } catch (error) {
    requestLoadError = error;
  }

  if (!Array.isArray(state.players) || !state.players.length) {
    try {
      const players = await request('/players');
      state.players = Array.isArray(players) ? players : [];
    } catch (error) {
      showGlobalMessage('No fue posible cargar la lista de jugadores.', 'error');
      return;
    }
  }

  const container = document.createElement('div');
  container.className = 'enrollment-modal';

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  const header = document.createElement('p');
  header.className = 'meta';
  header.textContent = `Jugadores inscritos en ${category.name}`;
  container.appendChild(header);

  const requestHeader = document.createElement('p');
  requestHeader.className = 'meta';
  requestHeader.textContent = 'Solicitudes de inscripción pendientes';
  container.appendChild(requestHeader);

  const requestList = document.createElement('ul');
  requestList.className = 'list compact';
  container.appendChild(requestList);

  const list = document.createElement('ul');
  list.className = 'list compact';
  container.appendChild(list);

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Añadir jugador
      <select name="playerId" required></select>
    </label>
    <div class="form-actions">
      <button type="submit" class="primary">Inscribir</button>
    </div>
  `;
  container.appendChild(form);
  container.appendChild(status);

  const select = form.elements.playerId;

  function refreshSelect() {
    const enrollments = state.enrollments.get(categoryId) || [];
    const enrolledIds = new Set(enrollments.map((enrollment) => normalizeId(enrollment.user)));
    select.innerHTML = '<option value="">Selecciona un jugador</option>';
    state.players
      .filter((player) => entityHasRole(player, 'player') && !enrolledIds.has(normalizeId(player)))
      .sort((a, b) => (a.fullName || '').localeCompare(b.fullName || '', 'es'))
      .forEach((player) => {
        const option = document.createElement('option');
        option.value = player._id || player.id;
        option.textContent = player.fullName || player.email;
        select.appendChild(option);
      });
  }

  function renderEnrollmentRequests() {
    const requests = state.enrollmentRequests.get(categoryId) || [];
    requestList.innerHTML = '';

    if (!requests.length) {
      requestList.innerHTML = '<li class="empty-state">No hay solicitudes pendientes.</li>';
      return;
    }

    requests.forEach((entry) => {
      const item = document.createElement('li');
      const name = entry.user?.fullName || entry.user?.email || 'Jugador';
      const title = document.createElement('strong');
      title.textContent = name;
      item.appendChild(title);

      const meta = document.createElement('div');
      meta.className = 'meta';
      const email = entry.user?.email;
      if (email) {
        meta.appendChild(document.createElement('span')).textContent = email;
      }
      const phone = entry.user?.phone;
      if (phone) {
        meta.appendChild(document.createElement('span')).textContent = phone;
      }
      const schedule = entry.user?.preferredSchedule;
      if (schedule) {
        meta.appendChild(document.createElement('span')).textContent = `Horario: ${translateSchedule(schedule)}`;
      }
      if (entry.createdAt) {
        const createdDate = formatDate(entry.createdAt);
        const createdTime = formatTime(entry.createdAt);
        meta.appendChild(document.createElement('span')).textContent = `Solicitada el ${createdDate} · ${createdTime}`;
      }
      item.appendChild(meta);

      const requestActions = document.createElement('div');
      requestActions.className = 'actions';

      const approveButton = document.createElement('button');
      approveButton.type = 'button';
      approveButton.className = 'primary';
      approveButton.dataset.requestId = entry._id || entry.id;
      approveButton.dataset.action = 'approve-request';
      approveButton.textContent = 'Aprobar';
      requestActions.appendChild(approveButton);

      const rejectButton = document.createElement('button');
      rejectButton.type = 'button';
      rejectButton.className = 'ghost';
      rejectButton.dataset.requestId = entry._id || entry.id;
      rejectButton.dataset.action = 'reject-request';
      rejectButton.textContent = 'Rechazar';
      requestActions.appendChild(rejectButton);

      item.appendChild(requestActions);
      requestList.appendChild(item);
    });
  }

  function renderEnrollmentEntries() {
    const enrollments = state.enrollments.get(categoryId) || [];
    list.innerHTML = '';

    if (!enrollments.length) {
      list.innerHTML = '<li class="empty-state">Aún no hay jugadores inscritos.</li>';
      return;
    }

    enrollments
      .slice()
      .sort((a, b) => {
        const nameA = a.user?.fullName || a.user?.email || '';
        const nameB = b.user?.fullName || b.user?.email || '';
        return nameA.localeCompare(nameB, 'es');
      })
      .forEach((enrollment) => {
        const item = document.createElement('li');
        const name = enrollment.user?.fullName || enrollment.user?.email || 'Jugador';
        const title = document.createElement('strong');
        title.textContent = name;
        item.appendChild(title);

        const meta = document.createElement('div');
        meta.className = 'meta';
        if (enrollment.user?.email) {
          meta.appendChild(document.createElement('span')).textContent = enrollment.user.email;
        }
        if (enrollment.user?.phone) {
          meta.appendChild(document.createElement('span')).textContent = enrollment.user.phone;
        }
        item.appendChild(meta);

        const removeButton = document.createElement('button');
        removeButton.type = 'button';
        removeButton.className = 'ghost';
        removeButton.dataset.enrollmentId = enrollment._id || enrollment.id;
        removeButton.textContent = 'Quitar';
        item.appendChild(removeButton);

        list.appendChild(item);
      });
  }

  container.addEventListener('click', async (event) => {
    const requestButton = event.target.closest('button[data-request-id]');
    if (requestButton) {
      const { requestId, action } = requestButton.dataset;
      if (!requestId || !action) {
        return;
      }

      const isApprove = action === 'approve-request';
      const actionLabel = isApprove ? 'Aprobando solicitud...' : 'Rechazando solicitud...';
      const successMessage = isApprove
        ? 'Solicitud aprobada. El jugador ha sido inscrito.'
        : 'Solicitud rechazada.';

      const parentItem = requestButton.closest('li');
      const buttons = parentItem?.querySelectorAll('button[data-request-id]') || [];
      const previousLabels = new Map();
      buttons.forEach((btn) => {
        previousLabels.set(btn, btn.textContent);
        btn.disabled = true;
        if (btn === requestButton) {
          btn.textContent = isApprove ? 'Aprobando...' : 'Rechazando...';
        }
      });

      setStatusMessage(status, 'info', actionLabel);

      try {
        await request(`/categories/${categoryId}/enrollment-requests/${requestId}`, {
          method: 'PATCH',
          body: { action: isApprove ? 'approve' : 'reject' },
        });
        state.enrollmentRequests.delete(categoryId);
        state.enrollments.delete(categoryId);
        invalidateLeaguePaymentsByCategory(categoryId);
        await loadEnrollmentRequests(categoryId, { force: true });
        await loadEnrollments(categoryId);
        await reloadCategories();
        renderEnrollmentRequests();
        renderEnrollmentEntries();
        refreshSelect();
        setStatusMessage(status, 'success', successMessage);
      } catch (error) {
        setStatusMessage(status, 'error', error.message);
      } finally {
        buttons.forEach((btn) => {
          btn.disabled = false;
          const label = previousLabels.get(btn);
          if (label) {
            btn.textContent = label;
          }
        });
      }

      return;
    }

    const button = event.target.closest('button[data-enrollment-id]');
    if (!button) return;

    const enrollmentId = button.dataset.enrollmentId;
    button.disabled = true;
    setStatusMessage(status, 'info', 'Eliminando inscripción...');

    try {
      await request(`/categories/${categoryId}/enrollments/${enrollmentId}`, { method: 'DELETE' });
      state.enrollments.delete(categoryId);
      invalidateLeaguePaymentsByCategory(categoryId);
      await loadEnrollments(categoryId);
      renderEnrollmentEntries();
      refreshSelect();
      await reloadCategories();
      setStatusMessage(status, 'success', 'Inscripción eliminada.');
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    } finally {
      button.disabled = false;
    }
  });

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const playerId = select.value;
    if (!playerId) {
      setStatusMessage(status, 'error', 'Selecciona un jugador.');
      return;
    }

    setStatusMessage(status, 'info', 'Inscribiendo jugador...');

    try {
      await request('/categories/enroll', {
        method: 'POST',
        body: { categoryId, userId: playerId },
      });
      select.value = '';
      state.enrollments.delete(categoryId);
      invalidateLeaguePaymentsByCategory(categoryId);
      await loadEnrollments(categoryId);
      await loadEnrollmentRequests(categoryId, { force: true });
      await reloadCategories();
      renderEnrollmentEntries();
      renderEnrollmentRequests();
      refreshSelect();
      setStatusMessage(status, 'success', 'Jugador inscrito correctamente.');
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    }
  });

  renderEnrollmentRequests();
  renderEnrollmentEntries();
  refreshSelect();

  openModal({
    title: `Inscripciones · ${category.name}`,
    content: (body) => {
      body.appendChild(container);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });

  if (requestLoadError) {
    setStatusMessage(status, 'error', 'No fue posible cargar las solicitudes pendientes.');
  }
}

function openSeasonModal(seasonId = '') {
  if (!isAdmin()) return;

  const normalizedId = seasonId || '';
  const season = normalizedId
    ? state.seasons.find((item) => normalizeId(item) === normalizedId)
    : null;

  const categoryOptions = Array.isArray(state.categories)
    ? state.categories
        .map((category) => {
          const id = normalizeId(category);
          if (!id) return '';
          return `<option value="${id}">${category.name}</option>`;
        })
        .join('')
    : '';

  const form = document.createElement('form');
  form.className = 'form';
  form.innerHTML = `
    <label>
      Nombre de la temporada
      <input type="text" name="name" required />
    </label>
    <label>
      Año
      <input type="number" name="year" min="2000" max="2100" required />
    </label>
    <div class="form-grid">
      <label>
        Inicio
        <input type="date" name="startDate" />
      </label>
      <label>
        Fin
        <input type="date" name="endDate" />
      </label>
    </div>
    <label>
      Descripción
      <textarea name="description" rows="3" maxlength="500" placeholder="Detalles opcionales"></textarea>
    </label>
    <label>
      Categorías vinculadas
      <select name="categories" multiple size="5">${categoryOptions}</select>
      <span class="form-hint">Mantén presionada la tecla Ctrl (Cmd en Mac) para seleccionar varias categorías.</span>
    </label>
    <div class="form-actions">
      <button type="submit" class="primary">${season ? 'Actualizar' : 'Crear'} temporada</button>
      <button type="button" class="ghost" data-action="cancel">Cancelar</button>
      ${
        season
          ? '<button type="button" class="danger" data-action="delete">Eliminar temporada</button>'
          : ''
      }
    </div>
  `;

  form.elements.name.value = season?.name || '';
  form.elements.year.value = season?.year || new Date().getFullYear();
  if (season?.startDate) {
    form.elements.startDate.value = formatDateInput(season.startDate);
  }
  if (season?.endDate) {
    form.elements.endDate.value = formatDateInput(season.endDate);
  }
  form.elements.description.value = season?.description || '';

  const categorySelect = form.elements.categories;
  if (categorySelect && season?.categories?.length) {
    const selectedIds = season.categories.map((category) => normalizeId(category)).filter(Boolean);
    Array.from(categorySelect.options).forEach((option) => {
      option.selected = selectedIds.includes(option.value);
    });
  }

  const status = document.createElement('p');
  status.className = 'status-message';
  status.style.display = 'none';

  form.addEventListener('submit', async (event) => {
    event.preventDefault();
    const formData = new FormData(form);
    const payload = {
      name: (formData.get('name') || '').trim(),
      year: Number(formData.get('year')),
      description: (formData.get('description') || '').trim() || undefined,
    };

    const startDate = formData.get('startDate');
    const endDate = formData.get('endDate');
    payload.startDate = startDate || undefined;
    payload.endDate = endDate || undefined;

    payload.categories = Array.from(new Set(formData.getAll('categories')));

    setStatusMessage(
      status,
      'info',
      season ? 'Actualizando temporada...' : 'Creando temporada...'
    );

    try {
      if (season) {
        await request(`/seasons/${normalizedId}`, { method: 'PATCH', body: payload });
      } else {
        await request('/seasons', { method: 'POST', body: payload });
      }
      setStatusMessage(status, 'success', season ? 'Temporada actualizada.' : 'Temporada creada.');
      closeModal();
      await loadAllData();
    } catch (error) {
      setStatusMessage(status, 'error', error.message);
    }
  });

  form.querySelector('[data-action="cancel"]')?.addEventListener('click', () => {
    closeModal();
  });

  if (season) {
    form.querySelector('[data-action="delete"]')?.addEventListener('click', async () => {
      const confirmed = window.confirm('¿Eliminar esta temporada de forma permanente?');
      if (!confirmed) return;
      setStatusMessage(status, 'info', 'Eliminando temporada...');
      try {
        await request(`/seasons/${normalizedId}`, { method: 'DELETE' });
        setStatusMessage(status, 'success', 'Temporada eliminada.');
        closeModal();
        await loadAllData();
      } catch (error) {
        setStatusMessage(status, 'error', error.message);
      }
    });
  }

  openModal({
    title: season ? 'Editar temporada' : 'Nueva temporada',
    content: (body) => {
      body.appendChild(form);
      body.appendChild(status);
    },
    onClose: () => setStatusMessage(status, '', ''),
  });
}

function renderEnrollmentList(categoryId) {
  if (!adminEnrollmentList) return;

  adminEnrollmentList.innerHTML = '';

  if (!categoryId) {
    adminEnrollmentList.innerHTML =
      '<li class="empty-state">Selecciona una categoría para ver los jugadores asociados.</li>';
    return;
  }

  const enrollments = state.enrollments.get(categoryId);
  if (!enrollments) {
    adminEnrollmentList.innerHTML =
      '<li class="empty-state">Selecciona una categoría para ver los jugadores asociados.</li>';
    return;
  }

  if (!enrollments.length) {
    adminEnrollmentList.innerHTML =
      '<li class="empty-state">Aún no hay jugadores inscritos en esta categoría.</li>';
    return;
  }

  enrollments.forEach((enrollment) => {
    const item = document.createElement('li');
    const info = document.createElement('div');
    info.className = 'enrollment-player';

    const name = document.createElement('strong');
    name.textContent = enrollment.user?.fullName || 'Jugador';
    info.appendChild(name);

    const details = [];
    if (enrollment.user?.email) {
      details.push(enrollment.user.email);
    }
    if (enrollment.user?.phone) {
      details.push(enrollment.user.phone);
    }
    if (enrollment.user?.preferredSchedule) {
      details.push(`Horario: ${translateSchedule(enrollment.user.preferredSchedule)}`);
    }

    if (details.length) {
      const meta = document.createElement('span');
      meta.className = 'enrollment-meta';
      meta.textContent = details.join(' · ');
      info.appendChild(meta);
    }

    const removeButton = document.createElement('button');
    removeButton.type = 'button';
    removeButton.className = 'danger';
    removeButton.textContent = 'Quitar';
    removeButton.dataset.enrollmentId = enrollment._id || enrollment.id;
    removeButton.dataset.categoryId = categoryId;

    item.appendChild(info);
    item.appendChild(removeButton);
    adminEnrollmentList.appendChild(item);
  });
}

async function hydrateEnrollmentCache(categories) {
  if (!isAdmin()) return;
  if (!Array.isArray(categories) || !categories.length) return;

  const tasks = categories.map(async (category) => {
    const categoryId = category?._id || category?.id;
    if (!categoryId) return;
    if (state.enrollments.has(categoryId)) return;

    try {
      await loadEnrollments(categoryId);
    } catch (error) {
      state.enrollments.set(categoryId, []);
    }
  });

  await Promise.all(tasks);
}

async function loadGeneralChat() {
  try {
    const messages = await request('/chat/general');
    state.generalChatMessages = Array.isArray(messages) ? messages : [];
    syncNoticeBoardState(state.generalChatMessages);
    renderGeneralChat();
  } catch (error) {
    state.generalChatMessages = [];
    syncNoticeBoardState(state.generalChatMessages);
    renderGeneralChat();
  }
}

async function loadChatParticipants() {}

async function loadDirectChat() {}

function updateDirectChatFormState() {}

async function reloadCategories() {
  const categories = await request('/categories');
  const list = Array.isArray(categories) ? categories : [];
  state.categories = list;
  state.categoriesLoaded = true;
  updateRankingFilterControls({ renderOnChange: false });
  renderCategories(list);
  renderLeagues(state.leagues);
  updateLeaguePlayersControls();
  updateLeaguePaymentControls();
  if (state.activeSection === 'section-league-payments') {
    refreshLeaguePayments({ force: true }).catch((error) => {
      console.warn('No se pudo actualizar los pagos tras recargar las categorías', error);
    });
  }
  await refreshLeaguePlayers();
  await refreshAllRankings({ forceReload: true });
  if (isAdmin()) {
    renderAdminCategoryList();
    renderPlayerDirectory();
  }
}

async function loadAllData() {
  if (!state.token) return;

  try {
    const userId = state.user?.id || state.user?._id;
    if (!userId) {
      throw new Error('No fue posible identificar al usuario autenticado.');
    }

    state.courtAvailabilityDate = new Date(state.courtAvailabilityDate || Date.now());
    state.courtAvailabilityDate.setHours(0, 0, 0, 0);
    state.courtAdminDate = new Date(state.courtAdminDate || Date.now());
    state.courtAdminDate.setHours(0, 0, 0, 0);

    state.enrollments.clear();
    state.enrollmentRequests.clear();
    state.categoriesLoaded = false;
    const [leagues, categories, tournaments] = await Promise.all([
      request('/leagues'),
      request('/categories'),
      request('/tournaments').catch(() => []),
    ]);
    state.leagues = Array.isArray(leagues) ? leagues : [];
    renderLeagues(state.leagues);
    updateLeaguePaymentControls();

    const categoryList = Array.isArray(categories) ? categories : [];
    state.categories = categoryList;
    state.categoriesLoaded = true;
    updateRankingFilterControls({ renderOnChange: false });
    renderCategories(categoryList);
    renderLeagues(state.leagues);
    updateLeaguePlayersControls();
    updateLeaguePaymentControls();
    if (state.selectedLeagueId) {
      await refreshLeagueDetail(state.selectedLeagueId, { force: true });
    }
    await refreshLeaguePlayers();
    await refreshAllRankings({ forceReload: true });

    state.tournaments = Array.isArray(tournaments) ? tournaments : [];
    updateTournamentSelectors();
    updateTournamentPaymentControls();
    if (state.selectedTournamentId) {
      await refreshTournamentDetail(state.selectedTournamentId);
    }
    populateCourtBlockEntities();
    ensureCourtBlockRangeDefaults(state.courtAdminDate);

    await Promise.all([
      loadGlobalOverview(),
      loadLeagueDashboard(),
      loadTournamentDashboard(),
      loadAccountSummary(),
    ]);

    const [
      upcomingMatches,
      myMatches,
      notifications,
      clubProfile,
      seasons,
      calendarMatches,
      completedMatches,
      pendingReviewMatches,
    ] = await Promise.all([
      request('/matches?statuses=programado,revision'),
      request(`/matches?playerId=${userId}&includeDrafts=true`),
      request('/notifications/mine?upcoming=true').catch(() => []),
      request('/club').catch(() => null),
      request('/seasons').catch(() => []),
      request('/matches?statuses=pendiente,propuesto,programado,revision,completado,finalizado'),
      request('/matches?status=completado').catch(() => []),
      request('/matches?resultStatus=en_revision').catch(() => []),
    ]);

    state.upcomingMatches = Array.isArray(upcomingMatches) ? upcomingMatches : [];
    resetAllMatchPagination();
    renderMatches(
      state.upcomingMatches,
      upcomingList,
      'No hay partidos programados.',
      { listKey: 'upcoming' }
    );
    state.myMatches = Array.isArray(myMatches) ? myMatches : [];
    renderMyMatches(state.myMatches);
    let pendingMatches = Array.isArray(pendingReviewMatches) ? pendingReviewMatches : [];
    if (!isAdmin()) {
      const currentUserId = normalizeId(state.user);
      pendingMatches = pendingMatches.filter((match) =>
        Array.isArray(match.players)
          ? match.players.some((player) => normalizeId(player) === currentUserId)
          : false
      );
    }
    state.pendingApprovalMatches = pendingMatches;
    renderMatches(
      state.pendingApprovalMatches,
      pendingApprovalsList,
      'No hay resultados pendientes por aprobar.',
      { listKey: 'pending' }
    );
    state.completedMatches = Array.isArray(completedMatches) ? completedMatches : [];
    renderMatches(
      state.completedMatches,
      completedMatchesList,
      'Aún no hay partidos confirmados para mostrar.',
      { listKey: 'completed' }
    );
    renderNotifications(notifications);
    if (clubProfile) {
      renderClubProfile(clubProfile);
      if (!courtReservationDateInput?.value) {
        resetCourtReservationForm();
      }
    }
    populateCourtBlockCourts();
    state.seasons = Array.isArray(seasons) ? seasons : [];
    state.calendarMatches = Array.isArray(calendarMatches) ? calendarMatches : [];
    renderAdminMatchList(state.calendarMatches);
    renderAllCalendars();

    await loadPlayerCourtData();
    if (hasCourtManagementAccess()) {
      await Promise.all([loadAdminCourtData(), loadCourtCalendarData()]);
    } else {
      state.courtAdminSchedule = [];
      state.courtAdminBlocks = [];
      renderCourtAdminSchedule();
      resetCourtCalendarView();
    }

    if (isAdmin()) {
      await hydrateEnrollmentCache(categoryList);
      const allUsers = await request('/players');
      state.players = Array.isArray(allUsers) ? allUsers : [];
      renderCategories(state.categories);
      populateAdminSelects();
      renderAdminCategoryList();
      renderAdminPlayerList();
      renderPlayerDirectory();
      renderAdminMatchList(state.calendarMatches);
      const selectedCategory = adminEnrollmentCategory?.value;
      if (selectedCategory) {
        try {
          await loadEnrollments(selectedCategory);
          renderEnrollmentList(selectedCategory);
          setStatusMessage(adminEnrollmentStatus, '', '');
        } catch (error) {
          state.enrollments.delete(selectedCategory);
          invalidateLeaguePaymentsByCategory(selectedCategory);
          if (adminEnrollmentList) {
            adminEnrollmentList.innerHTML =
              '<li class="empty-state">No fue posible cargar las inscripciones.</li>';
          }
          setStatusMessage(adminEnrollmentStatus, 'error', error.message);
        }
      } else {
        renderEnrollmentList('');
      }
    }

    await loadGeneralChat();
    await syncPushSubscriptionState();
  } catch (error) {
    showGlobalMessage(error.message, 'error');
}
}

async function checkSetupStatus() {
  try {
    const data = await request('/auth/setup-status', { requireAuth: false });
    state.needsSetup = Boolean(data?.needsSetup);
  } catch (error) {
    state.needsSetup = false;
  }
  applySetupState();
}

loginForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  const formData = new FormData(loginForm);
  const payload = {
    email: formData.get('email'),
    password: formData.get('password'),
  };
  const rememberCredentials = loginRememberCheckbox?.checked ?? false;

  setStatusMessage(loginStatus, 'info', 'Verificando credenciales...');

  try {
    const data = await request('/auth/login', { method: 'POST', body: payload, requireAuth: false });
    state.token = data.token;
    state.user = data.user;
    state.needsSetup = false;
    applySetupState();
    persistSession();
    persistRememberedCredentials(payload.email, payload.password, rememberCredentials);
    applyInitialSectionFromLocation();
    if (!state.activeSection) {
      state.activeSection = 'section-dashboard';
    }
    shouldReplaceHistoryOnNextSection = true;
    updateAuthUI();
    setStatusMessage(loginStatus, 'success', 'Sesión iniciada.');
    await loadAllData();
    loginForm.reset();
    loadRememberedCredentials();
  } catch (error) {
    setStatusMessage(loginStatus, 'error', error.message);
  }
});

toggleMembershipField(registerIsMemberCheckbox, registerMembershipWrapper, registerMembershipNumberInput, {
  clearWhenDisabled: true,
});
toggleMembershipField(profileIsMemberCheckbox, profileMembershipWrapper, profileMembershipNumberInput, {
  clearWhenDisabled: true,
});

registerIsMemberCheckbox?.addEventListener('change', () => {
  toggleMembershipField(registerIsMemberCheckbox, registerMembershipWrapper, registerMembershipNumberInput, {
    clearWhenDisabled: true,
  });
});

profileIsMemberCheckbox?.addEventListener('change', () => {
  toggleMembershipField(profileIsMemberCheckbox, profileMembershipWrapper, profileMembershipNumberInput, {
    clearWhenDisabled: true,
  });
});

accountDashboardRefresh?.addEventListener('click', () => {
  loadAccountSummary({ force: true });
});

registerForm.addEventListener('submit', async (event) => {
  event.preventDefault();
  const formData = new FormData(registerForm);
  const payload = {
    fullName: formData.get('fullName'),
    email: formData.get('email'),
    password: formData.get('password'),
    gender: formData.get('gender'),
    birthDate: formData.get('birthDate'),
    phone: formData.get('phone'),
    preferredSchedule: formData.get('preferredSchedule'),
    notes: formData.get('notes') || undefined,
  };

  const shirtSizeRaw = (formData.get('shirtSize') || '').trim().toUpperCase();
  if (!shirtSizeRaw) {
    setStatusMessage(registerStatus, 'error', 'Selecciona tu talla de camiseta para completar el registro.');
    return;
  }
  payload.shirtSize = shirtSizeRaw;

  const registerIsMember = formData.has('isMember');
  payload.isMember = registerIsMember;
  const registerMembershipNumber = (formData.get('membershipNumber') || '').trim();
  if (registerIsMember) {
    if (!registerMembershipNumber) {
      setStatusMessage(registerStatus, 'error', 'Indica tu número de socio para completar el registro.');
      return;
    }
    payload.membershipNumber = registerMembershipNumber;
  }

  const roleInputs = Array.from(registerForm.querySelectorAll('input[name="roles"]'));
  const selectedRoles = roleInputs
    .filter((input) => input.checked)
    .map((input) => (typeof input.value === 'string' ? input.value.toLowerCase() : ''))
    .filter(Boolean);
  if (!selectedRoles.length) {
    selectedRoles.push('player');
  }
  if (state.needsSetup && !selectedRoles.includes('admin')) {
    selectedRoles.push('admin');
  }
  let normalizedRoles = Array.from(new Set(selectedRoles));
  if (normalizedRoles.includes('admin')) {
    normalizedRoles = normalizedRoles.filter((role) => role !== 'player');
  } else if (!normalizedRoles.includes('player')) {
    normalizedRoles.push('player');
  }
  if (!normalizedRoles.length) {
    normalizedRoles = ['player'];
  }
  payload.roles = normalizedRoles;

  setStatusMessage(registerStatus, 'info', 'Creando la cuenta...');

  try {
    const photoData = await extractPhotoFromForm(registerForm);
    if (photoData) {
      payload.photo = photoData;
    }
    const data = await request('/auth/register', { method: 'POST', body: payload, requireAuth: false });
    state.token = data.token;
    state.user = data.user;
    state.needsSetup = !data.setupCompleted;
    applySetupState();
    persistSession();
    applyInitialSectionFromLocation();
    if (!state.activeSection) {
      state.activeSection = 'section-dashboard';
    }
    shouldReplaceHistoryOnNextSection = true;
    updateAuthUI();
    await loadAllData();
    registerForm.reset();
    toggleMembershipField(registerIsMemberCheckbox, registerMembershipWrapper, registerMembershipNumberInput, {
      clearWhenDisabled: true,
    });
    setStatusMessage(registerStatus, 'success', 'Cuenta creada correctamente.');
  } catch (error) {
    setStatusMessage(registerStatus, 'error', error.message);
  }
});

profileEditButton?.addEventListener('click', () => {
  toggleProfileForm(true);
  profileForm?.scrollIntoView({ behavior: 'smooth', block: 'start' });
});

profileCancelButton?.addEventListener('click', () => {
  toggleProfileForm(false);
});

courtReservationForm?.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!state.token) {
    setStatusMessage(courtReservationStatus, 'error', 'Debes iniciar sesión para reservar una pista.');
    return;
  }

  const dateValue = courtReservationDateInput?.value || '';
  const timeValue = courtReservationTimeInput?.value || '';
  const startsAt = combineDateAndTime(dateValue, timeValue);
  if (!startsAt) {
    setStatusMessage(courtReservationStatus, 'error', 'Selecciona una fecha y hora válidas.');
    return;
  }

  if (!isValidReservationSlotStart(startsAt)) {
    setStatusMessage(
      courtReservationStatus,
      'error',
      'Selecciona un horario válido de 75 minutos entre las 08:30 y las 22:15.'
    );
    return;
  }

  const courtValue = courtReservationCourtSelect?.value || '';
  if (!courtValue) {
    setStatusMessage(courtReservationStatus, 'error', 'Selecciona una pista disponible.');
    return;
  }

  const durationValue = Number(courtReservationDurationSelect?.value || COURT_RESERVATION_DEFAULT_DURATION);
  const duration = Number.isFinite(durationValue) && durationValue > 0 ? durationValue : COURT_RESERVATION_DEFAULT_DURATION;
  const notes = courtReservationNotesInput?.value?.trim();

  const payload = {
    court: courtValue,
    startsAt: startsAt.toISOString(),
    durationMinutes: duration,
  };

  if (notes) {
    payload.notes = notes;
  }

  setStatusMessage(courtReservationStatus, 'info', 'Creando reserva...');
  if (courtReservationSubmit) {
    courtReservationSubmit.disabled = true;
  }

  try {
    await request('/courts/reservations', { method: 'POST', body: payload });
    setStatusMessage(courtReservationStatus, 'success', 'Reserva creada correctamente.');
    resetCourtReservationForm();
    await loadPlayerCourtData();
    if (isAdmin()) {
      await loadAdminCourtData();
    }
  } catch (error) {
    setStatusMessage(courtReservationStatus, 'error', error.message);
  } finally {
    if (courtReservationSubmit) {
      courtReservationSubmit.disabled = false;
    }
  }
});

courtReservationDateInput?.addEventListener('change', (event) => {
  const value = event.target.value;
  if (value) {
    populateCourtReservationTimeOptions(value);
  } else {
    populateCourtReservationTimeOptions(new Date());
  }
});

courtReservationList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button[data-action="cancel-reservation"]');
  if (!button) {
    return;
  }

  const { reservationId } = button.dataset;
  if (!reservationId) {
    return;
  }

  await cancelCourtReservation(reservationId, { button });
});

courtAvailabilityDateInput?.addEventListener('change', async (event) => {
  const value = event.target.value;
  if (!value) {
    state.courtAvailabilityDate = new Date();
    state.courtAvailabilityDate.setHours(0, 0, 0, 0);
  } else {
    const nextDate = new Date(`${value}T00:00:00`);
    if (Number.isNaN(nextDate.getTime())) {
      return;
    }
    state.courtAvailabilityDate = nextDate;
  }
  await refreshCourtAvailability('player');
});

courtAdminDateInput?.addEventListener('change', async (event) => {
  const value = event.target.value;
  if (!value) {
    state.courtAdminDate = new Date();
    state.courtAdminDate.setHours(0, 0, 0, 0);
  } else {
    const nextDate = new Date(`${value}T00:00:00`);
    if (Number.isNaN(nextDate.getTime())) {
      return;
    }
    state.courtAdminDate = nextDate;
  }
  await refreshCourtAvailability('admin');
});

courtAdminSchedule?.addEventListener('click', async (event) => {
  const cancelButton = event.target.closest('button[data-action="cancel-reservation"]');
  if (cancelButton) {
    const { reservationId } = cancelButton.dataset;
    if (reservationId) {
      await cancelCourtReservation(reservationId, { button: cancelButton });
    }
    return;
  }

  const blockButton = event.target.closest('button[data-action="delete-block"]');
  if (blockButton) {
    const { blockId } = blockButton.dataset;
    if (blockId) {
      await deleteCourtBlock(blockId, { button: blockButton });
    }
  }
});

courtBlocksList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button[data-action="delete-block"]');
  if (!button) {
    return;
  }

  const { blockId } = button.dataset;
  if (!blockId) {
    return;
  }

  await deleteCourtBlock(blockId, { button });
});

courtCalendarViewButtons?.forEach((button) => {
  button.addEventListener('click', () => {
    const view = button.dataset.courtCalendarView;
    if (!view) {
      return;
    }
    setCourtCalendarViewMode(view);
  });
});

playerCourtCalendarPrev?.addEventListener('click', async () => {
  const reference =
    state.courtAvailabilityDate instanceof Date
      ? state.courtAvailabilityDate
      : new Date();
  const base = startOfDay(reference);
  state.courtAvailabilityDate = addDays(base, -1);
  await refreshCourtAvailability('player');
});

playerCourtCalendarNext?.addEventListener('click', async () => {
  const reference =
    state.courtAvailabilityDate instanceof Date
      ? state.courtAvailabilityDate
      : new Date();
  const base = startOfDay(reference);
  state.courtAvailabilityDate = addDays(base, 1);
  await refreshCourtAvailability('player');
});

playerCourtCalendarDateInput?.addEventListener('change', async (event) => {
  const { value } = event.target;
  const nextDate = value ? new Date(`${value}T00:00:00`) : null;
  if (!nextDate || Number.isNaN(nextDate.getTime())) {
    return;
  }
  state.courtAvailabilityDate = startOfDay(nextDate);
  await refreshCourtAvailability('player');
});

courtCalendarPrev?.addEventListener('click', async () => {
  const reference = state.courtCalendarDate instanceof Date ? state.courtCalendarDate : new Date();
  const base = startOfDay(reference);
  state.courtCalendarDate =
    state.courtCalendarViewMode === 'day' ? addDays(base, -1) : startOfDay(addMonths(base, -1));
  await loadCourtCalendarData();
});

courtCalendarNext?.addEventListener('click', async () => {
  const reference = state.courtCalendarDate instanceof Date ? state.courtCalendarDate : new Date();
  const base = startOfDay(reference);
  state.courtCalendarDate =
    state.courtCalendarViewMode === 'day' ? addDays(base, 1) : startOfDay(addMonths(base, 1));
  await loadCourtCalendarData();
});

courtCalendarContainer?.addEventListener('click', (event) => {
  if (state.courtCalendarViewMode === 'day') {
    return;
  }
  if (event.target.closest('.calendar-event')) {
    return;
  }

  const day = event.target.closest('[data-calendar-date]');
  if (!day) {
    return;
  }

  const { calendarDate } = day.dataset;
  if (!calendarDate) {
    return;
  }

  handleCourtCalendarDaySelection(calendarDate).catch(() => {});
});

courtCalendarContainer?.addEventListener('keydown', (event) => {
  if (state.courtCalendarViewMode === 'day') {
    return;
  }
  if (event.target.closest('.calendar-event')) {
    return;
  }

  if (event.key !== 'Enter' && event.key !== ' ') {
    return;
  }

  const day = event.target.closest('[data-calendar-date]');
  if (!day) {
    return;
  }

  event.preventDefault();
  const { calendarDate } = day.dataset;
  if (!calendarDate) {
    return;
  }
  handleCourtCalendarDaySelection(calendarDate).catch(() => {});
});

courtBlockContextSelect?.addEventListener('change', () => {
  populateCourtBlockEntities();
});

courtBlockForm?.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!hasCourtManagementAccess()) {
    showGlobalMessage('No tienes permisos para crear bloqueos de pistas.', 'error');
    return;
  }

  const formData = new FormData(courtBlockForm);
  const payload = {
    contextType: formData.get('contextType'),
    contextId: formData.get('contextId'),
    startsAt: formData.get('startsAt'),
    endsAt: formData.get('endsAt'),
  };

  const notesValue = (formData.get('notes') || '').toString().trim();
  if (notesValue) {
    payload.notes = notesValue;
  }

  if (!payload.contextType || !payload.contextId) {
    setStatusMessage(courtBlockStatus, 'error', 'Selecciona la competición asociada al bloqueo.');
    return;
  }

  if (!payload.startsAt || !payload.endsAt) {
    setStatusMessage(courtBlockStatus, 'error', 'Debes indicar la fecha de inicio y fin del bloqueo.');
    return;
  }

  const courts = formData.getAll('courts').filter((value) => typeof value === 'string' && value.trim().length);
  if (courts.length) {
    payload.courts = courts;
  }

  if (courtBlockStatus) {
    setStatusMessage(courtBlockStatus, 'info', 'Guardando bloqueo de pistas...');
  }
  if (courtBlockSubmit) {
    courtBlockSubmit.disabled = true;
  }

  try {
    await request('/courts/blocks', { method: 'POST', body: payload });
    setStatusMessage(courtBlockStatus, 'success', 'Bloqueo registrado correctamente.');

    const baseDate = payload.startsAt ? new Date(payload.startsAt) : state.courtAdminDate;
    courtBlockForm.reset();
    if (courtBlockContextSelect) {
      courtBlockContextSelect.value = payload.contextType || 'league';
    }
    populateCourtBlockEntities();
    if (courtBlockEntitySelect && payload.contextId) {
      courtBlockEntitySelect.value = payload.contextId;
    }
    populateCourtBlockCourts();
    if (baseDate) {
      setCourtBlockDefaultRange(baseDate);
    } else {
      setCourtBlockDefaultRange();
    }

    await Promise.all([loadAdminCourtData(), loadCourtCalendarData()]);
  } catch (error) {
    setStatusMessage(courtBlockStatus, 'error', error.message);
  } finally {
    if (courtBlockSubmit) {
      courtBlockSubmit.disabled = false;
    }
  }
});

profileForm?.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!state.user) return;

  const formData = new FormData(profileForm);
  const payload = {
    fullName: (formData.get('fullName') || '').trim(),
    email: (formData.get('email') || '').trim(),
    phone: (formData.get('phone') || '').trim(),
    preferredSchedule: formData.get('preferredSchedule'),
    gender: formData.get('gender'),
    birthDate: formData.get('birthDate'),
    notifyMatchRequests: formData.has('notifyMatchRequests'),
    notifyMatchResults: formData.has('notifyMatchResults'),
  };

  const shirtSizeRaw = (formData.get('shirtSize') || '').trim().toUpperCase();
  if (!shirtSizeRaw) {
    setStatusMessage(profileStatus, 'error', 'Selecciona tu talla de camiseta para continuar.');
    return;
  }
  payload.shirtSize = shirtSizeRaw;

  const isMember = formData.has('isMember');
  payload.isMember = isMember;
  const membershipNumberRaw = (formData.get('membershipNumber') || '').trim();
  if (isMember) {
    if (!membershipNumberRaw) {
      setStatusMessage(profileStatus, 'error', 'Indica tu número de socio para continuar.');
      return;
    }
    payload.membershipNumber = membershipNumberRaw;
  } else {
    payload.membershipNumber = '';
  }

  const notesRaw = (formData.get('notes') || '').trim();
  payload.notes = notesRaw;

  const password = formData.get('password');
  if (password) {
    payload.password = password;
  }

  setStatusMessage(profileStatus, 'info', 'Guardando cambios...');

  try {
    const photoData = await extractPhotoFromForm(profileForm);
    if (photoData) {
      payload.photo = photoData;
    }
    const data = await request('/auth/me', { method: 'PATCH', body: payload });
    state.user = data.user;
    persistSession();
    updateProfileCard();
    showGlobalMessage('Perfil actualizado correctamente.');
    toggleProfileForm(false);
  } catch (error) {
    setStatusMessage(profileStatus, 'error', error.message);
  }
});

rankingPrintButton?.addEventListener('click', () => {
  openRankingPrintModal();
});

rankingLeagueFilter?.addEventListener('change', () => {
  const filters = ensureRankingFilters();
  filters.league = rankingLeagueFilter.value;
  renderRankingSections();
});

calendarPrev?.addEventListener('click', () => {
  shiftCalendar(-1);
});

calendarNext?.addEventListener('click', () => {
  shiftCalendar(1);
});

globalCalendarPrev?.addEventListener('click', () => {
  shiftGlobalCalendar(-1);
});

globalCalendarNext?.addEventListener('click', () => {
  shiftGlobalCalendar(1);
});

if (globalCalendarViewButtons.length) {
  setCalendarViewButtonState(globalCalendarViewButtons, state.globalCalendarViewMode);
  globalCalendarViewButtons.forEach((button) => {
    button.addEventListener('click', () => {
      const { globalCalendarView } = button.dataset;
      if (!globalCalendarView || state.globalCalendarViewMode === globalCalendarView) {
        return;
      }
      state.globalCalendarViewMode = globalCalendarView;
      if (globalCalendarView === 'day') {
        state.globalCalendarDate = startOfDay(new Date());
      } else {
        state.globalCalendarDate = startOfMonth(new Date(state.globalCalendarDate));
      }
      setCalendarViewButtonState(globalCalendarViewButtons, state.globalCalendarViewMode);
      renderGlobalCalendar();
    });
  });
}

clubEditButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  openClubModal();
});

leagueRulesEditButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  openRulesEditorModal('league');
});

tournamentRulesEditButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  openRulesEditorModal('tournament');
});

generalChatToolbar?.addEventListener('click', handleNoticeToolbarClick);

generalChatAttachmentInput?.addEventListener('change', handleNoticeAttachmentChange);

generalChatImageInput?.addEventListener('change', handleNoticeImageSelection);

generalChatAttachmentsList?.addEventListener('click', (event) => {
  const button = event.target.closest('[data-attachment-remove]');
  if (!button) return;
  removeNoticeAttachment(button.dataset.attachmentRemove);
});

generalChatForm?.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!isAdmin()) return;

  const rawHtml = generalChatEditor ? generalChatEditor.innerHTML : '';
  const sanitizedRich = sanitizeNoticeHtml(rawHtml);
  const plainText = extractPlainTextFromHtml(sanitizedRich);
  const inlineImageSources = extractInlineImageSources(sanitizedRich);

  let inlineImagesTotalSize = 0;
  for (const source of inlineImageSources) {
    if (!NOTICE_INLINE_IMAGE_DATA_URL_PATTERN.test(source)) {
      continue;
    }
    const estimatedSize = estimateDataUrlPayloadSize(source);
    if (estimatedSize > MAX_INLINE_NOTICE_IMAGE_SIZE) {
      showGlobalMessage(
        `Cada imagen insertada debe pesar menos de ${formatFileSize(MAX_INLINE_NOTICE_IMAGE_SIZE)}.`,
        'error'
      );
      return;
    }
    inlineImagesTotalSize += estimatedSize;
  }

  if (inlineImagesTotalSize > MAX_TOTAL_INLINE_NOTICE_IMAGE_SIZE) {
    showGlobalMessage(
      `Las imágenes insertadas superan el peso máximo total permitido (${formatFileSize(
        MAX_TOTAL_INLINE_NOTICE_IMAGE_SIZE
      )}).`,
      'error'
    );
    return;
  }

  if (!plainText && !sanitizedRich && !noticeDraftAttachments.length) {
    showGlobalMessage('Escribe un mensaje o añade un adjunto antes de publicar.', 'error');
    generalChatEditor?.focus();
    return;
  }

  if (plainText.length > 2000) {
    showGlobalMessage('El aviso supera el límite de 2000 caracteres.', 'error');
    return;
  }

  if (!inlineImageSources.length && sanitizedRich.length > MAX_NOTICE_RICH_CONTENT_LENGTH) {
    showGlobalMessage(
      `El contenido enriquecido es demasiado largo (máximo ${MAX_NOTICE_RICH_CONTENT_LENGTH.toLocaleString('es-ES')} caracteres).`,
      'error'
    );
    return;
  }

  if (inlineImageSources.length && sanitizedRich.length > MAX_NOTICE_RICH_CONTENT_WITH_IMAGES) {
    showGlobalMessage(
      'El aviso supera el tamaño máximo permitido para contenido con imágenes. Reduce el peso de las imágenes e inténtalo de nuevo.',
      'error'
    );
    return;
  }

  if (generalChatInput) {
    generalChatInput.value = plainText;
  }

  const attachmentsPayload = noticeDraftAttachments.map((attachment) => ({
    filename: attachment.name,
    contentType: attachment.contentType,
    size: attachment.size,
    dataUrl: attachment.dataUrl,
    type: attachment.type,
  }));

  const payload = {
    content: plainText,
    richContent: sanitizedRich || undefined,
    attachments: attachmentsPayload,
  };

  setNoticeFormBusy(true);

  try {
    await request('/chat/general', { method: 'POST', body: payload });
    resetNoticeComposer();
    await loadGeneralChat();
  } catch (error) {
    showGlobalMessage(error.message, 'error');
  } finally {
    setNoticeFormBusy(false);
  }
});

pushEnableButton?.addEventListener('click', () => {
  enablePushNotifications();
});

pushDisableButton?.addEventListener('click', () => {
  disablePushNotifications();
});

logoutButtons.forEach((button) => {
  button.addEventListener('click', () => {
    closeMobileMenu();
    state.token = null;
    state.user = null;
    state.leagues = [];
    state.selectedLeagueId = '';
    state.categories = [];
    state.categoriesLoaded = false;
    state.players = [];
    state.selectedCategoryId = null;
    state.rankingsByCategory.clear();
    state.rankingsLoading = false;
    state.notifications = [];
    state.notificationBase = null;
    state.pendingEnrollmentRequestCount = 0;
    state.calendarDate = new Date();
    state.globalCalendarDate = new Date();
    state.globalCalendarViewMode = 'month';
    state.matchPagination = { upcoming: {}, pending: {}, completed: {} };
    renderLeagues([]);
    clearSession();
    updateNotificationCounts([]);
    updateAuthUI();
    showGlobalMessage('Sesión cerrada correctamente.');
    checkSetupStatus();
  });
});

tournamentsList?.addEventListener('click', async (event) => {
  const button = event.target.closest('.list-item-button[data-tournament-id]');
  if (!button) return;

  const tournamentId = normalizeId(button.dataset.tournamentId);
  const previous = state.selectedTournamentId;
  state.selectedTournamentId = tournamentId;

  if (!state.selectedTournamentCategoriesId || state.selectedTournamentCategoriesId === previous) {
    state.selectedTournamentCategoriesId = tournamentId;
  }

  if (!state.selectedEnrollmentTournamentId || state.selectedEnrollmentTournamentId === previous) {
    state.selectedEnrollmentTournamentId = tournamentId;
    state.selectedEnrollmentCategoryId = '';
    clearTournamentEnrollmentFilters();
  }

  if (!state.selectedMatchTournamentId || state.selectedMatchTournamentId === previous) {
    state.selectedMatchTournamentId = tournamentId;
    state.selectedMatchCategoryId = '';
  }

  if (!state.selectedDoublesTournamentId || state.selectedDoublesTournamentId === previous) {
    state.selectedDoublesTournamentId = tournamentId;
  }

  updateTournamentSelectors();
  if (tournamentId) {
    await refreshTournamentDetail(tournamentId);
    if (state.activeSection === 'section-tournament-doubles') {
      await refreshTournamentDoubles();
    }
  }
});

tournamentCategoryTournamentSelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  state.selectedTournamentCategoriesId = value;
  if (value && !state.tournamentDetails.has(value)) {
    renderTournamentCategories({ loading: true });
    await refreshTournamentDetail(value);
  } else {
    renderTournamentCategories();
  }
});

tournamentCategoriesList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button[data-tournament-category-action]');
  if (!button || !isAdmin()) return;

  const { tournamentCategoryAction: action, tournamentId, categoryId } = button.dataset;
  const normalizedCategoryId = normalizeId(categoryId);
  const normalizedTournamentId = normalizeId(tournamentId) || state.selectedTournamentCategoriesId;

  if (!normalizedCategoryId) {
    return;
  }

  if (action === 'edit') {
    openTournamentCategoryModal({
      tournamentId: normalizedTournamentId,
      categoryId: normalizedCategoryId,
    });
    return;
  }

  if (action === 'enrollments') {
    if (!normalizedTournamentId) {
      showGlobalMessage('Selecciona un torneo para gestionar sus inscripciones.', 'error');
      return;
    }
    openTournamentCategoryEnrollmentModal(normalizedTournamentId, normalizedCategoryId);
    return;
  }

  if (action === 'delete') {
    if (!normalizedTournamentId) {
      return;
    }
    const confirmed = window.confirm('¿Seguro que deseas eliminar esta categoría?');
    if (!confirmed) return;

    button.disabled = true;
    try {
      await request(`/tournaments/${normalizedTournamentId}/categories/${normalizedCategoryId}`, {
        method: 'DELETE',
      });
      await reloadTournaments({ selectTournamentId: normalizedTournamentId });
      state.tournamentDetails.delete(normalizedTournamentId);
      await refreshTournamentDetail(normalizedTournamentId);
      showGlobalMessage('Categoría de torneo eliminada correctamente.');
    } catch (error) {
      showGlobalMessage(error.message || 'No fue posible eliminar la categoría.', 'error');
    } finally {
      button.disabled = false;
    }
  }
});

tournamentEnrollmentTournamentSelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  state.selectedEnrollmentTournamentId = value;
  state.selectedEnrollmentCategoryId = '';
  clearTournamentEnrollmentFilters();
  updateEnrollmentCategoryOptions();
  if (value && !state.tournamentDetails.has(value)) {
    await refreshTournamentDetail(value);
  }
  updateTournamentActionAvailability();
});

tournamentDoublesTournamentSelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  state.selectedDoublesTournamentId = value;

  if (!value) {
    renderTournamentDoubles();
    updateTournamentActionAvailability();
    return;
  }

  if (!state.tournamentDetails.has(value)) {
    await refreshTournamentDetail(value);
  }

  await refreshTournamentDoubles();
  updateTournamentActionAvailability();
});

tournamentDoublesContainer?.addEventListener('submit', async (event) => {
  const form = event.target.closest('form.doubles-pair-form');
  if (!form || !isAdmin()) {
    return;
  }

  event.preventDefault();

  const { categoryId } = form.dataset;
  const playerA = form.elements.playerA?.value || '';
  const playerB = form.elements.playerB?.value || '';
  const tournamentId = state.selectedDoublesTournamentId || '';

  if (!tournamentId || !categoryId) {
    showGlobalMessage('Selecciona un torneo antes de crear parejas.', 'error');
    return;
  }

  if (!playerA || !playerB) {
    showGlobalMessage('Selecciona dos jugadores para crear la pareja.', 'error');
    return;
  }

  if (playerA === playerB) {
    showGlobalMessage('Los jugadores deben ser distintos.', 'error');
    return;
  }

  const submitButton = form.querySelector('button[type="submit"]');
  if (submitButton) {
    submitButton.disabled = true;
  }

  try {
    await request(
      `/tournaments/${tournamentId}/categories/${categoryId}/doubles-pairs`,
      {
        method: 'POST',
        body: { players: [playerA, playerB] },
      }
    );
    state.tournamentDoublesPairs.delete(
      getTournamentDoublesPairCacheKey(tournamentId, categoryId)
    );
    form.reset();
    showGlobalMessage('Pareja creada correctamente.', 'success');
    await refreshTournamentDoubles({ force: true });
  } catch (error) {
    showGlobalMessage(error.message || 'No fue posible crear la pareja.', 'error');
  } finally {
    if (submitButton) {
      submitButton.disabled = false;
    }
  }
});

tournamentDoublesContainer?.addEventListener('click', async (event) => {
  const button = event.target.closest('button[data-action="delete-pair"]');
  if (!button || !isAdmin()) {
    return;
  }

  const { pairId, categoryId } = button.dataset;
  const tournamentId = state.selectedDoublesTournamentId || '';

  if (!pairId || !categoryId || !tournamentId) {
    return;
  }

  const confirmed = window.confirm('¿Seguro que deseas eliminar esta pareja?');
  if (!confirmed) {
    return;
  }

  button.disabled = true;
  try {
    await request(
      `/tournaments/${tournamentId}/categories/${categoryId}/doubles-pairs/${pairId}`,
      { method: 'DELETE' }
    );
    state.tournamentDoublesPairs.delete(
      getTournamentDoublesPairCacheKey(tournamentId, categoryId)
    );
    showGlobalMessage('Pareja eliminada correctamente.', 'success');
    await refreshTournamentDoubles({ force: true });
  } catch (error) {
    showGlobalMessage(error.message || 'No fue posible eliminar la pareja.', 'error');
  } finally {
    button.disabled = false;
  }
});

tournamentEnrollmentCategorySelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  state.selectedEnrollmentCategoryId = value;
  clearTournamentEnrollmentFilters();
  if (value) {
    await refreshTournamentEnrollments();
  } else {
    renderTournamentEnrollments([], { loading: false });
  }
  updateTournamentActionAvailability();
});

tournamentEnrollmentSearch?.addEventListener('input', (event) => {
  const filters = ensureTournamentEnrollmentFilters();
  filters.search = (event.target.value || '').trim();
  const cacheKey = getTournamentEnrollmentCacheKey(
    state.selectedEnrollmentTournamentId,
    state.selectedEnrollmentCategoryId
  );
  if (!cacheKey || !state.tournamentEnrollments.has(cacheKey)) {
    return;
  }
  renderTournamentEnrollments(state.tournamentEnrollments.get(cacheKey) || []);
});

tournamentEnrollmentGender?.addEventListener('change', (event) => {
  const filters = ensureTournamentEnrollmentFilters();
  filters.gender = event.target.value || '';
  const cacheKey = getTournamentEnrollmentCacheKey(
    state.selectedEnrollmentTournamentId,
    state.selectedEnrollmentCategoryId
  );
  if (!cacheKey || !state.tournamentEnrollments.has(cacheKey)) {
    return;
  }
  renderTournamentEnrollments(state.tournamentEnrollments.get(cacheKey) || []);
});

tournamentDetailBody?.addEventListener('click', (event) => {
  const button = event.target.closest('button[data-tournament-action]');
  if (!button) return;

  const { tournamentAction, tournamentId, categoryId } = button.dataset;
  if (tournamentAction === 'open-enrollment') {
    openTournamentSelfEnrollmentModal({
      tournamentId: tournamentId || state.selectedTournamentId,
      allowMultiple: true,
    });
    return;
  }

  if (tournamentAction === 'request-enrollment') {
    openTournamentSelfEnrollmentModal({
      tournamentId: tournamentId || state.selectedTournamentId,
      categoryId: categoryId || '',
    });
  }
});

tournamentAdminEnrollButton?.addEventListener('click', () => {
  const targetTournamentId =
    tournamentAdminEnrollButton.dataset.tournamentId || state.selectedTournamentId;
  openTournamentAdminEnrollmentModal({ tournamentId: targetTournamentId });
});

tournamentMatchTournamentSelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  state.selectedMatchTournamentId = value;
  state.selectedMatchCategoryId = '';
  state.selectedOrderOfPlayDay = '';
  updateMatchCategoryOptions();
  if (value && !state.tournamentDetails.has(value)) {
    await refreshTournamentDetail(value);
  }
  updateTournamentActionAvailability();
});

tournamentMatchCategorySelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  state.selectedMatchCategoryId = value;
  if (value) {
    await refreshTournamentMatches();
  } else {
    renderTournamentMatches([], { loading: false });
  }
  updateTournamentActionAvailability();
});

tournamentOrderDayInput?.addEventListener('change', (event) => {
  state.selectedOrderOfPlayDay = (event.target.value || '').trim();
  updateTournamentActionAvailability();
});

tournamentOrderDownloadButton?.addEventListener('click', async () => {
  const tournamentId = state.selectedMatchTournamentId || '';
  const day = state.selectedOrderOfPlayDay || '';

  if (!tournamentId || !day) {
    return;
  }

  const previousLabel = tournamentOrderDownloadButton.textContent;
  tournamentOrderDownloadButton.disabled = true;
  tournamentOrderDownloadButton.textContent = 'Generando PDF...';

  try {
    const params = new URLSearchParams({ day });
    const headers = new Headers({ Accept: 'application/pdf' });
    if (state.token) {
      headers.set('Authorization', `Bearer ${state.token}`);
    }

    let response;
    try {
      response = await fetch(
        `${API_BASE}/tournaments/${tournamentId}/order-of-play?${params.toString()}`,
        { headers }
      );
    } catch (error) {
      throw new Error('No fue posible conectar con el servidor.');
    }

    if (!response.ok) {
      let message = 'No fue posible generar el PDF del orden de juego.';
      const contentType = response.headers.get('content-type') || '';
      if (contentType.includes('application/json')) {
        try {
          const data = await response.json();
          message = data?.message || message;
        } catch (parseError) {
          // Ignorar errores al parsear la respuesta.
        }
      }
      if (response.status === 401) {
        clearSession();
        state.token = null;
        state.user = null;
        updateAuthUI();
      }
      throw new Error(message);
    }

    const blob = await response.blob();
    const downloadUrl = URL.createObjectURL(blob);
    const anchor = document.createElement('a');
    anchor.href = downloadUrl;
    const safeDay = day.replace(/[^0-9-]/g, '');
    anchor.download = `orden-juego-${safeDay || 'torneo'}.pdf`;
    document.body.appendChild(anchor);
    anchor.click();
    anchor.remove();
    URL.revokeObjectURL(downloadUrl);
    showGlobalMessage('Orden de juego descargado correctamente.', 'success');
  } catch (error) {
    const message = error instanceof Error ? error.message : String(error);
    showGlobalMessage(message || 'No fue posible generar el PDF del orden de juego.', 'error');
  } finally {
    tournamentOrderDownloadButton.textContent = previousLabel;
    updateTournamentActionAvailability();
  }
});

tournamentBracketTournamentSelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  state.selectedBracketTournamentId = value;
  state.selectedBracketCategoryId = '';
  state.tournamentBracketSeedsDirty = false;
  setStatusMessage(tournamentBracketStatus, '', '');
  if (value && !state.tournamentDetails.has(value)) {
    try {
      await refreshTournamentDetail(value);
    } catch (error) {
      setStatusMessage(tournamentBracketStatus, 'error', error.message);
    }
  }
  updateBracketCategoryOptions();
  updateTournamentActionAvailability();
});

tournamentBracketFullscreenButton?.addEventListener('click', () => {
  toggleBracketCardFullscreen(tournamentBracketViewCard, tournamentBracketFullscreenButton);
});

tournamentConsolationFullscreenButton?.addEventListener('click', () => {
  toggleBracketCardFullscreen(
    tournamentConsolationViewCard,
    tournamentConsolationFullscreenButton
  );
});

document.addEventListener('fullscreenchange', () => {
  syncBracketFullscreenState();
});

document.addEventListener('fullscreenerror', () => {
  syncBracketFullscreenState();
});

document.addEventListener('keydown', (event) => {
  if (event.key !== 'Escape') {
    return;
  }
  if (
    !isFallbackBracketFullscreen(tournamentBracketViewCard) &&
    !isFallbackBracketFullscreen(tournamentConsolationViewCard)
  ) {
    return;
  }
  clearFallbackBracketFullscreen(tournamentBracketViewCard, tournamentBracketFullscreenButton);
  clearFallbackBracketFullscreen(
    tournamentConsolationViewCard,
    tournamentConsolationFullscreenButton
  );
  syncBracketFullscreenState();
});

tournamentBracketCategorySelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  state.selectedBracketCategoryId = value;
  state.tournamentBracketSeedsDirty = false;
  setStatusMessage(tournamentBracketStatus, '', '');
  if (value) {
    await loadTournamentBracketContext({
      tournamentId: state.selectedBracketTournamentId,
      categoryId: value,
      forceMatches: true,
    });
  } else {
    renderTournamentBracketSeeds();
    renderTournamentBracket([], { loading: false });
  }
  updateTournamentActionAvailability();
});

tournamentBracketSizeSelect?.addEventListener('change', async () => {
  const tournamentId = state.selectedBracketTournamentId;
  const categoryId = state.selectedBracketCategoryId;
  if (!tournamentId || !categoryId) {
    return;
  }
  let enrollments = [];
  try {
    enrollments = await fetchTournamentEnrollments(tournamentId, categoryId, {
      forceReload: false,
    });
  } catch (error) {
    setStatusMessage(tournamentBracketStatus, 'error', error.message);
  }
  const category = getTournamentCategoryById(tournamentId, categoryId);
  renderTournamentBracketSeeds({
    tournamentId,
    categoryId,
    enrollments,
    category,
    pairs,
  });
  updateTournamentActionAvailability();
});

tournamentBracketSaveSeedsButton?.addEventListener('click', async () => {
  if (!isAdmin()) {
    return;
  }

  const tournamentId = state.selectedBracketTournamentId;
  const categoryId = state.selectedBracketCategoryId;
  if (!tournamentId || !categoryId) {
    setStatusMessage(
      tournamentBracketStatus,
      'error',
      'Selecciona un torneo y una categoría válidos.'
    );
    return;
  }

  const assignments = collectTournamentSeedAssignments();
  const validationError = validateTournamentSeedAssignments(assignments);
  if (validationError) {
    setStatusMessage(tournamentBracketStatus, 'error', validationError);
    return;
  }

  const success = await persistTournamentBracketSeeds(assignments, { silent: false });
  if (success) {
    await loadTournamentBracketContext({
      tournamentId,
      categoryId,
      forceMatches: false,
    });
  }
  updateTournamentActionAvailability();
});

tournamentBracketPreviewButton?.addEventListener('click', async () => {
  if (!isAdmin()) {
    return;
  }

  const tournamentId = state.selectedBracketTournamentId;
  const categoryId = state.selectedBracketCategoryId;
  if (!tournamentId || !categoryId) {
    setStatusMessage(
      tournamentBracketStatus,
      'error',
      'Selecciona un torneo y una categoría válidos.'
    );
    return;
  }

  const assignments = collectTournamentSeedAssignments();
  const validationError = validateTournamentSeedAssignments(assignments);
  if (validationError) {
    setStatusMessage(tournamentBracketStatus, 'error', validationError);
    return;
  }

  const drawSizeValue = Number(tournamentBracketSizeSelect?.value);

  tournamentBracketPreviewButton.disabled = true;
  setStatusMessage(tournamentBracketStatus, 'info', 'Generando previsualización del cuadro...');

  try {
    const body = {
      previewOnly: true,
      seeds: assignments,
    };

    if (Number.isFinite(drawSizeValue) && drawSizeValue > 0) {
      body.drawSizeOverride = drawSizeValue;
    }

    const response = await request(
      `/tournaments/${tournamentId}/categories/${categoryId}/brackets/auto`,
      {
        method: 'POST',
        body,
      }
    );

    let list = Array.isArray(response) ? response : [];
    list = await hydrateTournamentMatchesWithPairs(list, { tournamentId, categoryId });

    renderTournamentBracket(list, {
      preview: true,
      previewDrawSize: Number.isFinite(drawSizeValue) ? drawSizeValue : undefined,
    });

    setStatusMessage(
      tournamentBracketStatus,
      'success',
      'Mostrando previsualización del cuadro. Genera el cuadro para confirmarlo.'
    );
  } catch (error) {
    setStatusMessage(tournamentBracketStatus, 'error', error.message);
  } finally {
    tournamentBracketPreviewButton.disabled = false;
    updateTournamentActionAvailability();
  }
});

tournamentBracketGenerateButton?.addEventListener('click', async () => {
  if (!isAdmin()) {
    return;
  }

  const tournamentId = state.selectedBracketTournamentId;
  const categoryId = state.selectedBracketCategoryId;
  if (!tournamentId || !categoryId) {
    setStatusMessage(
      tournamentBracketStatus,
      'error',
      'Selecciona un torneo y una categoría válidos.'
    );
    return;
  }

  const cachedMatches = getCachedTournamentBracketMatches(tournamentId, categoryId);
  const hasRecordedResults = bracketMatchesHaveRecordedResults(cachedMatches);

  if (hasRecordedResults || cachedMatches.length) {
    const confirmed = await openConfirmationDialog({
      title: 'Generar nuevo cuadro',
      message: hasRecordedResults
        ? TOURNAMENT_BRACKET_RESULTS_REPLACEMENT_CONFIRMATION
        : TOURNAMENT_BRACKET_REPLACEMENT_CONFIRMATION,
      confirmLabel: 'Generar nuevo cuadro',
      cancelLabel: 'Cancelar',
    });
    if (!confirmed) {
      updateTournamentActionAvailability();
      return;
    }
  }

  const assignments = collectTournamentSeedAssignments();
  const validationError = validateTournamentSeedAssignments(assignments);
  if (validationError) {
    setStatusMessage(tournamentBracketStatus, 'error', validationError);
    return;
  }

  const category = getTournamentCategoryById(tournamentId, categoryId);
  const drawSizeValue = Number(tournamentBracketSizeSelect?.value);
  const currentDrawSize = Number(category?.drawSize);

  tournamentBracketGenerateButton.disabled = true;
  setStatusMessage(tournamentBracketStatus, 'info', 'Generando cuadro automáticamente...');

  try {
    const saved = await persistTournamentBracketSeeds(assignments, { silent: true });
    if (!saved) {
      tournamentBracketGenerateButton.disabled = false;
      updateTournamentActionAvailability();
      return;
    }

    if (drawSizeValue && drawSizeValue !== currentDrawSize) {
      await request(`/tournaments/${tournamentId}/categories/${categoryId}`, {
        method: 'PATCH',
        body: { drawSize: drawSizeValue },
      });
    }

    await request(`/tournaments/${tournamentId}/categories/${categoryId}/brackets/auto`, {
      method: 'POST',
    });

    state.tournamentBracketMatches.delete(
      getTournamentBracketCacheKey(tournamentId, categoryId)
    );

    await refreshTournamentDetail(tournamentId);
    await loadTournamentBracketContext({
      tournamentId,
      categoryId,
      forceMatches: true,
    });

    setStatusMessage(tournamentBracketStatus, 'success', 'Cuadro generado correctamente.');
  } catch (error) {
    setStatusMessage(tournamentBracketStatus, 'error', error.message);
  } finally {
    tournamentBracketGenerateButton.disabled = false;
    updateTournamentActionAvailability();
  }
});

tournamentBracketClearButton?.addEventListener('click', async () => {
  if (!isAdmin()) {
    return;
  }

  const tournamentId = state.selectedBracketTournamentId;
  const categoryId = state.selectedBracketCategoryId;
  if (!tournamentId || !categoryId) {
    setStatusMessage(
      tournamentBracketStatus,
      'error',
      'Selecciona un torneo y una categoría válidos.'
    );
    return;
  }

  const cachedMatches = getCachedTournamentBracketMatches(tournamentId, categoryId);
  if (!cachedMatches.length) {
    setStatusMessage(tournamentBracketStatus, 'error', 'No hay partidos que limpiar en esta categoría.');
    return;
  }

  const confirmed = await openConfirmationDialog({
    title: 'Limpiar cuadro',
    message: 'Se eliminarán todos los partidos generados en esta categoría. ¿Deseas continuar?',
    confirmLabel: 'Limpiar cuadro',
    cancelLabel: 'Cancelar',
  });

  if (!confirmed) {
    updateTournamentActionAvailability();
    return;
  }

  tournamentBracketClearButton.disabled = true;
  setStatusMessage(tournamentBracketStatus, 'info', 'Eliminando cuadro...');

  try {
    await request(`/tournaments/${tournamentId}/categories/${categoryId}/brackets`, {
      method: 'DELETE',
    });

    const cacheKey = getTournamentBracketCacheKey(tournamentId, categoryId);
    if (cacheKey && state.tournamentBracketMatches instanceof Map) {
      state.tournamentBracketMatches.delete(cacheKey);
    }

    await refreshTournamentDetail(tournamentId);
    await loadTournamentBracketContext({ tournamentId, categoryId, forceMatches: true });

    setStatusMessage(tournamentBracketStatus, 'success', 'Cuadro eliminado correctamente.');
  } catch (error) {
    setStatusMessage(tournamentBracketStatus, 'error', error.message);
  } finally {
    tournamentBracketClearButton.disabled = false;
    updateTournamentActionAvailability();
  }
});

tournamentBracketRecalculateButton?.addEventListener('click', async () => {
  if (!isAdmin()) {
    return;
  }

  const tournamentId = state.selectedBracketTournamentId;
  const categoryId = state.selectedBracketCategoryId;
  if (!tournamentId || !categoryId) {
    setStatusMessage(
      tournamentBracketStatus,
      'error',
      'Selecciona un torneo y una categoría válidos.'
    );
    return;
  }

  tournamentBracketRecalculateButton.disabled = true;
  setStatusMessage(tournamentBracketStatus, 'info', 'Recalculando cuadro...');

  try {
    await request(`/tournaments/${tournamentId}/categories/${categoryId}/brackets/recalculate`, {
      method: 'POST',
    });
    state.tournamentBracketMatches.delete(
      getTournamentBracketCacheKey(tournamentId, categoryId)
    );
    await refreshTournamentDetail(tournamentId);
    await loadTournamentBracketContext({
      tournamentId,
      categoryId,
      forceMatches: true,
    });
    setStatusMessage(tournamentBracketStatus, 'success', 'Cuadro actualizado correctamente.');
  } catch (error) {
    setStatusMessage(tournamentBracketStatus, 'error', error.message);
  } finally {
    tournamentBracketRecalculateButton.disabled = false;
    updateTournamentActionAvailability();
  }
});

notificationsList?.addEventListener('click', async (event) => {
  const tournamentButton = event.target.closest('button[data-review-tournament]');
  if (tournamentButton) {
    const { reviewTournament, reviewTournamentCategory } = tournamentButton.dataset;
    if (reviewTournament) {
      const tournamentId = reviewTournament;
      const categoryId = reviewTournamentCategory || '';
      state.selectedTournamentId = tournamentId;
      state.selectedTournamentCategoriesId = tournamentId;
      state.selectedEnrollmentTournamentId = tournamentId;
      state.selectedMatchTournamentId = tournamentId;
      state.selectedEnrollmentCategoryId = categoryId;
      clearTournamentEnrollmentFilters();
      updateTournamentSelectors();
      await refreshTournamentDetail(tournamentId);
      if (categoryId) {
        await refreshTournamentEnrollments({ forceReload: true });
      } else {
        renderTournamentEnrollments([], { loading: false });
      }
      showSection('section-tournament-enrollments');
    }
    return;
  }

  const reviewButton = event.target.closest('button[data-review-category]');
  if (reviewButton) {
    const { reviewCategory } = reviewButton.dataset;
    if (reviewCategory) {
      openEnrollmentModal(reviewCategory, { focusRequests: true });
    }
    return;
  }

  const button = event.target.closest('button[data-notification-id]');
  if (!button) return;
  const { notificationId } = button.dataset;
  if (!notificationId) return;

  button.disabled = true;
  try {
    await request(`/notifications/mine/${notificationId}`, { method: 'DELETE' });
    const notifications = await request('/notifications/mine?upcoming=true').catch(() => []);
    renderNotifications(Array.isArray(notifications) ? notifications : []);
    await loadLeagueDashboard();
    await loadGlobalOverview();
  } catch (error) {
    button.disabled = false;
    showGlobalMessage(error.message, 'error');
  }
});

adminCategoryForm?.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!isAdmin()) return;
  const succeeded = await submitCategoryFormData({
    form: adminCategoryForm,
    categoryId: state.adminCategoryEditingId,
    statusElement: adminStatus,
  });
  if (succeeded) {
    resetAdminCategoryForm();
  }
});

adminEnrollmentCategory?.addEventListener('change', async (event) => {
  const categoryId = event.target.value;
  if (!categoryId) {
    renderEnrollmentList('');
    setStatusMessage(adminEnrollmentStatus, '', '');
    return;
  }

  if (adminEnrollmentList) {
    adminEnrollmentList.innerHTML = '<li class="empty-state">Cargando inscripciones...</li>';
  }
  setStatusMessage(adminEnrollmentStatus, '', '');

  try {
    await loadEnrollments(categoryId);
    renderEnrollmentList(categoryId);
    renderPlayerDirectory();
  } catch (error) {
    state.enrollments.delete(categoryId);
    invalidateLeaguePaymentsByCategory(categoryId);
    if (adminEnrollmentList) {
      adminEnrollmentList.innerHTML =
        '<li class="empty-state">No fue posible cargar las inscripciones.</li>';
    }
    setStatusMessage(adminEnrollmentStatus, 'error', error.message);
  }
});

adminEnrollmentForm?.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!isAdmin()) return;

  const formData = new FormData(adminEnrollmentForm);
  const categoryId = formData.get('categoryId');
  const userId = formData.get('userId');

  if (!categoryId || !userId) {
    setStatusMessage(adminEnrollmentStatus, 'error', 'Selecciona la categoría y el jugador.');
    return;
  }

  setStatusMessage(adminEnrollmentStatus, 'info', 'Inscribiendo jugador...');

  try {
    await request('/categories/enroll', { method: 'POST', body: { categoryId, userId } });
    state.enrollments.delete(categoryId);
    invalidateLeaguePaymentsByCategory(categoryId);
    await loadEnrollments(categoryId);
    state.enrollmentRequests.delete(categoryId);
    await reloadCategories();
    renderEnrollmentList(categoryId);
    setStatusMessage(adminEnrollmentStatus, 'success', 'Jugador inscrito correctamente.');
    if (adminEnrollmentForm.elements.userId) {
      adminEnrollmentForm.elements.userId.value = '';
    }
  } catch (error) {
    setStatusMessage(adminEnrollmentStatus, 'error', error.message);
  }
});

adminEnrollmentList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button[data-enrollment-id]');
  if (!button || !isAdmin()) return;

  const categoryId = button.dataset.categoryId;
  const enrollmentId = button.dataset.enrollmentId;
  if (!categoryId || !enrollmentId) return;

  button.disabled = true;
  setStatusMessage(adminEnrollmentStatus, 'info', 'Eliminando inscripción...');

  try {
    await request(`/categories/${categoryId}/enrollments/${enrollmentId}`, { method: 'DELETE' });
    state.enrollments.delete(categoryId);
    invalidateLeaguePaymentsByCategory(categoryId);
    await loadEnrollments(categoryId);
    state.enrollmentRequests.delete(categoryId);
    await reloadCategories();
    renderEnrollmentList(categoryId);
    setStatusMessage(adminEnrollmentStatus, 'success', 'Inscripción eliminada.');
  } catch (error) {
    setStatusMessage(adminEnrollmentStatus, 'error', error.message);
  } finally {
    button.disabled = false;
  }
});

adminCategoryCancel?.addEventListener('click', () => {
  resetAdminCategoryForm();
  setStatusMessage(adminStatus, '', '');
});

adminCategoryList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button[data-category-id]');
  if (!button || !isAdmin()) return;
  const { categoryId, action } = button.dataset;
  if (!categoryId) return;

  if (action === 'delete') {
    const category = state.categories.find((item) => normalizeId(item) === categoryId);
    const categoryName = category?.name ? `la categoría "${category.name}"` : 'esta categoría';
    const confirmed = window.confirm(
      `¿Seguro que deseas eliminar ${categoryName}? Esta acción eliminará los partidos e inscripciones asociadas.`
    );
    if (!confirmed) return;

    button.disabled = true;
    setStatusMessage(adminStatus, 'info', 'Eliminando categoría...');

    try {
      await request(`/categories/${categoryId}`, { method: 'DELETE' });
      setStatusMessage(adminStatus, 'success', 'Categoría eliminada.');
      if (state.adminCategoryEditingId === categoryId) {
        resetAdminCategoryForm();
      }
      await loadAllData();
    } catch (error) {
      setStatusMessage(adminStatus, 'error', error.message);
    } finally {
      button.disabled = false;
    }

    return;
  }

  setAdminCategoryEditing(categoryId);
});

adminPlayerForm?.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!isAdmin()) return;
  const succeeded = await submitPlayerFormData({
    form: adminPlayerForm,
    playerId: state.adminPlayerEditingId,
    statusElement: adminStatus,
  });
  if (succeeded) {
    resetAdminPlayerForm();
  }
});

adminPlayerCancel?.addEventListener('click', () => {
  resetAdminPlayerForm();
  setStatusMessage(adminStatus, '', '');
});

adminPlayerList?.addEventListener('click', (event) => {
  const button = event.target.closest('button[data-player-id]');
  if (!button || !isAdmin()) return;
  setAdminPlayerEditing(button.dataset.playerId);
});

playerDirectorySearch?.addEventListener('input', (event) => {
  state.playerDirectoryFilters.search = (event.target.value || '').trim();
  renderPlayerDirectory();
});

playerDirectoryGender?.addEventListener('change', (event) => {
  state.playerDirectoryFilters.gender = event.target.value || '';
  renderPlayerDirectory();
});

playerDirectoryRole?.addEventListener('change', (event) => {
  state.playerDirectoryFilters.role = event.target.value || '';
  renderPlayerDirectory();
});

playerDirectoryCategory?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  state.playerDirectoryFilters.category = value;
  if (value) {
    try {
      await loadEnrollments(value);
    } catch (error) {
      console.warn('No fue posible actualizar las inscripciones para el filtro seleccionado', error);
    }
  }
  renderPlayerDirectory();
});

leaguePlayersLeagueSelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  const filters = ensureLeaguePlayerFilters();
  filters.league = value;
  filters.category = '';
  filters.search = '';
  filters.gender = '';
  updateLeaguePlayersControls();
  await refreshLeaguePlayers();
});

leaguePlayersCategorySelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  const filters = ensureLeaguePlayerFilters();
  filters.category = value;
  await refreshLeaguePlayers();
});

leaguePlayersSearch?.addEventListener('input', (event) => {
  const filters = ensureLeaguePlayerFilters();
  filters.search = (event.target.value || '').trim();
  refreshLeaguePlayers().catch((error) => {
    console.warn('No se pudo actualizar el listado de jugadores de liga', error);
  });
});

leaguePlayersGender?.addEventListener('change', (event) => {
  const filters = ensureLeaguePlayerFilters();
  filters.gender = event.target.value || '';
  refreshLeaguePlayers().catch((error) => {
    console.warn('No se pudo actualizar el listado de jugadores de liga', error);
  });
});

leaguePaymentsLeagueSelect?.addEventListener('change', async (event) => {
  const value = event.target.value || '';
  const filters = ensureLeaguePaymentFilters();
  const previousLeague = filters.league || '';
  filters.league = value;
  if (value !== previousLeague) {
    filters.search = '';
  }
  updateLeaguePaymentControls();
  try {
    await refreshLeaguePayments({ force: value !== previousLeague });
  } catch (error) {
    console.warn('No se pudo actualizar los pagos de liga tras cambiar la liga seleccionada', error);
  }
});

leaguePaymentsSearchInput?.addEventListener('input', (event) => {
  const filters = ensureLeaguePaymentFilters();
  filters.search = (event.target.value || '').trim();
  refreshLeaguePayments().catch((error) => {
    console.warn('No se pudo actualizar los pagos de liga al filtrar por búsqueda', error);
  });
});

  leaguePaymentsGroups?.addEventListener('submit', (event) => {
    const form = event.target.closest('form[data-league-payment-form="true"]');
    if (!form) {
      return;
    }
    event.preventDefault();
    handleLeaguePaymentFormSubmit(form).catch((error) => {
      console.warn('No se pudo registrar o actualizar el pago de la liga seleccionada', error);
    });
  });

  tournamentPaymentsTournamentSelect?.addEventListener('change', async (event) => {
    const filters = ensureTournamentPaymentFilters();
    const previousTournament = filters.tournament || '';
    const value = (event.target.value || '').trim();
    filters.tournament = value;
    if (value !== previousTournament) {
      filters.search = '';
    }
    updateTournamentPaymentControls();
    try {
      await refreshTournamentPayments({ force: value !== previousTournament });
    } catch (error) {
      console.warn('No se pudo actualizar los pagos de torneo tras cambiar el torneo seleccionado', error);
    }
  });

  tournamentPaymentsSearchInput?.addEventListener('input', (event) => {
    const filters = ensureTournamentPaymentFilters();
    filters.search = (event.target.value || '').trim();
    refreshTournamentPayments().catch((error) => {
      console.warn('No se pudo actualizar los pagos de torneo al filtrar por búsqueda', error);
    });
  });

  tournamentPaymentsGroups?.addEventListener('submit', (event) => {
    const form = event.target.closest('form[data-tournament-payment-form="true"]');
    if (!form) {
      return;
    }
    event.preventDefault();
    handleTournamentPaymentFormSubmit(form).catch((error) => {
      console.warn('No se pudo registrar o actualizar el pago del torneo seleccionado', error);
    });
  });

playerDirectoryList?.addEventListener('click', (event) => {
  const button = event.target.closest('button[data-player-id]');
  if (!button || !isAdmin()) return;
  openPlayerModal(button.dataset.playerId);
});

categoriesList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button[data-category-id]');
  if (!button) return;

  const { categoryId, action } = button.dataset;
  if (!categoryId) return;

  if (action === 'request-enrollment') {
    const previousLabel = button.textContent;
    button.disabled = true;
    button.textContent = 'Enviando solicitud...';
    try {
      await request(`/categories/${categoryId}/enrollment-requests`, { method: 'POST' });
      state.enrollmentRequests.delete(categoryId);
      showGlobalMessage('Solicitud enviada. Un administrador la revisará en breve.');
      await reloadCategories();
    } catch (error) {
      showGlobalMessage(error.message, 'error');
    } finally {
      if (document.body.contains(button)) {
        button.disabled = false;
        button.textContent = previousLabel;
      }
    }
    return;
  }

  if (!isAdmin()) return;

  if (action === 'review-requests') {
    openEnrollmentModal(categoryId, { focusRequests: true });
    return;
  }

  if (action === 'enrollments') {
    openEnrollmentModal(categoryId);
  } else {
    openCategoryModal(categoryId);
  }
});

upcomingList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button');
  if (!button) return;

  const { action } = button.dataset;
  if (action === 'paginate') {
    event.preventDefault();
    handleMatchPagination(button.dataset);
    return;
  }

  const { matchId } = button.dataset;
  if (!matchId) return;

  if (action === 'delete-match') {
    await deleteMatchById(matchId, { button });
    return;
  }

  if (action === 'report-result' || action === 'edit-result') {
    openResultModal(matchId);
    return;
  }

  if (!isAdmin()) return;
  openMatchModal(matchId);
});

pendingApprovalsList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button');
  if (!button) return;

  const { action } = button.dataset;
  if (action === 'paginate') {
    event.preventDefault();
    handleMatchPagination(button.dataset);
    return;
  }

  const { matchId } = button.dataset;
  if (!matchId) return;

  if (action === 'delete-match') {
    await deleteMatchById(matchId, { button });
    return;
  }

  if (action === 'report-result' || action === 'edit-result') {
    openResultModal(matchId);
    return;
  }

  if (!isAdmin()) return;
  openMatchModal(matchId);
});

completedMatchesList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button');
  if (!button) return;

  const { action } = button.dataset;
  if (action === 'paginate') {
    event.preventDefault();
    handleMatchPagination(button.dataset);
    return;
  }

  const { matchId } = button.dataset;
  if (!matchId) return;

  if (action === 'delete-match') {
    await deleteMatchById(matchId, { button });
    return;
  }

  if (action === 'report-result' || action === 'edit-result') {
    openResultModal(matchId);
    return;
  }

  if (!isAdmin()) return;
  openMatchModal(matchId);
});

globalLeaguesList?.addEventListener('click', (event) => {
  const button = event.target.closest('button[data-global-league-id]');
  if (!button) return;
  const leagueId = normalizeId(button.dataset.globalLeagueId);
  if (!leagueId) return;
  openLeagueEnrollmentModal(leagueId);
});

globalTournamentsList?.addEventListener('click', (event) => {
  const button = event.target.closest('button[data-global-tournament-id]');
  if (!button) return;
  const tournamentId = normalizeId(button.dataset.globalTournamentId);
  if (!tournamentId) return;
  openTournamentSelfEnrollmentModal({ tournamentId });
});

leagueActiveList?.addEventListener('click', (event) => {
  const button = event.target.closest('button[data-league-id]');
  if (!button) return;

  const leagueId = normalizeId(button.dataset.leagueId);
  if (!leagueId) {
    return;
  }

  showSection('section-leagues');

  if (state.selectedLeagueId !== leagueId) {
    state.selectedLeagueId = leagueId;
  }

  renderLeagues(state.leagues);
});

leagueEnrolledPagination?.addEventListener('click', (event) => {
  const button = event.target.closest('button[data-page]');
  if (!button) return;

  const page = Number(button.dataset.page);
  if (!Number.isFinite(page) || page === state.leagueDashboardPlayersPage) {
    return;
  }

  state.leagueDashboardPlayersPage = page;
  const players = Array.isArray(state.leagueDashboard?.enrolledPlayers)
    ? state.leagueDashboard.enrolledPlayers
    : [];
  renderLeagueEnrolledPlayers(players);
});

leaguesList?.addEventListener('click', (event) => {
  const actionButton = event.target.closest('button[data-action]');
  if (actionButton) {
    const { action, leagueId } = actionButton.dataset;
    if (action === 'request-league-enrollment' && leagueId) {
      openLeagueEnrollmentModal(leagueId);
      return;
    }
    if (action === 'edit' && leagueId) {
      openLeagueModal(leagueId);
      return;
    }
    if (action === 'delete' && leagueId) {
      deleteLeagueById(leagueId, { button: actionButton });
      return;
    }
    return;
  }

  if (event.target.closest('.league-actions')) {
    return;
  }

  const button = event.target.closest('.list-item-button[data-league-id]');
  const item = button || event.target.closest('li[data-league-id]');
  if (!item) return;

  const leagueId = normalizeId(button ? button.dataset.leagueId : item.dataset.leagueId);
  if (!leagueId || leagueId === state.selectedLeagueId) {
    return;
  }

  state.selectedLeagueId = leagueId;
  renderLeagues(state.leagues);
});

categoryLeagueFilter?.addEventListener('change', () => {
  const filters = ensureCategoryFilters();
  filters.league = categoryLeagueFilter.value || '';
  renderCategories(state.categories);
});

categoryCreateButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  openCategoryModal();
});

leagueCreateButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  openLeagueModal();
});

leagueEditButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  const leagueId = state.selectedLeagueId;
  if (!leagueId) {
    return;
  }
  openLeagueModal(leagueId);
});

tournamentCreateButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  openTournamentModal();
});

tournamentEditButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  const tournamentId = state.selectedTournamentId;
  if (!tournamentId) {
    return;
  }
  openTournamentModal(tournamentId);
});

tournamentCategoryCreateButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  const preferred = state.selectedTournamentCategoriesId || state.selectedTournamentId || '';
  openTournamentCategoryModal({ tournamentId: preferred });
});

tournamentEnrollmentAddButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  openTournamentEnrollmentModal();
});

tournamentDrawGenerateButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  openTournamentDrawModal();
});

demoModeGenerateButton?.addEventListener('click', async () => {
  if (!isAdmin()) {
    return;
  }

  const confirmed = await openConfirmationDialog({
    title: 'Generar jugadores demo',
    message:
      'Se crearán cuentas de demostración con nombres de jugadores profesionales. Las cuentas existentes se mantendrán. ¿Deseas continuar?',
    confirmLabel: 'Generar',
    cancelLabel: 'Cancelar',
  });

  if (!confirmed) {
    return;
  }

  resetDemoModeResults();
  setStatusMessage(demoModeStatus, 'info', 'Generando jugadores demo...');
  demoModeGenerateButton.disabled = true;

  try {
    const result = await request('/players/demo', { method: 'POST' });
    renderDemoModeResults(result);
    const hasNewPlayers = Number(result?.totalCreated) > 0;
    const message = hasNewPlayers
      ? 'Se generaron los jugadores demo correctamente.'
      : 'Las cuentas demo ya estaban creadas.';
    setStatusMessage(demoModeStatus, 'success', message);
  } catch (error) {
    console.warn('No se pudo generar el modo demo', error);
    const message = error?.message || 'No se pudo generar el modo demo.';
    setStatusMessage(demoModeStatus, 'error', message);
  } finally {
    demoModeGenerateButton.disabled = false;
  }
});

playerCreateButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  openPlayerModal();
});

matchGenerateButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  const defaultCategory =
    state.selectedCategoryId || normalizeId(state.categories[0]) || '';
  openGenerateMatchesModal(defaultCategory);
});

matchCreateButton?.addEventListener('click', () => {
  if (!isAdmin()) return;
  openMatchModal();
});

tournamentMatchesList?.addEventListener('click', (event) => {
  const button = event.target.closest('button[data-action]');
  if (!button || !isAdmin()) {
    return;
  }

  const { matchId, tournamentId = '', categoryId = '', action } = button.dataset;
  if (!matchId) {
    return;
  }

  if (action === 'schedule-tournament-match') {
    openTournamentMatchScheduleModal(matchId, { tournamentId, categoryId });
  } else if (action === 'record-tournament-result') {
    openTournamentMatchResultModal(matchId, { tournamentId, categoryId });
  }
});

tournamentBracketView?.addEventListener('click', (event) => {
  const button = event.target.closest('button[data-action]');
  if (!button || !isAdmin()) {
    return;
  }

  const { matchId, tournamentId = '', categoryId = '', action } = button.dataset;
  if (!matchId) {
    return;
  }

  if (action === 'schedule-tournament-match') {
    openTournamentMatchScheduleModal(matchId, { tournamentId, categoryId });
  } else if (action === 'record-tournament-result') {
    openTournamentMatchResultModal(matchId, { tournamentId, categoryId });
  }
});

modalClose?.addEventListener('click', () => {
  closeModal();
});

modalOverlay?.addEventListener('click', (event) => {
  if (event.target === modalOverlay) {
    closeModal();
  }
});

document.addEventListener('keydown', (event) => {
  if (event.key !== 'Escape') {
    return;
  }

  let handled = false;

  if (!modalOverlay?.hidden) {
    closeModal();
    handled = true;
  }

  if (isMobileMenuOpen()) {
    closeMobileMenu({ restoreFocus: true });
    handled = true;
  }

  if (handled) {
    event.preventDefault();
  }
});

adminMatchSelect?.addEventListener('change', (event) => {
  const matchId = event.target.value;
  if (!matchId) {
    resetAdminMatchForm();
    return;
  }
  setAdminMatchEditing(matchId);
});

adminMatchList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button[data-match-id]');
  if (!button || !isAdmin()) return;

  const { matchId, action } = button.dataset;
  if (!matchId) return;

  if (action === 'delete') {
    await deleteMatchById(matchId, { statusElement: adminMatchStatusMessage, button });
    return;
  }

  setAdminMatchEditing(matchId);
});

adminMatchCancel?.addEventListener('click', () => {
  resetAdminMatchForm();
});

adminMatchDelete?.addEventListener('click', async () => {
  if (!isAdmin()) return;
  const matchId = state.adminMatchEditingId || adminMatchSelect?.value;
  if (!matchId) {
    setStatusMessage(
      adminMatchStatusMessage,
      'error',
      'Selecciona un partido pendiente o programado para poder eliminarlo.'
    );
    return;
  }

  await deleteMatchById(matchId, {
    statusElement: adminMatchStatusMessage,
    button: adminMatchDelete,
  });
});

adminMatchForm?.addEventListener('submit', async (event) => {
  event.preventDefault();
  if (!isAdmin()) return;

  const matchId = state.adminMatchEditingId || adminMatchSelect?.value;
  if (!matchId) {
    setStatusMessage(adminMatchStatusMessage, 'error', 'Selecciona un partido para actualizar.');
    return;
  }

  const succeeded = await submitMatchFormData({
    form: adminMatchForm,
    matchId,
    statusElement: adminMatchStatusMessage,
    creating: false,
  });

  if (succeeded) {
    if (state.calendarMatches.some((match) => (match._id || match.id) === matchId)) {
      setAdminMatchEditing(matchId);
    } else {
      resetAdminMatchForm();
    }
  }
});

myMatchesList?.addEventListener('click', async (event) => {
  const button = event.target.closest('button[data-action]');
  if (!button || !state.token) return;

  const { action, matchId } = button.dataset;
  if (!matchId || !action) return;

  button.disabled = true;

  try {
    if (action === 'edit-match') {
      button.disabled = false;
      if (isAdmin()) {
        openMatchModal(matchId);
      }
      return;
    }

    if (action === 'delete-match') {
      await deleteMatchById(matchId, { button });
      return;
    }

    if (action === 'report-result') {
      button.disabled = false;
      openResultModal(matchId);
      return;
    } else if (action === 'propose') {
      openProposalForm(matchId, button);
      return;
    } else if (action === 'respond') {
      const { decision } = button.dataset;
      if (!decision) return;

      await request(`/matches/${matchId}/respond`, {
        method: 'POST',
        body: {
          decision,
        },
      });

      const message = decision === 'accept' ? 'Partido confirmado.' : 'Se rechazó la propuesta.';
      showGlobalMessage(message, 'info');
    } else if (action === 'confirm-result' || action === 'reject-result') {
      const decision = action === 'confirm-result' ? 'approve' : 'reject';
      await request(`/matches/${matchId}/result/confirm`, {
        method: 'POST',
        body: { decision },
      });
      const message =
        decision === 'approve'
          ? 'Resultado confirmado.'
          : 'Has rechazado el resultado. Regístralo nuevamente si es necesario.';
      showGlobalMessage(message, 'info');
    }

    await loadAllData();
  } catch (error) {
    showGlobalMessage(error.message, 'error');
  } finally {
    button.disabled = false;
  }
});

if (state.push.supported) {
  window.addEventListener('focus', () => {
    const permission = Notification.permission;
    if (state.push.permission !== permission) {
      state.push.permission = permission;
      updatePushSettingsUI();
    }
  });
}

if (state.push.supported) {
  ensurePushServiceWorker();
}

updatePushSettingsUI();

function applyInitialSectionFromLocation() {
  if (typeof window === 'undefined') {
    return;
  }

  const sectionId = getSectionIdFromPath(window.location.pathname);
  if (sectionId) {
    state.activeSection = sectionId;
  }
}

async function init() {
  resetData();
  loadRememberedCredentials();
  await checkSetupStatus();
  restoreSession();
  applyInitialSectionFromLocation();
  shouldReplaceHistoryOnNextSection = true;
  updateAuthUI();
  if (state.token) {
    await loadAllData();
  }
}

init();
